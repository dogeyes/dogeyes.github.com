<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>dogeyes</title>
        <description>dogeyes - dogeyes</description>
        <link>http://username.github.com</link>
        <link>http://username.github.com</link>
        <lastBuildDate>2013-03-13T13:36:07+08:00</lastBuildDate>
        <pubDate>2013-03-13T13:36:07+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>C1 Getting Started</title>
                <description>&lt;h1&gt;chapter1 Getting Started&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;sx&quot;&gt;% ruby&lt;/span&gt;
&lt;span class=&quot;sx&quot;&gt;puts &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



</description>
                <link>http://username.github.com/programming%20ruby/2013/03/13/c1-getting-started</link>
                <guid>http://username.github.com/programming%20ruby/2013/03/13/c1-getting-started</guid>
                <pubDate>2013-03-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>preface</title>
                <description>&lt;p&gt;I wanted a language more powerful than Perl and more object-oriented than Python.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fred#do_something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instance method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fred.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;class method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fred::EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;class constant&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Facets of Ruby&lt;/li&gt;
&lt;li&gt;Ruby in Its Setting&lt;/li&gt;
&lt;li&gt;Ruby Crystallized&lt;/li&gt;
&lt;li&gt;Ruby Library Reference&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://username.github.com/programming%20ruby/2013/03/13/c0-preface</link>
                <guid>http://username.github.com/programming%20ruby/2013/03/13/c0-preface</guid>
                <pubDate>2013-03-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll</title>
                <description>&lt;h1&gt;CygWin下Jekyll的安装&lt;/h1&gt;

&lt;p&gt;主要是依靠&lt;a href=&quot;http://xialuxing.com/2012/05/11/cygwin-jekyll-bootstrap/&quot;&gt;在Cygwin下配置jekyll bootstrap&lt;/a&gt;
这篇文章,写的很清楚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装Cygwin&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装ruby的依赖yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ wget http://pyyaml.org/download/libyaml/yaml-0.1.4.tar.gz
  $ tar xf yaml-0.1.4.tar.gz
  $ cd yaml-0.1.4
  $ ./configure --prefix=/usr/local/yaml &amp;amp;&amp;amp; make -j2 
  $ make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ wget http://ruby.taobao.org/mirrors/ruby/ruby-1.9.2-p320.tar.bz2
  $ tar xf ruby-1.9.2-p320.tar.bz2
  $ cd ruby-1.9.2-p320
  $ ./configure --prefix=/usr/local/ruby19 --with-opt-dir=/usr/local/yaml/ &amp;amp;&amp;amp; make -j2 
  $ make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置PATH&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ echo 'PATH=/usr/local/ruby19/bin:$PATH' &amp;gt;&amp;gt;~/.bashrc
  $ source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装gem&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ wget http://production.cf.rubygems.org/rubygems/rubygems-1.8.24.tgz
  $ tar xf rubygems-1.8.24.tgz
  $ cd rubygems-1.8.24
  $ ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装posix-spawn&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ git clone git://github.com/rtomayko/posix-spawn.git
  $ cd posix-spawn
  $ gem build posix-spawn.gemspec
  $ gem install posix-spawn-0.3.6.gem
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装jekyll以及Redcloth,rdiscount&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ gem instal -V jekyll RedCloth rdiscount
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修复&lt;code&gt;invalid byte sequence in GBK&lt;/code&gt;问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ echo -e 'export LC_ALL=&quot;en_US.UTF-8&quot;\nexport LANG=&quot;en_US.UTF-8&quot;' &amp;gt;&amp;gt;~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其实在Cygwin中ruby,gem可以通过源来安装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pygments语法高亮&lt;/p&gt;

&lt;p&gt;  Pygments的easy_install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ easy_install Pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  Pygments提供了多种样式,比如’native’, ‘emacs’, ‘vs’等等，可以在&lt;a href=&quot;http://pygments.org/demo&quot;&gt;Pygments Demo&lt;/a&gt;中选择某种语言的例子，体验不同的样式。&lt;/p&gt;

&lt;p&gt;  通过下面的命令查看当前支持的样式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt;python
  &amp;gt;&amp;gt;&amp;gt; from pygments.styles import STYLE_MAP
  &amp;gt;&amp;gt;&amp;gt;STYLE_MAP.keys()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  选择一种样式,应用在Jekyll中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cd *****.github.com/assets/themes/***/css&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pygmentize -S native -f html &amp;gt; pygments.css&lt;/code&gt; &quot;native&quot;是样式名,&quot;html&quot;是formatter&lt;/li&gt;
&lt;li&gt;在layout中应用刚刚加的pygments.css,如在_layouts/default.html中加入&lt;code&gt;&amp;lt;link href=&quot;/path/to/css/pygments.css&quot; rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt;这一行&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  在文章中使用高亮代码&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{% highlight java %}
public class HelloWorld {
    public static void main(String args[]) {
        System.out.println(&amp;quot;Hello World!&amp;quot;);
    }
}
{% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HelloWorld&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



</description>
                <link>http://username.github.com/Jekyll/2013/03/01/jekyll</link>
                <guid>http://username.github.com/Jekyll/2013/03/01/jekyll</guid>
                <pubDate>2013-03-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>排错</title>
                <description>&lt;h1&gt;第五章 排错&lt;/h1&gt;

&lt;p&gt;程序的复杂性与各个部件间可能相互作用的途径书目有关.减弱软件各部件间的关联,使存在交互作用的程序片段更少.包括信息屏蔽,抽象和界面,以及各种支持他们的语言特征&lt;/p&gt;

&lt;p&gt;保证程序的完整性:程序证明,模型技术,需求分析,形式化验证&lt;/p&gt;

&lt;p&gt;好的程序员知道他们在排错上花费的时间至少与写程序一样多,所以努力冲错误中学习,你发现的任何错误都能教导你如何防止类似错误的再次发生,以及在发生这种问题时及早识别它.&lt;/p&gt;

&lt;p&gt;减少排错时间有所帮助的技术: 好的设计,好的风格,边界条件测试,代码中的断言和合理性检查,防御性程序设计,设计良好的界面,限制全局数据结构,检查工具.&lt;/p&gt;

&lt;p&gt;早期防御胜过事后治疗&lt;/p&gt;

&lt;p&gt;程序设计语言: 下表范围检查,受限制的指针或取消指针,废料收集,字符串数据类型,带类型的I/O以及强类型检查等等&lt;/p&gt;

&lt;p&gt;容易引起错误的语言特性: goto语句,全局变量,无限制的指针,自动类型转换.&lt;/p&gt;

&lt;p&gt;留意警告&lt;/p&gt;

&lt;h2&gt;5.1 排错系统&lt;/h2&gt;
</description>
                <link>http://username.github.com/TPOP/2013/02/27/error</link>
                <guid>http://username.github.com/TPOP/2013/02/27/error</guid>
                <pubDate>2013-02-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>界面</title>
                <description>&lt;h1&gt;第4章 界面&lt;/h1&gt;

&lt;p&gt;在造墙之前,我必须设法弄清
该把什么放在墙里,什么放在墙外,
最需要防御的又是什么.
确实有些东西不喜欢墙,
总希望它倒下来.
---Robert Frost, &amp;lt;&amp;lt;修墙&gt;&gt;&lt;/p&gt;

&lt;p&gt;设计的真谛,就是在一些相互冲突的需求和约束条件之间寻找平衡点.&lt;/p&gt;

&lt;p&gt;在进行设计时,要考虑的问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;界面: 应该提供哪些服务和访问? 界面在效能上实际成为服务的提供者和使用者之间的一个约定.同一方便的服务,功能足够丰富,但又不过多而无法控制.&lt;/li&gt;
&lt;li&gt;信息隐藏: 哪些信息可见,哪些不可见. 访问方便,同时隐藏实现细节.&lt;/li&gt;
&lt;li&gt;资源管理: 谁负责管理内存或者其他资源? 主要问题是存储的分配和释放,以及管理共享信息的拷贝等.&lt;/li&gt;
&lt;li&gt;错误处理: 谁检查错误,谁报告,如何恢复?&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;4.1 逗号分隔的值&lt;/h2&gt;

&lt;p&gt;逗号分隔的值(comma-separated value, CSV),用于表示表格数据的自然形式.&lt;/p&gt;

&lt;h2&gt;4.2 一个原型库&lt;/h2&gt;

&lt;p&gt;不大可能在第一次设计函数库或者界面时就做的很好.&quot;要计划扔掉一个,你总会这样做,无论以什么方式&quot;&lt;/p&gt;

&lt;p&gt;只有在已经构造和使用了程序的一个版本之后,才能对如何把系统设计正确有足够的认识&lt;/p&gt;

&lt;p&gt;先搞出一个将要丢掉的,搞出一个原型.&lt;/p&gt;

&lt;p&gt;strtok(p, s) 返回p中的一个标示符的指针,标示符完全由不再s中的字符构成. 第一次调用时p是原始字符串,而以后p是NULL,以从前一次调用结束的地方继续下去.(同时调用多个strtok会相互干扰)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(q = buf;(p = strtok(q, &quot;,\n\r&quot;)) != NULL; q = NULL)
    field[nfield++] = unquote(p);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对特定的数据可以进行处理,但是长的输入行,很多的数据域以及未预料到的或者欠缺的分隔符都可能造成大麻烦&lt;/p&gt;

&lt;p&gt;一些需要仔细思考的问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有处理特别长的行,很多域,没有检查溢出,没有报错&lt;/li&gt;
&lt;li&gt;假定输入是换行字符结尾的行组成&lt;/li&gt;
&lt;li&gt;数据域由逗号分隔,数据域前后的引号被去除,没有考虑嵌套的引号和逗号&lt;/li&gt;
&lt;li&gt;输入行没有保留, 在构造数据域的过程中将它覆盖掉了&lt;/li&gt;
&lt;li&gt;在从一行输入转到另一行时没有保留任何数据,如果需要记录什么东西,那么就必须做一个拷贝&lt;/li&gt;
&lt;li&gt;对数据域的访问通过全局变量,对数据域内容或指针的访问都没有任何控制,对超出最后一个域的访问也没有任何防御措施&lt;/li&gt;
&lt;li&gt;使用全局变量,多线程环境无法使用,甚至不能两个交替进行的条用序列&lt;/li&gt;
&lt;li&gt;调用库的程序必须显式打开或关闭文件&lt;/li&gt;
&lt;li&gt;输入和划分操作纠缠在一起:每个调用读入一行并把它切分成一些域,不管实际应用中是否真的需要后一个服务&lt;/li&gt;
&lt;li&gt;函数返回值表示输入行中的数据域个数,每行都被切分,无法把错误和文件结束区分开&lt;/li&gt;
&lt;li&gt;除了改变代码外,没有任何办法来改变这些特性&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;但是如此多的改变都可以一起实现吗,如何实现?&lt;/p&gt;

&lt;h2&gt;4.3 为别人用的库&lt;/h2&gt;

&lt;p&gt;一个比较明确的需求是,csvgetline更健壮,使它能够处理很长的行和很多域,也必须能更仔细地剖析数据域&lt;/p&gt;

&lt;p&gt;界面,信息隐藏,资源管理,错误处理&lt;/p&gt;

&lt;h4&gt;界面&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;char&lt;em&gt; csvgetline(FILE&lt;/em&gt;): 读取一个新CSV行&lt;/li&gt;
&lt;li&gt;char* csvfield(int n): 返回当前行的第n个数据域&lt;/li&gt;
&lt;li&gt;int csvfield(void): 返回当前行中数据域的个数&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;信息隐藏&lt;/h4&gt;

&lt;p&gt;存储管理师对外隐藏的,到底是分配了一个大数组来存储行还是通过扩展来存储行&lt;/p&gt;

&lt;p&gt;域的切分是在读取时进行的,还是在对数据域的访问时进行的也是对用户隐藏的&lt;/p&gt;

&lt;h4&gt;资源管理&lt;/h4&gt;

&lt;p&gt;谁负责共享信息,返回原始数据还是返回一个拷贝&lt;/p&gt;

&lt;p&gt;文件的管理,做文件打开的部分也应该负责关闭: 相互匹配的操作应该在同一个层次或位置完成.&lt;/p&gt;

&lt;p&gt;在一个库与它的调用程序之间共享的,或者传递通过他们之间的界限的资源,管理起来总是很困难,这里经常出现一些合理而又相互矛盾的道理,要求我们做这种或者那种选择.在共享资源的责任方面常常出现错误或误解,这是程序错误最常见的根源之一.&lt;/p&gt;

&lt;h4&gt;错误处理&lt;/h4&gt;

&lt;p&gt;错误通过返回来标记还是通过一个函数查询来标记&lt;/p&gt;

&lt;p&gt;一个基本的原则是当错误发生时,库函数绝不能简单的死掉,而是应该把错误状态返回给调用程序,以便那里能采取适当的措施.另一方面,库函数也不应该输出错误信息,或者弹出一个会话框,因为这个程序将来可能运行在某些环境里,在那里这种信息可能干扰其他东西.&lt;/p&gt;

&lt;h4&gt;规范&lt;/h4&gt;

&lt;p&gt;把上面的这些决定汇集在一起,就形成一个规范,它说明了csvgetline能够提供什么服务,应该如何使用.&lt;/p&gt;

&lt;p&gt;在实践中规范和实现虽然可能来自不同的机构,但是两者一起发展.&lt;/p&gt;

&lt;p&gt;规范最好及早提出,并随着实现中学到的新情况,对规范进行必要的修改.规范写的越精确越好,程序工作的很好的可能性就越大.&lt;/p&gt;

&lt;p&gt;目前而言,规范包括函数原型,函数行为的细节描述,各种责任和假设:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;域由都好分隔&lt;/li&gt;
&lt;li&gt;一个域可能由一对双引号&quot;...&quot;括起&lt;/li&gt;
&lt;li&gt;一个括起的域中可以包含逗号,但不能有换行&lt;/li&gt;
&lt;li&gt;一个括起的域中可以包含双引号&quot;本身, 表示为&quot;&quot;&lt;/li&gt;
&lt;li&gt;域可以为空; &quot;&quot;和一个空串都表示空的域&lt;/li&gt;
&lt;li&gt;引导的和尾随的空格将预留&lt;/li&gt;
&lt;li&gt;char &lt;em&gt;csvgetline(FILE&lt;/em&gt; f);&lt;/br&gt;
从打开的文件f中读入一行;输入行以\r,\n,\r\n,或EOF结束;返回指向行的指针,行中结束符去掉;如果遇到EOF则返回NULL;行可以任意长,超出存储限度返回NULL;行必须当作只读存储看待;如果需要保存或修改,调用者必须自己建立拷贝.&lt;/li&gt;
&lt;li&gt;char *csvfield(int n);&lt;/br&gt;
域从0开始;返回由csvgetline最近读入行的第n个域;如果n&amp;lt;0或者超出最后一个域,则返回NULL;域由逗号分隔;域可以用&quot;...&quot;括起来,这些引号将被去除;在&quot;...&quot;内部的&quot;&quot;用&quot;取代,内部逗号不作为分隔符.在没有引号括起来的域里,引号当作普通字符;允许有任意个数和任意长度的域;如果超出存储的限度,返回NULL;域必须当作只读存储看待;如果需要保存或修改,调用者必须自己建立拷贝;在调用csvgetline之前调用本函数,行为没有定义;&lt;/li&gt;
&lt;li&gt;int csvnfield(void);&lt;/br&gt;
返回由csvgetline最近读入的行的域的个数;在调用csvgetline之前调用本函数,其行为没有定义.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;还有许多问题没有被考虑,如EOF之后调用csvnfield和csvfield,将返回什么,具体错误形式的域将如何处理?&lt;/p&gt;

&lt;p&gt;同文件包含函数声明，是界面的公共部分&lt;/p&gt;

&lt;p&gt;通过static，使全局变量只在定义的文件中可见&lt;/p&gt;

&lt;h2&gt;4.4 c++实现&lt;/h2&gt;

&lt;p&gt;c可以通过struct进行封装&lt;/p&gt;

&lt;h2&gt;4.5 界面原则&lt;/h2&gt;

&lt;p&gt;界面定义了某个代码提为其用户提供的各种东西，定义了哪些功能或者数据元素可以为程序的其他部分使用&lt;/p&gt;

&lt;p&gt;简单，通用，规范，其行为可以预料及坚固，还必须很好地适应用户或者实现方式的变化&lt;/p&gt;

&lt;h4&gt;隐藏实现细节&lt;/h4&gt;

&lt;p&gt;信息隐蔽，封装，抽象，模块化&lt;/p&gt;

&lt;p&gt;如果头文件里不包含实际结构的声明，而只有结构的名字，这种情况被称为模糊类型，其特性本身无法看到，所有操作都通过指针方式进行，实际的数据对象则潜藏在指针后面&lt;/p&gt;

&lt;p&gt;避免使用全局变量，如果可能，数据通过函数参数传递&lt;/p&gt;

&lt;p&gt;选择一小组正交的基本操作。 一个界面应该提供外界所需要的全部功能，但绝不要更多，函数在功能方面不应该有过度重叠。同一功能多种方式，这种冗余是要反对的。&lt;/p&gt;

&lt;p&gt;窄的界面比宽的界面更受欢迎。做一件事并且把它做好。不要因为一个界面可能做某些事就给它增加这些东西。如果实现方面出了毛病那么就不要去修改界面。&lt;/p&gt;

&lt;p&gt;不要在用户背后做小动作。一个库函数不应该写某个秘密文件、修改某个秘密变量，或者改变某些全局性数据，在改变调用者的数据时也要特别谨慎。&lt;/p&gt;

&lt;p&gt;一个界面在使用时不应该强求另外的东西，如果这样做仅仅是为了设计者或实现者的某些方便。应该使界面成为自给自足。如果确实无法做到这一点，那么也应该把需要哪些外部服务的问题做成明显的。&lt;/p&gt;

&lt;p&gt;在各处都用同样的方式做同样的事. 一致性和规范性非常重要,相关的事物应该有相关的意义.&lt;/p&gt;

&lt;p&gt;外部一致性。 与其他东西的行为类似也是非常重要的。比如*是通配符等等&lt;/p&gt;

&lt;h2&gt;4.6 资源管理&lt;/h2&gt;

&lt;p&gt;在设计库的界面时，一个最困难的问题就是管理某些资源，这些资源是库所拥有的，而又在库和它的调用程序之间共享。最明显的资源是存储--谁负责分配和释放存储；打开的文件，共同关心的变量状态。&lt;/p&gt;

&lt;p&gt;初始化，状态维护，共享和复制，清除&lt;/p&gt;

&lt;p&gt;初始化方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;静态初始化&lt;/li&gt;
&lt;li&gt;初始化函数&lt;/li&gt;
&lt;li&gt;类的初始函数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;终止和析构&lt;/p&gt;

&lt;p&gt;资源的清理回收，文件的关闭&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;释放资源与分配资源应该在同一层次进行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;资源的分配状态在跨过界面时不应该改变&lt;/p&gt;

&lt;p&gt;废料收集机制， 收集动作发生的时间无法预期&lt;/p&gt;

&lt;p&gt;代码可重入， 无论存在多少个同时的执行，它都应该能正常工作&lt;/p&gt;

&lt;p&gt;可重入代码要求避免使用全局变量，静态局部变量，以及其他可能在别的线程里改变的变量&lt;/p&gt;

&lt;p&gt;对于好的多线程设计，最关键的是做好各部件之间的隔离，使他们除了经过良好设计的界面外不再共享任何东西。随意把变量暴露出来共享的库就破坏了这个模型。 如果存在必须的共享变量，必须把他们放在某种锁定机制中，确保一次只有一个线程访问他们（Java的同步方法）&lt;/p&gt;

&lt;h2&gt;4.7 终止、重试或失败&lt;/h2&gt;

&lt;p&gt;eprintf 和 estrdup等函数&lt;/p&gt;

&lt;p&gt;&amp;lt;stdarg.h&gt;头文件,va_start初始化,va_end终止处理&lt;/p&gt;

&lt;p&gt;错误发生时,有时终止不是一个好的选择,这将完全排除程序其他部分进行恢复的可能性.&lt;/p&gt;

&lt;p&gt;在低层检查错误,在高层处理它们.一般情况下,应该由调用程序决定对错误的处理方式,而不该由被调用程序决定.尤其是库函数,应该以某种得体的失败方式在这方面起作用.&lt;/p&gt;

&lt;p&gt;可以通过返回一个特定的值来标明特定的错误.&lt;/p&gt;

&lt;p&gt;也可以返回单一异常值,再通过特定函数来读取错误信息&lt;/p&gt;

&lt;p&gt;unix和c标准库的 errno变量和strerror函数&lt;/p&gt;

&lt;p&gt;只把异常用在异常情况.对可预期的结果(如读到文件末尾等)不进行异常处理,而是返回特定值.异常最好留给那些无法预期的事件(如文件系统满或者浮点错误等等)&lt;/p&gt;

&lt;p&gt;通过setjmp和longjmp可以实现一套异常处理机制&lt;/p&gt;

&lt;p&gt;发生错误时应该如何恢复有关的资源,如果发生个错误,库函数应该做这种恢复吗?通常它们不做这些事,但也可以在这方面提供一些帮助:提供尽可能清楚的信息和以尽可能无害的方式退出&lt;/p&gt;

&lt;h2&gt;4.8 用户界面&lt;/h2&gt;

&lt;p&gt;显示的信息应该尽可能详细,不要简单的说发生错误,而应该标明哪个程序发生什么错误,在可能的情况下要指明正确的方式是什么.&lt;/p&gt;

&lt;p&gt;防御性程序设计,保证程序在遇到坏的输入时本身不会受到损害.&lt;/p&gt;

&lt;p&gt;图形用户界面. 很难做正确,通常实现交互的代码比实现所完成工作算法的代码更多&lt;/p&gt;

&lt;p&gt;界面:简单性,清晰性,规范性,统一性,熟悉性,严谨性&lt;/p&gt;

&lt;p&gt;对实现图形用户界面而言,面向对象的程序设计远胜于其他方法,因为它提供了一种途径,能够封装各种窗口的行为和状态细节,通过集成来取得基类的相似性,通过导出类区分相互的差异.&lt;/p&gt;
</description>
                <link>http://username.github.com/TPOP/2013/02/26/interface</link>
                <guid>http://username.github.com/TPOP/2013/02/26/interface</guid>
                <pubDate>2013-02-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>shell脚本编程进阶 chapter27 LCLSS</title>
                <description>&lt;h1&gt;第27章 shell脚本进阶&lt;/h1&gt;

&lt;h2&gt;27.1 监测系统统计数据&lt;/h2&gt;

&lt;h3&gt;27.1.1 系统快照报告&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;快照报告&lt;/strong&gt;是特定时间点由系统的统计数据构成的图&lt;/p&gt;

&lt;h4&gt;1. 需要的功能&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;uptime&lt;/code&gt; &lt;code&gt;df&lt;/code&gt; &lt;code&gt;free&lt;/code&gt; &lt;code&gt;ps&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;运行时间&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;uptime&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;li&gt;系统运行的天数,小时和分钟数&lt;/li&gt;
&lt;li&gt;当前登陆到系统上的用户数&lt;/li&gt;
&lt;li&gt;一分钟,五分钟,十分钟的平均负载&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;磁盘使用情况&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;df&lt;/code&gt; 命令&lt;/p&gt;

&lt;h5&gt;内存使用情况&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;free&lt;/code&gt;命令那个&lt;/p&gt;

&lt;h5&gt;僵尸进程&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; 命令&lt;/p&gt;

&lt;h4&gt;2. 创建快照脚本&lt;/h4&gt;

&lt;h3&gt;27.1.2 系统统计数据报告&lt;/h3&gt;

&lt;h4&gt;1. 需要的工具&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 命令&lt;/p&gt;

&lt;h4&gt;2. 创建捕捉脚本&lt;/h4&gt;

&lt;h4&gt;3. 生成报告脚本&lt;/h4&gt;

&lt;h4&gt;4. 运行脚本&lt;/h4&gt;

&lt;h2&gt;27.2 问题跟踪数据库&lt;/h2&gt;

&lt;h3&gt;27.2.1 创建数据库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;报告问题的日期&lt;/li&gt;
&lt;li&gt;解决问题的日期&lt;/li&gt;
&lt;li&gt;问题的描述及症状&lt;/li&gt;
&lt;li&gt;问题解决办法的描述&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;创建空数据库,创建表,4个数据字段,和一个id字段&lt;/p&gt;

&lt;p&gt;mysql 的&lt;code&gt;describe&lt;/code&gt;命令显示表的字段&lt;/p&gt;

&lt;p&gt;创建一个适当权限的新账户&lt;/p&gt;

&lt;h3&gt;27.2.1 记录问题&lt;/h3&gt;

&lt;p&gt;简易脚本封装&lt;/p&gt;

&lt;h4&gt;1. 需要的功能&lt;/h4&gt;

&lt;p&gt;mysql 的 INSERT命令&lt;/p&gt;

&lt;p&gt;命令以&lt;code&gt;;&lt;/code&gt;结尾和以&lt;code&gt;\G&lt;/code&gt;结尾显示方式不同&lt;/p&gt;

&lt;h4&gt;2. 创建脚本&lt;/h4&gt;

&lt;h3&gt;27.2.3 更新问题&lt;/h3&gt;

&lt;h4&gt;1. 需要的功能&lt;/h4&gt;

&lt;p&gt;mysql的update功能&lt;/p&gt;

&lt;h4&gt;2. 创建脚本&lt;/h4&gt;

&lt;h4&gt;3. 附加的修改&lt;/h4&gt;

&lt;h3&gt;27.2.4 查找问题&lt;/h3&gt;

&lt;h4&gt;1. 需要的功能&lt;/h4&gt;

&lt;p&gt;mysql 的 &lt;code&gt;SELECT&lt;/code&gt; 功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; SELECT * FROM problem_logger
 WHERE prob_symptoms LIKE '%yum%'\G
 #查找prob_symptoms字段有yum字符的项

 SELECT * FROM problem_logger
 WHERE prob_symptoms LIKE '%yum%'
 OR
 prob_solutions LIKE '%yum%'\G
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LIKE&lt;/code&gt;命令不支持多个关键字&lt;/p&gt;

&lt;p&gt;&lt;code&gt;REGEXP&lt;/code&gt; 命令支持多个关键字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; SELECT * FROM problem_logger
 WHERE prob_symptoms REGEXP 'yum|dash'
 OR
 WHERE prob_solutions REGEXP 'yum|dash'
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 创建脚本&lt;/h4&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/02/05/chapter27-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/02/05/chapter27-lclss</guid>
                <pubDate>2013-02-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>编写脚本实用工具 chapter26 LCLSS</title>
                <description>&lt;h1&gt;第26章 编写脚本使用工具&lt;/h1&gt;

&lt;h2&gt;26.1 监测磁盘空间&lt;/h2&gt;

&lt;h3&gt;26.1.1 需要的功能&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;du&lt;/code&gt;,每个文件和目录显示磁盘的使用情况&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-s&lt;/code&gt;选项用来在目录一级总结整体使用情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;du -s /home/* #home目录下各文件和目录占用空间大小
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-S&lt;/code&gt;选项,为每个目录和子目录分别提供一个总计&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;命令对输出进行排序 &lt;code&gt;-r&lt;/code&gt;反向, &lt;code&gt;-n&lt;/code&gt;对数值进行排序&lt;/p&gt;

&lt;p&gt;在对输出格式进行调整&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '{11,$D; =}' #只显示前面10行
sed 'N; s/\n/ /' #将行号和内容合并到同一行
gawk '{printf $1 &quot;:&quot; &quot;\t&quot; $2 &quot;\t&quot; $3 &quot;\n&quot;}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;26.1.2 创建脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

CHECK_DIRECTORIES=&quot;/var/log /home&quot;

DATE=$(date '+%m%d%y')

exec &amp;gt; disk_space_$DATE.rpt

echo &quot;Top Ten Disk Space Usage&quot;
echo &quot;for $CEHCK_DIRECTORIES Directories&quot;

for DIR_CHECK in $CHECK_DIRECTORIES
do
    echo &quot;&quot;
    echo &quot;The $DIR_CHECK Directory:&quot;

    du -S $DIR_CHECK 2&amp;gt; /dev/null |
    sort -rn |
    sed '{11,$D; =}' |
    sed 'N; s/\n/ /' |
    gawk '{printf $1 &quot;:&quot; &quot;\t&quot; $2 &quot;\t&quot; $3 &quot;\n&quot;}'  
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;26.1.3 运行脚本&lt;/h3&gt;

&lt;p&gt;可以手动运行&lt;/p&gt;

&lt;p&gt;也可以通过cron表来定期运行&lt;/p&gt;

&lt;h2&gt;26.2 进行备份&lt;/h2&gt;

&lt;h3&gt;26.2.1 归档数据文件&lt;/h3&gt;

&lt;h4&gt;1. 需要的功能&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; 命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -cf archive.tar /home/user/backup_test 2&amp;gt;/dev/null
#将文件夹归档成一个tar文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以加&lt;code&gt;-z&lt;/code&gt;选项进行压缩&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -zcf archive.tar /home/user/backup_test 2&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用配置文件包含你要归档的文件或目录&lt;/p&gt;

&lt;p&gt;通过脚本读取配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec &amp;lt; $CONFIG_FILE
read FILE_NAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;处理过程中简单的判断文件是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ -f $FILE_NAME -o -d $FILE_NAME ]
then
    FILE_LIST=&quot;$FILE_LIST $FILE_NAME&quot;
else
    echo
    echo &quot;$FILE_NAME, does not exist.&quot;
    echo &quot;Obviously, I will not include it in this archive.&quot;
    echo &quot;It is listed on line $FIlE_NO of the config file.&quot;
    echo &quot;Continuing to build archive list…&quot;
    echo
fi
FILE_NO=$[ $FILE_NO + 1 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 创建按日期归档的脚本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;DATE=`date +%m%d%y`
FILE=archive$DATE.tar.gz
CONFIG_FILE=/home/user/archive/Files_To_Backup
DESTINATION=/home/user/archive/$FILE

if [ -f $CONFIG_FILE ]
then
    echo
else
    echo
    echo &quot;$CONFIG_FILE does not exist&quot;
    echo &quot;BACKUP not completed due to missing Configuration File&quot;
    echo
    exit
fi

FILE_NO=1
exec &amp;lt; $CONFIG_FILE

read FILE_NAME
while [ $? -eq 0 ]
do
    if [ -f $FILE_NAME -o -d $FILE_NAME ]
then
    FILE_LIST=&quot;$FILE_LIST $FILE_NAME&quot;
else
    echo
    echo &quot;$FILE_NAME, does not exist.&quot;
    echo &quot;Obviously, I will not include it in this archive.&quot;
    echo &quot;It is listed on line $FIlE_NO of the config file.&quot;
    echo &quot;Continuing to build archive list…&quot;
    echo
    fi
    FILE_NO=$[ $FILE_NO + 1 ]
    read FILE_NAME
done

tar -czf $DESTINATION $FILE_LIST 2&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 运行按日期归档的脚本&lt;/h4&gt;

&lt;h4&gt;4. 创建按小时归档的脚本&lt;/h4&gt;

&lt;p&gt;按小时归档归档文件将很多,可以考虑构建目录层级&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkdir -p&lt;/code&gt; 创建新目录 如果目录已经存在就不再创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG_FILE=/home/user/archive/hourly/Files_To_Backup
BASEDEST=/home/user/archive/hourly

DAY=`date +%d`
MONTH=`date +%m`
TIME=`date +%K%M'

mkdir -p $BASEDEST/$MONTH/$DAY

DESTINATION=$BASEDEST/$MONTH/$DAY/archive$TIME.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5. 运行按小时归档的脚本&lt;/h4&gt;

&lt;h3&gt;26.3 管理用户账户&lt;/h3&gt;

&lt;h3&gt;26.3.1 需要的功能&lt;/h3&gt;

&lt;p&gt;删除用户账户&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取要删除账户的正确账户名&lt;/li&gt;
&lt;li&gt;强制终止正在系统上运行的属于该账户的进程&lt;/li&gt;
&lt;li&gt;确认系统上属于该账户的所有文件&lt;/li&gt;
&lt;li&gt;删除用户账户&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;1. 获取正确用户名&lt;/h4&gt;

&lt;h4&gt;2. 删除属于用户的进程&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ps -u usename&lt;/code&gt; 指定用户的进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cut&lt;/code&gt; 命令提取进程PID&lt;/p&gt;

&lt;h4&gt;3. 查找属于用户账户的文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt; 命令查找文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find / -user username #查找username的文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. 删除账户&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;userdel username&lt;/code&gt; 命令删除账户&lt;/p&gt;

&lt;h3&gt;26.3.2 创建脚本&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;完整的delete__user脚本&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;运行脚本&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/02/05/chapter26-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/02/05/chapter26-lclss</guid>
                <pubDate>2013-02-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用数据库 chapter23 LCLSS</title>
                <description>&lt;h1&gt;第23章 使用数据库&lt;/h1&gt;

&lt;h2&gt;23.1 MySQL数据库&lt;/h2&gt;

&lt;h3&gt;23.1.1 安装MySQL&lt;/h3&gt;

&lt;p&gt;参考第8章&lt;/p&gt;

&lt;h3&gt;23.1.2 MySQL客户端界面&lt;/h3&gt;

&lt;p&gt;mysql命令行界面&lt;/p&gt;

&lt;h4&gt;1. 连接到服务器&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;mysql命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; 指定登陆用户名,无该选项用Linux登陆名进行尝试&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 为用户账户提示输入命令&lt;/p&gt;

&lt;h4&gt;2. mysql命令&lt;/h4&gt;

&lt;p&gt;两类命令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;特殊的mysql命令&lt;/li&gt;
&lt;li&gt;标准SQL语句&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;mysql命令&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;简写命令或完整命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\s #status 服务器状态信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MySQL支持所有标准SQL(Structured Query Language, 结构化查询语言)命令&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SHOW&lt;/code&gt;命令, 提取关于MySQL的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SHOW DATABASES;
#显示数据库
USE mysql;
#连接到单个数据库mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意命令以&lt;code&gt;;&lt;/code&gt;结尾&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SHOW TABLES;
#显示表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql支持大写或者小写指定SQL命令,但是通用方式是大写字母&lt;/p&gt;

&lt;h3&gt;23.1.3 创建MySQL数据库对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;存储应用数据的唯一数据库;&lt;/li&gt;
&lt;li&gt;从脚本中访问数据库的唯一用户账户&lt;/li&gt;
&lt;li&gt;组织数据的一个或多个数据表&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. 创建数据库&lt;/h4&gt;

&lt;p&gt;创建一个新的数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE DATABASE name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必须有创建数据库的权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SHOW DATABASES;
#查看
USE test;
#使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 创建用户账户&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GRANT&lt;/code&gt; SQL语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRANT SELECT,INSERT,DELETE,UPDATE ON test.* TO test IDENTIFIED by 'test'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一部分定义了用户账户对那些数据库有哪些权限(查询(select权限),插入,删除以及更新)&lt;/p&gt;

&lt;p&gt;test.*项定义了权限作用的数据库和表,通过下面格式指定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;database.table
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test.*表示权限在test数据库的所有表上&lt;/p&gt;

&lt;p&gt;最后指定权限作用的用户账户,如果账户不存在,会直接创建账户&lt;/p&gt;

&lt;p&gt;identified by部分为新用户账户设定默认密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql test -u test -p
测试test数据库的test用户
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;23.2 PostgreSQL 数据库&lt;/h2&gt;

&lt;h3&gt;23.2.1 安装PostgreSQl&lt;/h3&gt;

&lt;p&gt;PostgreSQL的系统管理员账户称为postgres,而不是root&lt;/p&gt;

&lt;p&gt;PostgreSQL也支持在内部维护自己的用户数据库,但是大多数都会利用现有的Linux系统用户账户来认证PostgreSQL用户&lt;/p&gt;

&lt;p&gt;系统上必须有一个叫做postgres的用户账户&lt;/p&gt;

&lt;h3&gt;23.2.2 PostgreSQL命令行界面&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;psql&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;1. 连接服务器&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;psql命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;sudo -u postgres psql
#非postgres用户登陆数据库的postgres账户
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. psql命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;标准SQL语句&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PostgreSQL元命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\l   列出所有数据库&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;\c   连接到数据库&lt;/li&gt;
&lt;li&gt;\dt  列出数据库中的表&lt;/li&gt;
&lt;li&gt;\du  列出PostgreSQL用户&lt;/li&gt;
&lt;li&gt;\z   列出表的权限&lt;/li&gt;
&lt;li&gt;\?   列出所有可能的元命令&lt;/li&gt;
&lt;li&gt;\h   列出所有可能的SQL命令&lt;/li&gt;
&lt;li&gt;\q   退出数据库&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;23.2.3 创建PostgreSQL数据库对象&lt;/h3&gt;

&lt;h4&gt;1. 创建数据库对象&lt;/h4&gt;

&lt;p&gt;用postgres用户创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE DATABASE test;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模式(schema),数据库可以有多个模式,每个模式包含多个表,这样允许你根据特定应用或用户将数据库进一步细分&lt;/p&gt;

&lt;p&gt;默认每个数据库都有一个模式,成为public&lt;/p&gt;

&lt;h4&gt;2. 创建用户账户&lt;/h4&gt;

&lt;p&gt;PostgreSQL中的用户账户成为登陆角色(Login Role)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个跟PostpreSQL登陆角色对应的特殊Linux账户来运行所有的shell脚本&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为每个需要运行shell脚本来访问数据库的linux用户账户创建PostgreSQL账户&lt;/p&gt;

&lt;p&gt;  CREATE ROLE rich login;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;组角色(group role)&lt;/p&gt;

&lt;h2&gt;23.3 使用数据库&lt;/h2&gt;

&lt;h3&gt;23.3.1 创建数据表&lt;/h3&gt;

&lt;p&gt;关系数据库(relational database)&lt;/p&gt;

&lt;p&gt;在关系数据库中,数据由&lt;code&gt;数据字段&lt;/code&gt; &lt;code&gt;数据行&lt;/code&gt; &lt;code&gt;表&lt;/code&gt; 组成&lt;/p&gt;

&lt;p&gt;数据字段是单独的一条信息,如员工姓或工资&lt;/p&gt;

&lt;p&gt;数据行是相关数据字段的集合,比如员工ID号,姓,名,地址和工资&lt;/p&gt;

&lt;p&gt;表含有保存相关数据的所有数据行, 比如一个Employees的表来保存每个员工的数据行&lt;/p&gt;

&lt;p&gt;CREATE TABLE; 新建表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE employees (
empid int not null,   #定义非空
lastname varchar(30),
firstname varchar(30),
salary float,
primary key (empid)); #定义唯一性?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建新表前确保你正在正确的数据库中,还要确保你用管理员用户账户&lt;/p&gt;

&lt;p&gt;数据类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;char     定长字符串值&lt;/li&gt;
&lt;li&gt;Varchar  变长字符串值&lt;/li&gt;
&lt;li&gt;int      整数值&lt;/li&gt;
&lt;li&gt;float    浮点值&lt;/li&gt;
&lt;li&gt;Boolean  布尔类型true/false值&lt;/li&gt;
&lt;li&gt;Date     YYYY-MM-DD格式的日期值&lt;/li&gt;
&lt;li&gt;Time     HH:mm:ss格式的时间值&lt;/li&gt;
&lt;li&gt;Timestamp 日期和时间的组合值&lt;/li&gt;
&lt;li&gt;Text     长字符串值&lt;/li&gt;
&lt;li&gt;BLOB     大的二进制值,比如图片或视频剪辑&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;empid还指定了一个&lt;strong&gt;数据约束(data constraint)&lt;/strong&gt;, 数据约束限制输入的什么类型数据可以创建一个有效的数据行, not null 指明每个数据行都必须有一个唯一的empid值&lt;/p&gt;

&lt;p&gt;在PostgreSQL为表一级分配权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRANT SELECT,INSERT,DELETE,UPDATE ON public public.employees TO rich;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;23.3.2 插入和删除数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO table VALUES (…)

INSERT INTO employees VALUES (1, ' Blum' , ' Rich', 25000.00)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果插入两条empid相同的数据会报错&lt;/p&gt;

&lt;p&gt;删除数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DELETE FROM table;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小心,这个命令删除表中所有数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DELETE FROM employees WHERE empid = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;23.3.3 查询数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;SELECT datafields FROM table
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;datefields参数使用逗号分开的你希望查询的数据字段名称, 如果要提取所有字段,就用星号通配符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM employees
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以加修饰符来定义数据库服务器如何返回查询要找的数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WHERE    显示符合特定条件的数据子集&lt;/li&gt;
&lt;li&gt;ORDER BY 以指定顺序显示数据行&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LIMIT    只显示数据行的一个子集&lt;/p&gt;

&lt;p&gt;  SELECT * FROM employees WHERE salary &gt; 40000&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;23.4 在脚本中使用数据库&lt;/h2&gt;

&lt;h3&gt;23.4.1 连接到数据库&lt;/h3&gt;

&lt;h4&gt;1. 查找客户端程序&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;which mysql&lt;/code&gt; 查找mysql安装的位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYSQL=`which mysql`
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 登录到服务器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;MYSQL test -u test -ptest
#直接输入密码,登陆
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样任何能够访问脚本的人都能看到数据库的账号和密码&lt;/p&gt;

&lt;p&gt;使用`$HOME/.my.cnf文件来读取特殊的启动命令和设置&lt;/p&gt;

&lt;p&gt;在这个文件里面设置默认密码,加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[client]
password = test
#将文件权限换成400
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;23.4.2 向服务器发送命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;发送单个命令并退出&lt;/li&gt;
&lt;li&gt;发送多个命令&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;mysql 的 &lt;code&gt;-e&lt;/code&gt;参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYSQL=`which mysql`
$MYSQL test -u test -e 'select * from employees'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;psql使用-C参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PSQL=`which psql`
$PSQL test -c 'select * from employees&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要发送多条SQL命令使用文件重定向(第14章),在shell脚本中重定向行,必须定义一个结束字符串(end of file string),结束字符串指定了重定向数据的开始和结尾&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYSQL = `which mysql`
$MYSQL test -u test &amp;lt;&amp;lt; EOF
show tables;
select * from employees where salary &amp;gt; 40000;
EOF

PSQL=`which psql`
$PSQL test &amp;lt;&amp;lt; EOF
\dt;
select * from employees where salary &amp;gt; 40000;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;23.4.3 格式化数据&lt;/h3&gt;

&lt;h4&gt;1. 将输出赋给变量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dbs=`$MYSQL test -u test -Bse 'show databases'`
for db in $dbs
do
  echo $db
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 使用格式化标签&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;-H&lt;/code&gt;选项以HTML格式显示结果选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;psql test -H -C 'select * from  employees where empid = 1'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql还支持扩展标记语言(XML), 使用&lt;code&gt;-X&lt;/code&gt;选项&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/02/04/chapter23-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/02/04/chapter23-lclss</guid>
                <pubDate>2013-02-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用其他shell chapter22 LCLSS</title>
                <description>&lt;h1&gt;第22章 使用其他shell&lt;/h1&gt;

&lt;h2&gt;22.1 什么是dash shell&lt;/h2&gt;

&lt;p&gt;大多是发行版将/bin/sh链接到/bin/bash&lt;/p&gt;

&lt;p&gt;但是Ubuntu将/bin/sh链接到/bin/dash&lt;/p&gt;

&lt;h2&gt;22.2 dash shell 的特性&lt;/h2&gt;

&lt;h3&gt;22.2.1 dash命令行参数&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;dash命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;22.2.2 dash环境变量&lt;/h3&gt;

&lt;h4&gt;1. 默认环境变量&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;dash shell环境变量&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;OLDPWD 上一个工作目录&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;dash 也用&lt;code&gt;set&lt;/code&gt;命令来显示环境变量&lt;/p&gt;

&lt;h4&gt;2. 位置参数&lt;/h4&gt;

&lt;p&gt;和bash类似&lt;/p&gt;

&lt;h4&gt;3. 用户自定义的环境变量&lt;/h4&gt;

&lt;p&gt;和bash类似&lt;/p&gt;

&lt;p&gt;不支持可变数组&lt;/p&gt;

&lt;h3&gt;22.2.3 dash内建命令&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;dash内建命令&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;22.3 dash脚本编程&lt;/h2&gt;

&lt;p&gt;bash脚本通常不能在dash中运行&lt;/p&gt;

&lt;h3&gt;22.3.1 创建dash脚本&lt;/h3&gt;

&lt;p&gt; 第一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!/bin/dash
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;22.3.2 不能使用的功能&lt;/h3&gt;

&lt;p&gt;bash主义(bashism)&lt;/p&gt;

&lt;h4&gt;1. 使用算术运算&lt;/h4&gt;

&lt;p&gt;bash中,算术运算&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expr&lt;/li&gt;
&lt;li&gt;方括号&lt;/li&gt;
&lt;li&gt;双圆括号&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;dash支持expr和双圆括号,&lt;strong&gt;不支持方括号&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;2. test命令&lt;/h4&gt;

&lt;p&gt;bash的test支持&lt;code&gt;==&lt;/code&gt;,而dash不支持&lt;code&gt;==&lt;/code&gt;只支持&lt;code&gt;=&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;3. echo语句选项&lt;/h4&gt;

&lt;p&gt;bash中echo通过&lt;code&gt;-e&lt;/code&gt;选项来输出转义符号, 而dash中直接就能输出转义字符,因此没有&lt;code&gt;-e&lt;/code&gt;选项&lt;/p&gt;

&lt;h4&gt;4. function命令&lt;/h4&gt;

&lt;p&gt;bash支持两种方式定义函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function name{
    statements
}

name() {
    statementes
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dash只支持第二种方式定义函数&lt;/p&gt;

&lt;h2&gt;22.4 zsh shell&lt;/h2&gt;

&lt;p&gt;zsh的独特的功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;改进shell选项处理&lt;/li&gt;
&lt;li&gt;shell兼容性模式&lt;/li&gt;
&lt;li&gt;可加载模块  命令模块(command module)&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;22.5 zsh shell的组成&lt;/h2&gt;

&lt;h3&gt;22.5.1 shell选项&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;zsh shell命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;-o&lt;/code&gt; 选项允许设置shell选项来定义shell的功能&lt;/p&gt;

&lt;p&gt;选项类别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更改目录&lt;/li&gt;
&lt;li&gt;补全&lt;/li&gt;
&lt;li&gt;扩展和扩展匹配&lt;/li&gt;
&lt;li&gt;历史记录&lt;/li&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;输入输出&lt;/li&gt;
&lt;li&gt;作业控制&lt;/li&gt;
&lt;li&gt;提示&lt;/li&gt;
&lt;li&gt;脚本和函数&lt;/li&gt;
&lt;li&gt;shell模拟&lt;/li&gt;
&lt;li&gt;shell状态&lt;/li&gt;
&lt;li&gt;zle&lt;/li&gt;
&lt;li&gt;选项别名&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. shell状态选项&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;交互模式(-i , interactive)&lt;/li&gt;
&lt;li&gt;登陆模式(-l, login)&lt;/li&gt;
&lt;li&gt;特权模式(-p, privileged)&lt;/li&gt;
&lt;li&gt;限制模式(-r, restricted)&lt;/li&gt;
&lt;li&gt;shin_stdin模式(-s)&lt;/li&gt;
&lt;li&gt;single_command模式(-t)&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;2. shell模拟选项&lt;/h4&gt;

&lt;p&gt;提供类似于C shell或Korn shell的运行&lt;/p&gt;

&lt;h4&gt;3. 初始化选项&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;all_export&lt;/li&gt;
&lt;li&gt;global_export&lt;/li&gt;
&lt;li&gt;global_rcs&lt;/li&gt;
&lt;li&gt;rcs&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;4. 脚本和函数选项&lt;/h4&gt;

&lt;p&gt;定制shell脚本环境&lt;/p&gt;

&lt;h3&gt;22.5.2 内建命令&lt;/h3&gt;

&lt;h4&gt;1. 核心内建命令&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;zsh核心命令&lt;/p&gt;

&lt;hr /&gt;

&lt;h4&gt;2. 附加模块&lt;/h4&gt;

&lt;h4&gt;3. 查看,添加和删除模块&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;zmodload&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;默认显示当前加载模块&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zmodload 模块名&lt;/code&gt; 加载新模块&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zmodload -u 模块名&lt;/code&gt; 删除模块&lt;/p&gt;

&lt;h2&gt;22.6 zsh脚本编程&lt;/h2&gt;

&lt;h3&gt;22.6.1 数学运算&lt;/h3&gt;

&lt;h4&gt;1. 进行计算&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;let命令&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双圆括号命令&lt;/p&gt;

&lt;p&gt;  let value=&quot; 4 * 5.1 / 3.2 &quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;支持格式化输出printf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf &quot;%6.3f\n&quot; $value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双圆括号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value=$(( 4 * 5.1 ))
((value = 4 * 5.1 ))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 数学函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;zsh/mathfunc模块
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;22.6.2 结构化命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;if-then-else&lt;/li&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt;until&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;li&gt;case&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;此外还有`repeat命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repeat param
do
    commands
done
#param是一个数或一个值为数的表达式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;22.6.3 函数&lt;/h3&gt;

&lt;p&gt;支持function命令或圆括号定义函数名来创建自定义函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fpath&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;autoload&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zcompile&lt;/code&gt;命令&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/02/03/chapter22-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/02/03/chapter22-lclss</guid>
                <pubDate>2013-02-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>gawk进阶 chapter21 LCLSS</title>
                <description>&lt;h1&gt;第21章 gawk进阶&lt;/h1&gt;

&lt;h2&gt;21.1 使用变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;内建变量&lt;/li&gt;
&lt;li&gt;自定义变量&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;21.1.1 内建变量&lt;/h3&gt;

&lt;h4&gt;1. 字段和数据行分隔符变量&lt;/h4&gt;

&lt;p&gt;数据字段变量, $1代表第一个,$2代表第二个…, $0代表整行&lt;/p&gt;

&lt;p&gt;字段由字段分隔符划定,默认是空白字符,通过-F选项或者FS变量来更改&lt;/p&gt;

&lt;p&gt;gawk数据字段和数据行变量&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;变量     &lt;/th&gt;
&lt;th&gt;描述    &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FIELDIDTHS&lt;/td&gt;
&lt;td&gt;由空格分隔开的定义了灭个数据字段确切宽度的一列数字|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FS      &lt;/td&gt;
&lt;td&gt;输入字段分隔符|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;RS      &lt;/td&gt;
&lt;td&gt;输入数据行分隔符|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;OFS     &lt;/td&gt;
&lt;td&gt;输出字段分隔符  |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ORS     &lt;/td&gt;
&lt;td&gt;输出数据行分隔符|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;OFS默认是一个空格&lt;/p&gt;

&lt;p&gt;print命令会自动将OFS变量的值放置在输出的每个字段间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk 'BEGIN{FS=&quot;,&quot;; OFS=&quot;-&quot;} {print $1,$2,$3}' data1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FIELDWIDTHS变量,不用字段分隔符来划分字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#data1b
1005.3247596.37
115-2.349194.00
05810.1298100.1

gawk 'BEGIN{FIELDWIDTHS=&quot;3 5 2 5&quot;} {print $1,$2,$3,$4}' data1b

FIELDWIDTHS一旦设定,就不能改变,这种方法不适合边长字段
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RS和ORS定了如何处理数据流中的数据行,默认情况下,RS和ORS设为换行符&lt;/p&gt;

&lt;p&gt;有时数据项按行分隔, 而数据组之间有空行分隔,这时把FS设为换行符,RS设为空字符串&lt;/p&gt;

&lt;h4&gt;2. 数据变量&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;更多gawk内建变量&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;gawk 'BEGIN{print ARGC.ARBV[1]}' data1
&amp;gt;data1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ARGC变量表明命令行上有两个参数,gawk和data1参数,程序脚本并不算参数,ARGV数组从代表该命令的索引0开始&lt;/p&gt;

&lt;p&gt;gawk变量中,变量名前不加美元符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk '
BEGIN{
print ENVIRON[&quot;HOME&quot;]
print ENVIRON[&quot;PATH&quot;]
}'

gawk 'BEGIN{
FS=&quot;:&quot;
OFS=&quot;:&quot;}
{ print $1,$NF}' /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NF&lt;/code&gt;是最后一个数据字段的数字值,通过&lt;code&gt;$NF&lt;/code&gt;来引用最后一个字段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NR&lt;/code&gt;是处理过的所有数据行总数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FNR&lt;/code&gt;是当前数据文件处理过的总的数据行总数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#在同时处理多个文件的时候会有差别
gawk 'BEGIN{FS=&quot;,&quot;}{print $1, &quot;FNR&quot;=FNR, &quot;NR&quot;=NR}' data1 data1

data11 FNR=1 NR=1
data21 FNR=2 NR=2
data31 FNR=3 NR=3
data11 FNR=1 NR=4
data21 FNR=2 NR=5
data31 FNR=3 NR=6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;21.1.2 自定义变量&lt;/h3&gt;

&lt;h4&gt;1. 在脚本中给变量赋值&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;gawk 'BEGIN{x=4; x=x * 2 + 3; print x}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 在命令行上给变量赋值&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#script1
BEGIN{FS=&quot;,&quot;}
{print $n}

gawk -f script1 n=2 data1

gawk -f script2 n=3 data1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个值在BEGIN部分不可用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#script2
BEGIN{print &quot;The starting value is&quot;,n; FS=&quot;,&quot;}
{print $n}

gawk -f script2 n=3 data1
#第一行The starting value is#没有输出n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;-v&lt;/code&gt;选项来解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk -v n=3 -f script2 data1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;21.2 处理数组&lt;/h2&gt;

&lt;p&gt;关联数组&lt;/p&gt;

&lt;h3&gt;21.2.1 定义数组变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var[index]=element

gawk 'BEGIN{
capital[&quot;Illinois&quot;] = &quot;Springfield&quot;
print capital[&quot;Illinois&quot;]
}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;21.2.2 遍历数组变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;for (var in array)
{
  statements
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;var是遍历索引而不是值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk 'BEGIN{
var[&quot;a&quot;]=1
var[&quot;g&quot;]=2
var[&quot;m&quot;]=3
var[&quot;u&quot;]=4
for(test in var)
{
  print &quot;Index:&quot;,test,&quot; - Value:&quot;, var[test]
}
}'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的索引值不是按顺序的&lt;/p&gt;

&lt;h3&gt;21.2.2 删除数组变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;delete array[index]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;21.3 使用模式&lt;/h2&gt;

&lt;h3&gt;21.3.1 正则表达式&lt;/h3&gt;

&lt;p&gt;基本正则表达式(BRE) 扩展正则表达式(ERE)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk 'BEGIN{FS=&quot;,&quot;} /11/{print $1}' data1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则表达式会对数据中的所有数据字段进行匹配,包括分隔符&lt;/p&gt;

&lt;h3&gt;21.3.2 匹配操作符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;~&lt;/code&gt;匹配操作符(matching operator)允许将正则表达式限定在数据行中的特性数据字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$1 ~ /^data/

gawk 'BEGIN{FS=&quot;,&quot;} $2 ~ /^data2/{print $0}' data1

gawk -F: '$1 ~ /rich/{print $1,$NF}' /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用排除&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk -F: '$! !~ /rich/{print $1,$NF}' /etc/passwd

#输出不匹配的行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;21.3.3 数学表达式&lt;/h3&gt;

&lt;p&gt;可以在匹配模式中使用数学表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk -F: '$4 == 0{print $1}' /etc/passwd
#PID==0的行
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;x == y&lt;/li&gt;
&lt;li&gt;x &amp;lt;= y&lt;/li&gt;
&lt;li&gt;x &gt;= y&lt;/li&gt;
&lt;li&gt;x &amp;lt; y&lt;/li&gt;
&lt;li&gt;x &gt; y&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;也可对文本数据使用表达式,但是要完全相同才算匹配&lt;/p&gt;

&lt;h2&gt;21.4 结构化命令&lt;/h2&gt;

&lt;h3&gt;21.4.1 if语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if(condition)
    statement1

if(condition) statement1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#data4
10
5
13
50
34
gawk '{if ($1 &amp;gt; 20) print $1}' data4
50
34

gawk '{
if($1 &amp;gt;  20)
{
  x = $1 * 2;
  print x
} #多条语句用{}
}' data4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以加else语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk '{
if($1 &amp;gt; 20)
{
  x = $1 * 2
  print x
}else
{
  x = $1 / 2
  print x
}}' data4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(condition) statement1; else statement2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;21.4.2 while语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;while (condition)
{
  statement
}

#data5
130 120 135
160 113 140
145 170 215

gawk '{
total=0
i=1
while (i &amp;lt; 4)
{
  total+= $i
  i++
}
avg = total / 3
print &quot;Average: &quot;,avg
}' data5
#求每行平均
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;支持在while中使用continue和break&lt;/p&gt;

&lt;h3&gt;21.4.3 do-while 语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;do
{
    statements
}while(condition)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;21.4.4 for语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;for(variable assignment; condition; iteration process)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;21.5 格式化打印&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;printf&lt;/code&gt; 命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; printf &quot;fomat string&quot;, var1, var2, …
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式化指定符采用如下格式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%[modifier]control-letter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;control-letter(控制字符),和c中的printf相似&lt;/p&gt;

&lt;p&gt;modifier(修饰符),和c中也类似&lt;/p&gt;

&lt;h2&gt;21.6 内建函数&lt;/h2&gt;

&lt;h3&gt;21.6.1 数学函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;atan2(x,y)&lt;/li&gt;
&lt;li&gt;cos(x)&lt;/li&gt;
&lt;li&gt;exp(x)&lt;/li&gt;
&lt;li&gt;int(x)&lt;/li&gt;
&lt;li&gt;log(x)&lt;/li&gt;
&lt;li&gt;rand()&lt;/li&gt;
&lt;li&gt;sin(x)&lt;/li&gt;
&lt;li&gt;sqrt(x)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;srand(x)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;and(v1, v2) 按位与&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;compl(val)  补运算&lt;/li&gt;
&lt;li&gt;lshift(val, count) 左移&lt;/li&gt;
&lt;li&gt;rshift(val, count) 右移&lt;/li&gt;
&lt;li&gt;or(v1, v2)  按位或&lt;/li&gt;
&lt;li&gt;xor(v1, v2) 按位抑或&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;21.6.2 字符串函数&lt;/h3&gt;

&lt;p&gt;gawk字符串函数&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;函数      &lt;/th&gt;
&lt;th&gt;描述              &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;asort(s [, d])&lt;/td&gt;
&lt;td&gt;将数组s按数据元素排序,索引值会被替换成表示新的排序顺序的连续数字,另外,如果指定了d,则排序后的数组会存储在数组d中|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;asorti(s [, d])&lt;/td&gt;
&lt;td&gt;将数组s按索引值排序,生成的数组会将索引值作为数据元素值,用连续数字索引来表名排序顺序,另外如果指定了d,排序后的数组会存储在数组d中|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;gensub(r, s, h [, t])&lt;/td&gt;
&lt;td&gt;查找变量$0或目标字符串t(如果提供了的话)来匹配正则表达式r,如果h是以一个g或G开头的字符串,就用s替换掉匹配的文本,如果h是一个数字,它表示要替换掉第几处r匹配的地方|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;gsub(r, s [, t])&lt;/td&gt;
&lt;td&gt; 查找变量$0或目标字符串t(如果提供了的话)来匹配正则表达式r,如果找到了就全部替换成s|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;index(s, t)&lt;/td&gt;
&lt;td&gt; 返回t在s中的索引,如果没有找到就返回0|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;length([s])&lt;/td&gt;
&lt;td&gt; 返回s的长度,如果没有指定就放回$0的字符串|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;match(s, r [, a])&lt;/td&gt;
&lt;td&gt;返回字符串s中正则表达式r出现位置的索引,如果指定了数组a,它会存储s中匹配正则表达式的那部分|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;split(s, a[ ,r])&lt;/td&gt;
&lt;td&gt;将s用FS字符或正则表达式r(如果指定了的话)分开放到数组a中,返回字段的总数|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;sprintf(format, variable)&lt;/td&gt;
&lt;td&gt;用format和variables返回一个类似于printf输出的字符串|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;sub(r, s [, t])&lt;/td&gt;
&lt;td&gt;在变量$0或目标字符串t中查找正则表达式r和匹配,如果找到了,就用字符串s替换掉第一处匹配|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;substr(s, i [, n])&lt;/td&gt;
&lt;td&gt;返回s中从索引值i开始的n个字符串, 如果未提供n,则返回s的剩余部分|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;tolower(s)&lt;/td&gt;
&lt;td&gt;将s中的所有字符换成小写|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;toupper(s)&lt;/td&gt;
&lt;td&gt;将s中的所有字符换成大写|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;21.6.3 时间函数&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;mktime(datespec)&lt;/td&gt;
&lt;td&gt;将一个按YYYY MM DD HH MM SS[DST]格式指定的日期转换为时间戳值|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;strftime(format [, timestamp])&lt;/td&gt;
&lt;td&gt;将当前时间的时间戳或timestamp(如果提供了的话)转化成shell函数格式date()的格式化日期|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;systime()&lt;/td&gt;
&lt;td&gt;返回当前时间的时间戳|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h2&gt;21.7 自定义函数&lt;/h2&gt;

&lt;h3&gt;21.7.1 定义函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function name([variable])
{
    statements
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在函数中使用外部变量,如$1,$2等字段值&lt;/p&gt;

&lt;h3&gt;21.7.2 使用自定义函数&lt;/h3&gt;

&lt;p&gt;定义函数必须出现在所有代码块之前(包括BEGIN代码块)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk '
function myprint()
{
    printf &quot;%-16s - %s\n&quot;, $1, $4
}
BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;}
{
    myprint()
}' data2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;21.7.3 创建函数库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#funclib
gawk '
function myprint()
{
    printf &quot;%-16s - %s\n&quot;, $1, $4
} 
function myrand(limit)
{
    return int(limit * rand())
}
function printthird()
{
    print $3
}

gawk -f funclib -f script4 data2
#多个-f选项指定多个文件
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/02/02/chapter21-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/02/02/chapter21-lclss</guid>
                <pubDate>2013-02-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sed进阶 chapter20 LCLSS</title>
                <description>&lt;h1&gt;第20章 sed进阶&lt;/h1&gt;

&lt;h2&gt;20.1 多行命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;N: 将数据流中的下一行加进来创建一个多行组来处理&lt;/li&gt;
&lt;li&gt;D: 删除多行组中的一行&lt;/li&gt;
&lt;li&gt;P: 打印多行组中的一行&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;20.1.1 next命令&lt;/h3&gt;

&lt;h4&gt;1. 单行的next命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#data1
This is the header line.

This is a data line.

This is the last line.
#要删除第一个空行而保留第二个空行

sed '/^$/d' data1 #会删除两个空行

sed '/head/{n; d}' data1
#head搜索到第一行,n跳到下一行,d删除这一行,接着命令行又从第一行开始,但是接下来没有带head的行
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 合并文本行&lt;/h4&gt;

&lt;p&gt;单行next命令会将数据流的下一文本行移动到sed编辑器的工作空间(模式空间). 多行版本的next命令(用大写N)会将下一文本行加到已经在模式空间中的文本上,我这样两个文本合并到一个模式空间,文本行仍然用换行符分隔,但是sed现在会将两行文本当成一行来处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#data2
This is the header line.
This is the first data line.
This is the second data line.
This is the last line.

sed '/first/{N ; s/\n/ /}' data2

#data3
All System
Administrators should attend this meeting.

#跨行搜索
sed '
s/System Administrators/Desktop User/  #在一行中的情况
N
s/System\nAdministrators/Desktop\nUser/ #在两行的情况
' data3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.1.2 多行删除命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;d&lt;/code&gt;是单行删除命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;D&lt;/code&gt; 是多行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 'N ; /System\nAdministrator/d' data4
#有可能把模式空间中的两行都删除

#data5

This is the header line.
This is a data line.

This is the last line.

sed '/^$/{ N; /header/D}' data5 #删除第一行空行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.1.3 多行打印命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;P&lt;/code&gt; 打印模式空间中多行的第一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n 'N; /System\nAdministrator/P' data3
#只输出含有System的那一行
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20.2 保持空间&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;模式空间(pattern space)&lt;/strong&gt;是一块活动缓冲区,在sed编辑器zhi'i执行命令时保存sed编辑器要检验的文本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;保持空间(hold space)&lt;/strong&gt;, 另一块活动缓冲区,可以在处理模式空间中其他行时用保持空间来临时保存一些行&lt;/p&gt;

&lt;p&gt;sed保持空间的命令&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;命令    &lt;/th&gt;
&lt;th&gt;描述                     &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;h      &lt;/td&gt;
&lt;td&gt;将模式空间复制到保存空间     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;H      &lt;/td&gt;
&lt;td&gt;将模式空间附加到保持空间     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;g      &lt;/td&gt;
&lt;td&gt;将保持空间复制到模式空间     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;G      &lt;/td&gt;
&lt;td&gt;将保持空间附加到模式空间     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x      &lt;/td&gt;
&lt;td&gt;交换保持空间和模式空间的内容  |&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;pre&gt;&lt;code&gt;#data2
This is the header line.
This is the first line.
This is the second line.
This is the last line.

sed -n '/first/{
h   #复制到保持空间
p   #打印模式空间
n   #模式空间提取文本下一行
p   #打印模式空间
g   #保持空间复制到模式空间
p   #打印模式空间
}' data2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20.3 排除命令&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;!&lt;/code&gt; 感叹号命令排除(negate)命令,让原本会起作用的命令不起作用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/header/!p' data2
#含header行不打印

sed 'N: s/System.Administrator/Desktop User/' data4
The first meeting of the Linux Desktop User' group will  be held on Tuesday #这行的System Administrator改变了
All System Administrators should attend this meeting. #这行没改,因为N命令失败,命令结束

sed '$!N /System.Administrator/Desktop User/' data4
The first meeting of the Linux Desktop User' group will  be held on Tuesday #这行的System Administrator改变了
All Desktop Users should attend this meeting. #这行改了,因为$!N,表示最后一行不实行N命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将文本按行反向&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '1!G; h; $p' data3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tac&lt;/code&gt; 命令也按行反向文本&lt;/p&gt;

&lt;h2&gt;20.4 改变流&lt;/h2&gt;

&lt;p&gt;sed编辑器会从脚本顶部开始执行命令并一直处理到脚本的结尾(D命令是一个例外,会强制sed编辑器返回到脚本的顶部,而不读取新的行)&lt;/p&gt;

&lt;p&gt;sed提供了一个方法来改变命令脚本的流,实现类似结构化编程环境的结果&lt;/p&gt;

&lt;h3&gt;20.4.1 跳转&lt;/h3&gt;

&lt;p&gt;跳转(branch)命令&lt;code&gt;b&lt;/code&gt;的格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[address]b [label]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;address决定哪行或哪些行的数据会触发跳转,label定义了要跳转的位置,如果没有加label就跳转到脚本末尾&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '{2,3b ; s/This is/Is this/;s/line./test?/}' data2
#在2,3两行命令脚本直接跳到了最后
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签以冒号开始,最多7个字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:label2

sed '{/first/b jump1; s/This is the/No jump on/
:jump1
s/This is the/Jump here on/}' data2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以往前跳转:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;This, is, a, test, to, remove, commas. &quot; | sed -n'{
:start
s/.//1p
b start
}'   #无限循环了

echo &quot;This, is, a, test, to, remove, commas. &quot; | sed -n'{
:start
s/.//1p
/,/b start   #只有在匹配,时才跳转
}'   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.4.2 测试&lt;/h3&gt;

&lt;p&gt;测试(test)命令&lt;code&gt;t&lt;/code&gt;也可以改变sed脚本的流,测试命令会基于替换命令的输出跳转到一个标签,而不是基于地址跳转到一个标签&lt;/p&gt;

&lt;p&gt;如果替换命令成功匹配并替换了一个模式,测试命令就会跳转到指定的标签,如果为匹配成功就不会跳转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[address]t [label]
#没有指定label,匹配成功会跳转到最后

sed '{
s/first/matched/
t
s/This is the/No match on/
}' data2

echo &quot;This, is, a, test, to, remove, commas&quot;
| sed '{
:start
s/,//1p
t start
}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20.5 模式替换&lt;/h2&gt;

&lt;h3&gt;20.5.1 and符号&lt;/h3&gt;

&lt;p&gt;and符号&lt;code&gt;&amp;amp;&lt;/code&gt;来代表替换命令中的匹配模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;The cat sleeps in his hat&quot; | sed 's/.at/&quot;&amp;amp;&quot;/g'
The &quot;cat&quot; sleeps in his &quot;hat&quot;
#&amp;amp;代表匹配的模式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.5.2 替换单独的单词&lt;/h3&gt;

&lt;p&gt;用圆括号来定义替换模式的子字符串,要转义圆括号来将他们识别为聚合字符而不是普通的圆括号,这跟转义特殊字符正好相反&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;The System Administrator manual&quot; | sed '
s/\(System\) Administrator/\1 User/'
The System User manual
#\1来引用\(System\)匹配的部分

echo &quot;That furry cat is pretty&quot; | sed 's/furry \(.at\)/\1/'  
#即使用通配符又使用子串

echo &quot;1234567&quot; | sed '{
start
s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
t start
}'

#{}操作也要转义
#\1代表第一部分,\2代表第二部分
#但感觉这个有问题啊,在有多个匹配的情况下是最长匹配的?
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20.6 在脚本中使用sed&lt;/h2&gt;

&lt;h3&gt;20.6.1 使用包装脚本&lt;/h3&gt;

&lt;p&gt;可以将sed编辑器命令放到shell包装脚本(wrapper)中&lt;/p&gt;

&lt;p&gt;在包装脚本总可以将普通的shell变量及参数和sed编辑器脚本一起使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#reverse
sed -n '{
1!G
h
$p
}' $1

./reverse data2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.6.2 重定向sed的输出&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#fact

factorial=1
counter=1
number=$1

while[ $counter -le $number ]
do
  factorial=$[ $factorial * $counter ]
  counter=$[ $counter + 1 ]
done

result=`echo $factorial | sed '{
:start
s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
t start
}'`

echo &quot;The result is $result&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20.7 创建sed实用工具&lt;/h2&gt;

&lt;h3&gt;20.7.1 加倍行间距&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sed '$!G' data2
#出了最后一行后面不加空行,其他行后面都加空行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.7.2 对可能含有空白行的文件加倍行间距&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sed '{/^$/d; $!G}' data6
#先删除空白行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.7.3 给文件中的行编号&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sed '=' data2 #在每行之前显示行号

sed '=' data2 | sed 'N; s/\n/ /'
#将行号和数据显示在同一行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.7.4 打印末尾行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sed -n '$p' data2  #打印末尾一行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印末尾若干行,创建滚动窗口(rolling window)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '{
:start
$q
N
11,$D
b start
}' data2 #打印末尾的10行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.7.5 删除行&lt;/h3&gt;

&lt;h4&gt;1. 删除连续的空白行&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed '/./,/^$/!d' data6
#删除多余的空行,只有一个空行的不会被删除
#这里有多行匹配时是用最短匹配的?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 删除开头的空白行&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed '/./,$!d' data6
#删除开头的空白行
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 删除结尾的空白行&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed '{
:start
/^\n*$/{$d; N; b start }
}' data6
#删除结尾的行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;20.7.6 删除HTML标签&lt;/h3&gt;

&lt;p&gt;不能直接用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;,因为是使用最长匹配,一行中如果有两个标签就不对了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 's/&amp;lt;[^&amp;gt;]*&amp;gt;//g' data9
#在标签里面的符号排除&amp;gt;号
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/31/chapter20-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/31/chapter20-lclss</guid>
                <pubDate>2013-01-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>正则表达式 chapte19 LCLSS</title>
                <description>&lt;h1&gt;第19章 正则表达式&lt;/h1&gt;

&lt;h2&gt;19.1 什么是正则表达式&lt;/h2&gt;

&lt;h3&gt;19.1.1 定义&lt;/h3&gt;

&lt;p&gt;过滤文本的模式模版&lt;/p&gt;

&lt;h3&gt;19.1.2 正则表达式的类型&lt;/h3&gt;

&lt;p&gt;难点在于不止一种类型的正则表达式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正则表达式引擎(regular expression engine)&lt;/strong&gt;,是解释正则表达式模式并使用这些模式进行文本匹配的底层软件&lt;/p&gt;

&lt;p&gt;Linux中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;POSIX基本正则表达式(BRE)引擎&lt;/li&gt;
&lt;li&gt;POSIX扩展正则表达式(ERE)引擎&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;19.2 定义BRE模式&lt;/h2&gt;

&lt;h3&gt;19.2.1 纯文本&lt;/h3&gt;

&lt;p&gt;直接用纯文本匹配,区分大小写,空格也可以匹配&lt;/p&gt;

&lt;h3&gt;19.2.2 特殊字符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.*[]^${}\+?|()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是特殊字符,不能在文本模式中单独使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;转义&lt;/p&gt;

&lt;p&gt;尽管&lt;code&gt;/&lt;/code&gt;不是特殊字符,但是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;3 / 2&quot; | sed -n '///p'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是错误的,&lt;code&gt;/&lt;/code&gt;在此处也要转义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;3 / 2&quot; | sed -n '/\//p'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.2.3 锚字符&lt;/h3&gt;

&lt;h4&gt;1. 锁定在行首&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;^&lt;/code&gt;脱字符(caret character),定义行首开始模式&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;^&lt;/code&gt;不在模式的第一位,那么会被当做普通字符(如果只用了脱字符,不需要转义;如果模式首位有脱字符,那么需要转义)&lt;/p&gt;

&lt;h4&gt;2. 锁定在行尾&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$&lt;/code&gt;美元符定义了行尾锚定点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; echo &quot;This is a good book&quot; | sed -n '\book$\p'
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 组合锚点&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/^this is a test$/p' data4

sed '\^$\d' data5  #删除空行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.2.4 点字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;匹配任何单字符除了换行符,点字符必须匹配一个字符&lt;/p&gt;

&lt;h3&gt;19.2.5 字符组&lt;/h3&gt;

&lt;p&gt;字符组(character class), 使用&lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/[ch]at/p' data6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.2.6 排除字符组&lt;/h3&gt;

&lt;p&gt;在字符组开头加&lt;strong&gt;脱字符&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/[^ch]at/p' data6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.2.7 使用区间&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/^[0-9][0-9][0-9][0-9][0-9]&amp;amp;/p' data5

sed -n '/[a-ch-m]at/p' data6 #多区间
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.2.8 特殊字符组&lt;/h3&gt;

&lt;p&gt;特殊字符组&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;组             &lt;/th&gt;
&lt;th&gt;描述                          &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:alpha:]]   &lt;/td&gt;
&lt;td&gt; 匹配任意字母字符,不管是大写还是小写|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:alnum:]]   &lt;/td&gt;
&lt;td&gt; 匹配任意字母字符和数值           |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:blank:]]   &lt;/td&gt;
&lt;td&gt; 匹配空格或制表符                |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:digit:]]   &lt;/td&gt;
&lt;td&gt; 匹配数字                       |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:lower:]]   &lt;/td&gt;
&lt;td&gt; 匹配小写字母                   |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:upper:]]   &lt;/td&gt;
&lt;td&gt; 匹配大写字母                   |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:print:]]   &lt;/td&gt;
&lt;td&gt; 匹配可打印字符                 |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:punct:]]   &lt;/td&gt;
&lt;td&gt; 匹配标点符号                   |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[[:space:]]   &lt;/td&gt;
&lt;td&gt; 匹配任意空白字符:空格,制表符,NL,FF,VT和CR|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;19.2.9 星号&lt;/h3&gt;

&lt;p&gt;放置在字符后面说明该字符会在匹配模式的文本中出现0次或多次&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo 'ik' | sed -n '/ie*k/p'

echo &quot;this is a regular pattern expression&quot; | sed -n '
/regular.*expression/p'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.*&lt;/code&gt; 结合表示任意多个任意字符&lt;/p&gt;

&lt;h2&gt;19.3 扩展正则表达式&lt;/h2&gt;

&lt;p&gt;POSIX ERE模式包括一些Linux应用和工具使用的若干额外符号,gawk能够识别ERE,但是sed不能&lt;/p&gt;

&lt;h3&gt;19.3.1 问号&lt;/h3&gt;

&lt;p&gt;问号表明前面的字符可以出现0次或1次&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;bt&quot; | gawk '/be?t/{print $0}'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问号可以和字符组一起使用&lt;/p&gt;

&lt;h3&gt;19.3.2 加号&lt;/h3&gt;

&lt;p&gt;加号表明前面的字符可以出现1次或多次,至少出现一次&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;bet&quot; | gawk '/be+t/{print $0}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.3.3 使用花括号&lt;/h3&gt;

&lt;p&gt;为可重复的正则表达式指定一个上限, 通常成为&lt;strong&gt;区间(interval)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;m-----正则表达式准确出现m次&lt;/li&gt;
&lt;li&gt;m, n -正则表达式至少出现m次,最多出现n次&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;默认情况下.gawk不会识别正则表达式区间,必须为gawk程序指定--re-interval命令行选项来识别正则表达式区间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;bt&quot; | gawk --re-interval '/be{1}t/{print $0}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.3.4 管道符号&lt;/h3&gt;

&lt;p&gt;逻辑OR&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expr1|expr2|…

echo &quot;The cat is asleep&quot; | gawk '/cat|dog/{print $0}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.3.5 聚合表达式&lt;/h3&gt;

&lt;p&gt;用圆括号聚合起来,该组会被当成一个特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;Sat&quot; | gawk '/Sat(urday)?/{print $0}'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;19.4 实用中的正则表达式&lt;/h2&gt;

&lt;h3&gt;19.4.1 目录文件计数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mypath=`sed 's/:/ /g'`
count=0
for directory in $mypath
do
  check=`ls directory`
  for item in $check
  do
    count=$[ $count - 1 ]
  done
  echo &quot;$directory - $count&quot;
  count=0
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.4.2 验证电话号码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;19.4.3 解析邮箱&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;username@hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;username&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点号&lt;/li&gt;
&lt;li&gt;单破折线&lt;/li&gt;
&lt;li&gt;加号&lt;/li&gt;
&lt;li&gt;下划线&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;服务器名和域名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点号&lt;/li&gt;
&lt;li&gt;下划线&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;解析邮箱的正则表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/31/chapter19-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/31/chapter19-lclss</guid>
                <pubDate>2013-01-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>初识sed和gawk chapte18 LCLSS</title>
                <description>&lt;h1&gt;第18章 初识sed和gawk&lt;/h1&gt;

&lt;h2&gt;18.1 文本处理&lt;/h2&gt;

&lt;p&gt;命令行编辑器: sed和gawk&lt;/p&gt;

&lt;h3&gt;18.1.1 sed编辑器&lt;/h3&gt;

&lt;p&gt;流编辑器(stream editor), 在编辑器处理数据之前基于预先提供的一组规则来编辑数据流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed options script file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sed命令行选项&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;选项    &lt;/th&gt;
&lt;th&gt; 描述    &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-e script &lt;/td&gt;
&lt;td&gt; 在处理输入时,将script中指定的命令添加到运行的命令中|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-f file &lt;/td&gt;
&lt;td&gt;在处理输入时,将file中指定的命令添加到运行的命令中|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-n &lt;/td&gt;
&lt;td&gt; 不要为每个命令生成输出,等待print命令来输出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;script参数指定了将作用在流数据上的单个命令,如果需要多个命令,必须用-e选项或者-f选项&lt;/p&gt;

&lt;h4&gt;1. 命令行定义编辑器命令&lt;/h4&gt;

&lt;p&gt;默认情况下,sed编辑器会将制定的命令应用于STDIN输入流,因此可以直接使用流控制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;This is a test&quot; | sed 's/test/big test/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;s/string/new string/&lt;/code&gt; 替换&lt;/p&gt;

&lt;h4&gt;2. 在命令行使用多个编辑器命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e 's/brown/green/; s/dog/cat/' date1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令行之间用&lt;code&gt;;&lt;/code&gt;,命令末尾和分号之间不能有空格&lt;/p&gt;

&lt;p&gt;可以用次提示符分割命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e '
s/brown/green/
s/fox/elephant/
s/dog/cat/' date1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 从文件中读取编辑器命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#script1
s/brown/green/
s/fox/elephone/
s/dog/cat/

sed -f script1 data1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;18.1.2 gawk程序&lt;/h3&gt;

&lt;p&gt;awk程序的GNU版本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义变量保存数据&lt;/li&gt;
&lt;li&gt;使用算术和字符串操作来处理数据&lt;/li&gt;
&lt;li&gt;使用结构化编程概念,比如if-then语句和循环语句,来为数据处理增加逻辑&lt;/li&gt;
&lt;li&gt;提取数据文件中的数据元素并将他们按另一顺序或格式重新放置,从而生成格式化报告&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. gawk命令格式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;gawk options program file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gawk选项&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;选项          &lt;/th&gt;
&lt;th&gt;描述                            &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-F fs        &lt;/td&gt;
&lt;td&gt;指定行中分割数据字段的字段分隔符     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-f file      &lt;/td&gt;
&lt;td&gt;指定读取程序的文件名               |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-v var=value &lt;/td&gt;
&lt;td&gt;定义gawk程序中的一个变量及其默认值  |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-mf N        &lt;/td&gt;
&lt;td&gt;指定要处理的数据文件中的最大字段数   |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-mr N        &lt;/td&gt;
&lt;td&gt;指定数据文件中的最大数据行数        |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-W keyword   &lt;/td&gt;
&lt;td&gt;指定gawk的兼容模式和警告等级       |&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h4&gt;2. 从命令行读取程序脚本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;gawk '{print &quot;Hello John!&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EOF(CTRL-D)&lt;/p&gt;

&lt;h4&gt;3. 使用数据字段变量&lt;/h4&gt;

&lt;p&gt;每个数据字段都有一个变量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$0代表整个文本行&lt;/li&gt;
&lt;li&gt;$1 代表第一个数据字段&lt;/li&gt;
&lt;li&gt;$2 代表第二个数据字段&lt;/li&gt;
&lt;li&gt;$n 代表第n个数据字段&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;字段分隔符&lt;/code&gt;来划分数据字段&lt;/p&gt;

&lt;p&gt;默认字段分隔符是任意的空白字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#data3
One line of test text
Two lines of test text
Three lines of test text

gawk '{print $1}' data3
One
Two
Three
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-F:&lt;/code&gt;选项将分隔符换成&lt;code&gt;:&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;4. 在程序脚本中使用多个命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;My name is Rich&quot; | gawk '{$4=&quot;Christine&quot;; print $0}'

gawk '{
$4=&quot;testing&quot;
print $0 }'
This is not a good test
&amp;gt;This is not testing good test
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5. 在文件中读取程序&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#script2
{ print $1 &quot;'s home directory is &quot; $6}

gawk -F: -f script2 /etc/passwd

{
text = &quot;'s home directory is &quot;
print $1 text $6   #注意对text变量的引用不需要加$符号
}
gawk -F: -f script3 /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;6. 在处理数据前运行脚本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;BEGIN&lt;/code&gt; 关键字,强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gawk 'BEGIN {print &quot;Hello World!&quot;}'

#data4
Line 1
Line 2
Line 3
gawk 'BEGIN {print &quot;The data4 File Contents: &quot;} { print $0 }' data4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;7.在处理数据后运行脚本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;END&lt;/code&gt;关键字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#data4
Line 1
Line 2
Line 3
gawk 'BEGIN {print &quot;The data4 File Contents: &quot;} { print $0 } END { print &quot;End of File&quot;} ' data4

#script4
BEGIN {
print &quot;The latest list of users and shells&quot;
print &quot; Userid            shell&quot;
print &quot;---------         ------&quot;
FS=&quot;:&quot;
}
{
print $1 &quot;    &quot; $7
}
END {
print &quot;This concludes the listing&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;18.2 sed编辑器基础&lt;/h2&gt;

&lt;h3&gt;18.2.1 更多的替换选项&lt;/h3&gt;

&lt;p&gt;s(substitute)&lt;/p&gt;

&lt;h4&gt;1. 替换标记&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed 's/test/trial/' data5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况只替换每行的第一个test&lt;/p&gt;

&lt;p&gt;&lt;code&gt;替换标记&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s/pattern/replacement/flags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flags&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数字, 表明新文本将替换第几处模式匹配的地方&lt;/li&gt;
&lt;li&gt;g, 新文本替换所有已有文本出现的地方&lt;/li&gt;
&lt;li&gt;p, 原来行的内容要打印出来&lt;/li&gt;
&lt;li&gt;w file, 将替换结果写到文件中&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;-n&lt;/code&gt;选项禁止sed输出,&lt;code&gt;p&lt;/code&gt;标记会输出修改过的行,两者配合使用则只输出被substitute命令修改过的行&lt;/p&gt;

&lt;p&gt;w标记会产生同样的输出,不过会输出保存到指定的文件,只有那些包含模式匹配的行才会保存在指定的输出文件中&lt;/p&gt;

&lt;h4&gt;2. 替换字符&lt;/h4&gt;

&lt;p&gt;sed 处理中用&lt;code&gt;/&lt;/code&gt;来分割pattern和replacement,如果pattern或replacement中有&lt;code&gt;/&lt;/code&gt;(如目录),就需要有&lt;code&gt;\&lt;/code&gt;来转义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed `s/\/bin\/bash/\/bin\/csh/' /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sed允许substitute命令中用其他字符来进行分割&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed `s!/bin/bash!/bin/csh!` /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用&lt;code&gt;!&lt;/code&gt;来进行分割&lt;/p&gt;

&lt;h3&gt;18.2.2 使用地址&lt;/h3&gt;

&lt;p&gt;默认命令会作用于所有行, 如果只想命令作用于特定行或者某些行, 要使用&lt;strong&gt;行寻址(line addressing)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行的数字范围&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用文本模式来过滤出某行&lt;/p&gt;

&lt;p&gt;  [address]command
  或
  address {
  command1
  command2
  }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. 数字方式的行寻址&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed '2s/dog/cat/' data1

sed '2,3s/dog/cat/' data1 #使用范围,注意是逗号

sed '2,$s/dog/cat/' data1 #到末尾
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 使用文本模式过滤器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/pattern/command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用文本模式来过滤出命令要作用的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '/pattern/s/string/replace/' file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pattern可以使用正则表达式(regular expression)&lt;/p&gt;

&lt;h4&gt;3. 组合命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed '2{
s/fox/elephant/
s/dog/cat/
}'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多条命令&lt;/p&gt;

&lt;h3&gt;18.2.3 删除行&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;delete&lt;/code&gt;命令, 删除匹配的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '3d' data7  #删除第3行

sed '/pattern/d' file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用两个文本模式删除某个范围内的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '/1/,/3/d' data6  #删除匹配模式/1/到匹配模式/3/之间的所有行,包括这两行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/1/打开行删除,/3/关闭行删除,下一个匹配/1/时,删除行模式又被打开,直到下一个/3/&lt;/p&gt;

&lt;h3&gt;18.2.3 插入和附加文本&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;插入(insert)命令&lt;code&gt;i&lt;/code&gt;会在指定行前增加一个新行&lt;/li&gt;
&lt;li&gt;追加(append)命令&lt;code&gt;a&lt;/code&gt;会在指定行后增加一个新行&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '[address]command\
new line'

echo &quot;Test Line 2&quot; | sed 'i\Test line 1'

echo &quot;Test line 2&quot; | sed 'a\Test line 1'

echo &quot;Test line2&quot;  | sed 'i\
Test line 1'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定行地址, 可以是数字行号或文本模式,但不能用地址区间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '3i\
This is an inserted line.' data3 #插入到第三行前

sed '3i\
This is an inserted line.' data3 #插入到第三行之后
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入多行,用&lt;code&gt;\&lt;/code&gt;隔开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '1i\
This is one line of new text.\
This is another line of new text.' data7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;18.2.5 修改行&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;change&lt;/code&gt;命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '3c\
This is a changed line of text.' data7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可使用文本模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '/number 3/c\
This is a changed line of text.' data7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改匹配的所有行&lt;/p&gt;

&lt;p&gt;可以使用地址区间,但是用一行文本来替换整个区间&lt;/p&gt;

&lt;h3&gt;18.2.6 转换命令&lt;/h3&gt;

&lt;p&gt;转换(transform, y)命令是唯一可以处理单个字符的sed编辑器命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[address]y/inchars/outchars/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inchars到outchars是一一映射&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 'y/123/789/' data7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以一整行为单位,无法只转换一行当中的一部分&lt;/p&gt;

&lt;h3&gt;18.2.7 回顾打印&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;小写p命令用来打印文本行&lt;/li&gt;
&lt;li&gt;等号(=)命令用来打印行号&lt;/li&gt;
&lt;li&gt;l命令用来列出行号&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. 打印行&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;this is a test&quot; | sed 'p'

sed -n '/number 3/p' data7 #打印包含/number 3/模式的行

sed -n '2,3p' data7 #打印2,3行

sed -n '/3/{
p
s/line/test/p
}' data7
# 在修改之前查看
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 打印行号&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sed '=' data7

sed -n '/number4/{
=
p
}' data7
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 列出行&lt;/h4&gt;

&lt;p&gt;列出命令(l)允许打印数据流中的文本和不可打印的ASCII字符,任何不可打印字符都用它们的八进制值加一个反斜杠或标准的C风格命令法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This    line    contains    tabs
sed -n 'l' data9
This\tline\tcontains\ttabs$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;18.2.8 用sed和文件一起工作&lt;/h3&gt;

&lt;h4&gt;1. 向文件写入&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;命令,向文件写入行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[address]w filename

sed '2,3w test' data7  #将data7的2,3行写入test文件

sed -n '/IN/w INcustomers' data11 #将含有IN的行写入到INcustomers文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 从文件读取&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;r&lt;/code&gt;命令,从文件读取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[address]r filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能读取一个区间,只能读取单独一个行号或者文本模式地址,sed会将文件中的文本插入到地址后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '3r data12' data7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较好的用途是结合删除命令来替换文件中的数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#letter
Would the following people:
LIST
please report to the office.

sed '/LIST/{
r data11
d
}' letter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;r&lt;/code&gt;命令来插入,在删除占位符&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/30/chapter18-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/30/chapter18-lclss</guid>
                <pubDate>2013-01-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>图形化桌面上的脚本编程 chapte17 LCLSS</title>
                <description>&lt;h1&gt;第17章 图形化桌面上的脚本编程&lt;/h1&gt;

&lt;h2&gt;17.1 创建文本菜单&lt;/h2&gt;

&lt;h3&gt;17.1.1 创建菜单布局&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;clear&lt;/code&gt; 命令用当前终端会话的terminfo数据来清理 出现在屏幕上的文本,接着用echo来显示菜单元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;中显示制表符,换行符等,使用&lt;code&gt;-e&lt;/code&gt;选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo -e &quot;1.\tDisplay disk space&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对排版来说大有好处&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clear
echo
echo -e &quot;\t\t\tSys Admin Menu\n&quot;
echo -e &quot;\t1. Display disk space&quot;
echo -e &quot;\t2. Display logged on users&quot;
echo -e &quot;\t3. Display memory usage&quot;
echo -e &quot;\t0. Exit menu\n\n&quot;
echo -en &quot;\t\tEnter option: &quot;
read -n 1 option
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;17.1.2 创建菜单函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;桩函数(stub function)&lt;/strong&gt;,用来占位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function diskspace {
  clear
  echo &quot;This is where the diskspace commands will go&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将菜单布局本身作为一个函数创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function menu {
    clear
    echo
    echo -e &quot;\t\t\tSys Admin Menu\n&quot;
    echo -e &quot;\t1. Display disk space&quot;
    echo -e &quot;\t2. Display logged on users&quot;
    echo -e &quot;\t3. Display memory usage&quot;
    echo -e &quot;\t0. Exit menu\n\n&quot;
    echo -en &quot;\t\tEnter option: &quot;
    read -n 1 option
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;17.1.3 添加菜单逻辑&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt;命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;menu
case $option in
0)
    break ;;
1)
    diskspace ;;
2) 
    whoseon ;;
3)
    memusage ;;
*)
    clear
    echo &quot;Sorry, wrong selection&quot; ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;17.1.4 整合shell脚本菜单&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function diskspace {
    clear
    df -k
}
function whoseon {
    clear
    who
}
function memusage {
    clear
    cat /proc/meminfo
}
function menu {
    clear
    echo
    echo -e &quot;\t\t\tSys Admin Menu\n&quot;
    echo -e &quot;\t1. Display disk space&quot;
    echo -e &quot;\t2. Display logged on users&quot;
    echo -e &quot;\t3. Display memory usage&quot;
    echo -e &quot;\t0. Exit menu\n\n&quot;
    echo -en &quot;\t\tEnter option: &quot;
    read -n 1 option
}

while [ 1 ]
do
    menu
    case $option in
    0)
        break ;;
    1)
        diskspace ;;
    2) 
        whoseon ;;
    3)
        memusage ;;
    *)
        clear
        echo &quot;Sorry, wrong selection&quot; ;;
    esac
    echo -en &quot;\n\n\t\tHit and key to continue&quot;
    read -n 1 line 
done    
clear
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;17.1.5 使用select命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;select&lt;/code&gt;命令允许从单个命令行创建菜单,然后再提取输入的答案并自动处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select variable in list
do
    commands
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list参数是构成菜单的空格分割的文本选项列表&lt;/p&gt;

&lt;p&gt;select命令会在列表中将每个选项作为一个编好号的选项显示,然后为选项显示一个特殊的由PS3环境变量定义的提示符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function diskspace {
    clear
    df -k
}
function whoseon {
    clear
    who
}
function memusage {
    clear
    cat /proc/meminfo
}

PS3=&quot;Enter option: &quot;
select option in &quot;Display disk space&quot; &quot;Display logged on users&quot; &quot;Display memory usage&quot; &quot;Exit program&quot;
do
    case $option in
    &quot;Exit program&quot;)
        break;;
    &quot;Display disk space&quot;)
        diskspace;;
    &quot;Display logged on users&quot;)
        whoseon;;
    &quot;Display memory usage&quot;)
        memusage;;
    *)
        clear
        echo &quot;Sorry, wrong selection&quot;;;
    esac
done
clear
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;17.2 使用窗口&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dialog&lt;/code&gt;包,能将文本环境总用ANSI转义控制字符来创建标准的窗口对话框&lt;/p&gt;

&lt;h3&gt;17.3 dialog包&lt;/h3&gt;

&lt;p&gt;部件(widget)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;dialog部件 p361&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;dialog --widget parameters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;parameters定义了部件的大小以及部件需要的文本&lt;/p&gt;

&lt;p&gt;每个dialog部件提供了两种格式的输出&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用STDERR&lt;/li&gt;
&lt;li&gt;使用退出状态码&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;退出状态码决定了用户选择的按钮,可以用&lt;code&gt;#?&lt;/code&gt;来查看具体选择了哪个按钮&lt;/p&gt;

&lt;p&gt;如果部件返回了任何数据,比如菜单选择, 那么dialog命令会将数据发送到STDERR,可以重定向之&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dialog --inputbox &quot;Enter your age:&quot; 10 20 2&amp;gt;age.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;1. msgbox部件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dialog --msgbox text height width
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--title&lt;/code&gt; 顶部标题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dialog --title testing --msgbox &quot;This is a test&quot; 10 20
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. yesno部件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dialog --title &quot;Please answer&quot;  --yesno &quot;Is this thing on?&quot; 10 20

echo $?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.inputbox部件&lt;/h4&gt;

&lt;p&gt;会将输入发送给STDERR&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dialog --inputbox &quot;Enter your age&quot; 10 20 2&amp;gt;age.txt
echo $?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. textbox部件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dialog --textbox /etc/passwd 15 45
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5. menu部件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dialog --menu &quot;Sys Admin Menu &quot; 20 30 10 1 &quot;Display disk space&quot; 2 &quot;Display users&quot; 3 &quot;Display memory usage&quot; 4 &quot;Exit&quot; 2&amp;gt; test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;6. fselect部件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dialog --title &quot;Select a file&quot; --fselect $HOME/ 10 50 2&amp;gt;file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;17.2.2 dialog选项&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;dialog命令选项&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;17.2.3 在脚本中使用dialog命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果有Cancel或No按钮,检查dialog命令的退出状态码&lt;/li&gt;
&lt;li&gt;重定向STDERR来获得输出值&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;一个脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;temp=`mktemp -t test.XXXXXX`
temp=`mktemp -t test2.XXXXXX`

function diskspace {
    df -k &amp;gt; $temp
    dialog --textbox $temp 20 60
}
function whoseon {
    who &amp;gt; $temp
    dialog --textbox $temp 20 50
}
function memusage {
    cat /proc/meminfo
    dialog --textbox $temp 20 50
}
function menu {
    clear
    echo
    echo -e &quot;\t\t\tSys Admin Menu\n&quot;
    echo -e &quot;\t1. Display disk space&quot;
    echo -e &quot;\t2. Display logged on users&quot;
    echo -e &quot;\t3. Display memory usage&quot;
    echo -e &quot;\t0. Exit menu\n\n&quot;
    echo -en &quot;\t\tEnter option: &quot;
    read -n 1 option
}

while [ 1 ]
do
    dialog --menu &quot;Sys Admin Menu &quot; 20 30 10 1 &quot;Display disk space&quot; 2 &quot;Display users&quot; 3 &quot;Display memory usage&quot; 4 &quot;Exit&quot; 2&amp;gt; temp2

    if [ $? -eq 1 ]
    then
        break
    fi

    selection=`cat $temp2`
    case $selection in
    0)
        break ;;
    1)
        diskspace ;;
    2) 
        whoseon ;;
    3)
        memusage ;;
    *)
        clear
        dialog --msgbox &quot;Sorry, invalid selection&quot; 10 30 ;;
    esac
    done
    rm -f $temp 2&amp;gt; /dev/null
    rm -f $temp2 2&amp;gt; /dev/null   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;17.3 使用图形&lt;/h2&gt;

&lt;p&gt;kdialog 和 zenity包, 各自为KDE和GNOME桌面提供了图形化窗口部件&lt;/p&gt;

&lt;h3&gt;17.3.1 KDE环境&lt;/h3&gt;

&lt;p&gt;kdialog包&lt;/p&gt;

&lt;h4&gt;1. kdialog部件&lt;/h4&gt;

&lt;p&gt;和dialog包类似&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kdialog display-options window-options arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;window-options&lt;/code&gt;选项允许指定使用哪种类型的窗口部件&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;kdialog窗口选项&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;kdialog --checklist &quot;Item I need&quot; 1 &quot;Toothbrush&quot; on 2 &quot;Toothpaste&quot; off 3 &quot;Hair brush&quot; on 4 &quot;Deodorant&quot; off 5 &quot;lippers&quot; off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认发送到STDOUT&lt;/p&gt;

&lt;h4&gt;2. 使用kdialog&lt;/h4&gt;

&lt;p&gt;kdialog使用STDOUT输出,而dialog用STDERR输出&lt;/p&gt;

&lt;p&gt;使用和dialog包几乎完全一样&lt;/p&gt;

&lt;h3&gt;17.3.2 GNOME环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;gdialog&lt;/li&gt;
&lt;li&gt;zenity&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. zenity部件&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;zenity窗口部件&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;zenity命令行程序于dialog工作方式有些不同, 许多部件类型都用命令行上的其他选项定义,而不是将它们包括在选项参数里&lt;/p&gt;

&lt;p&gt;将结果输出到STDOUT&lt;/p&gt;

&lt;h4&gt;2. 在脚本总使用zenity&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;zenity --text-info --title &quot;Logged in users&quot; --filename=$temp --width 500 --height 500
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/30/chapter17-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/30/chapter17-lclss</guid>
                <pubDate>2013-01-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>创建函数 chapte16 LCLSS</title>
                <description>&lt;h1&gt;第16章 创建函数&lt;/h1&gt;

&lt;h2&gt;16.1 基本的脚本函数&lt;/h2&gt;

&lt;p&gt;函数(function)&lt;/p&gt;

&lt;h3&gt;16.1.1 创建函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function name {
    commands
}

name() {
    commands
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;16.1.2 使用函数&lt;/h3&gt;

&lt;p&gt;跟使用其他shell命令一样&lt;/p&gt;

&lt;p&gt;函数要在定义后才能使用,而定义只要在使用之前就行&lt;/p&gt;

&lt;p&gt;定义了两个相同的函数,第一个函数将被覆盖&lt;/p&gt;

&lt;h2&gt;16.2 返回值&lt;/h2&gt;

&lt;p&gt;bash shell 把函数当成小型脚本,运行结束时会返回一个退出状态码&lt;/p&gt;

&lt;h3&gt;16.2.1 默认退出状态码&lt;/h3&gt;

&lt;p&gt;默认状态,是最后一条命令返回的退出状态码.&lt;/p&gt;

&lt;p&gt;在函数执行结束厚,可以用&lt;code&gt;$?&lt;/code&gt;变量来决定函数的确定函数的退出状态码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func1() {
  echo &quot;trying to display a not-existent file&quot;
  ls -l badfile
}

echo &quot;testing the function&quot;

func1

echo &quot;The exit status is: $?&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只能确定最后一条的退出状态码,不能确定是否所有命令都运行正确&lt;/p&gt;

&lt;h3&gt;16.2.2 使用return命令&lt;/h3&gt;

&lt;p&gt;return可以指定一个退组状态码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function dbl {
  read -p &quot;Enter a value: &quot; value
  echo &quot;doubling the value&quot;
  return $[ $value * 2 ]
}

dbl
echo &quot;The new value is $?&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;要立即取返回值,否则可能被覆盖&lt;/li&gt;
&lt;li&gt;返回值要在0-255之间&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;16.2.3 使用函数输出&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;result=`dbl`  类似于脚本输出的保存

function dbl {
    read -p &quot;Enter a value: &quot; value
    echo $[ $value * 2 ]
}

result=`dbl`
echo &quot;The new value is $result&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个技术函数最后一行要使用echo&lt;/p&gt;

&lt;h2&gt;16.3 在函数中使用变量&lt;/h2&gt;

&lt;h3&gt;16.3.1 向函数传递参数&lt;/h3&gt;

&lt;p&gt;函数可以使用标准的参数环境变量来代表命令行上传给函数的参数(函数名在$0中,参数在$1,$2…),亦可使用特殊变量$#来判断传给函数的参数数目(和传给脚本的参数相似)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function addem{
  if [ $# -eq 0 ] || [ $# -gt 2 ]
  then
    echo -1
  elif
  then
    echo $[ $1 + $1 ]
  else
    echo $[ $1 + $2 ]
  fi
}

echo -n &quot;Adding 10 and 15: &quot;
value=`addem 10 15`
echo $value
echo -n &quot;Let's try adding just one number: &quot;
value=`addem 10`
echo $value
echo -n &quot;Now trying adding no numbers: &quot;
value=`addem`
echo $value
echo -n &quot;Finally, try adding three numbers: &quot;
value=`addem 10 15 20`
echo $value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shell脚本的空格很是麻烦啊&lt;/p&gt;

&lt;p&gt;因为函数使用特殊的环境变量作为自己的参数值,因此函数不能直接从脚本的命令行获取脚本的参数值&lt;/p&gt;

&lt;p&gt;要通过传递来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fun7{
  echo $[ $1 * $2 ]
}   

if [ $# -eq 2 ]
then
#    value=`fun7` 错误
  value=`fun7 $1 $2`
  echo &quot;The result is $value&quot;
else
  echo &quot;Usage: badtest1 a b &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;16.3.2 在函数中处理变量&lt;/h3&gt;

&lt;p&gt;作用域&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. 全局变量&lt;/h4&gt;

&lt;p&gt;全局有效,可以在基本主体部分定义,也可在函数中定义&lt;/p&gt;

&lt;p&gt;默认情况下定义的变量都是全局变量,即在主体部分定义的变量,可以在函数在用使用和修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func1 {
  temp=$[ $value + 5 ]
  result=$[ $temp + 2 ]
}

temp=4
value=6

func1
echo &quot;The result is $result&quot;
if [ $temp -gt $value ]
then
  echo &quot;temp is larger&quot;
else
  echo &quot;temp is smaller&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;temp可以在函数func1中使用和改变,result可以在主体部分使用,只会引起混乱&lt;/p&gt;

&lt;h4&gt;2. 局部变量&lt;/h4&gt;

&lt;p&gt;函数中的局部变量,&lt;code&gt;local&lt;/code&gt;关键字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local temp  局部变量的定义

function func1 {
  local temp=$[ $value + 5 ]
  result=$[ $temp + 2 ]
}

temp=4
value=6

func1
echo &quot;The result is $result&quot;
if [ $temp -gt $value ]
then
  echo &quot;temp is larger&quot;
else
  echo &quot;temp is smaller&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;16.4 属组变量和函数&lt;/h2&gt;

&lt;h3&gt;16.4.1 向函数传数组参数&lt;/h3&gt;

&lt;p&gt;直接用一个变量传递数组,只有数组的第一个值被传送&lt;/p&gt;

&lt;p&gt;先将数组分解成单个值将这些值作为函数参数使用,在函数内部将所有参数重组到新的数组变量中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function testit {
    local newarray
    newarray=(`echo &quot;$@&quot;`)
    echo &quot;The new array value is:  ${newarray[*]}&quot;
}

myarray=(1 2 3 4 5)
echo &quot;The original array is ${myarray[*]}&quot;
testit ${myarray[*]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;16.4.2 从函数返回数组&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function arraybdlr {
  local origarray
  local newarray
  local elements
  local i

  origarray=(`echo &quot;$@&quot;`)
  newarray=(`echo &quot;$@&quot;`)
  elements=$[ $# - 1 ]
  for (( i = 0; i &amp;lt;= $elements; i++))
  {
    newarray[$i]=$[ ${origarray[$i]} * 2 ]
  }
  echo ${newarray[*]}
}

myarray=(1 2 3 4 5)
echo &quot;The original array is: ${myarray[*]}&quot;
arg1=`echo ${myarray[*]}`
result=(`arrayblr $arg1`)
echo &quot;The new array is: ${result[*]}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;16.5 函数递归&lt;/h2&gt;

&lt;p&gt;自成体系(self-containment)&lt;/p&gt;

&lt;p&gt;递归调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function factorial {
  if[ $1 -eq 1 ]
  then
    echo 1
  else
    local temp=$[ $1 - 1 ]
    local result=`factorial temp`
    echo $[ $result * $1 ]
  fi
}

read -p &quot;Enter value: &quot; value

result=`factorial $value`

echo &quot;The factorial of $value is: $result&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;16.6 创建库&lt;/h2&gt;

&lt;p&gt;函数库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;source&lt;/code&gt; 命令, 快捷别名&lt;code&gt;.&lt;/code&gt;点操作符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#myfuncs 函数库
function addem {
  echo $[ $1 + $2 ]
}
function multem {
  ehco $[ $1 * $2 ]
}
function divem {
  echo $[ $1 / $2 ]
}

#使用函数库
. ./myfuncs

value1=10
value2=5

result1=`addem $value1 $value2`
result2=`multem $value1 $value2`
result3=`divem $value1 $value2`

echo $result1
echo $result2
echo $result3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;16.7 在命令行上使用函数&lt;/h2&gt;

&lt;h3&gt;16.7.1 在命令行上创建函数&lt;/h3&gt;

&lt;p&gt;可以直接在命令行上定义函数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一行内定义整个函数&lt;/p&gt;

&lt;p&gt; function divem { echo $[ $1 / $2 ]; }&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在每个命令后加&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;多行定义函数,不需要在每行后面加&lt;code&gt;;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果定义的函数和内建函数名相同,内建函数会被覆盖&lt;/p&gt;

&lt;h3&gt;16.7.2 在.bashrc文件中定义函数&lt;/h3&gt;

&lt;p&gt;命令行上定义函数,在shell退出以后函数就消失了&lt;/p&gt;

&lt;h4&gt;1. 直接定义函数&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;.bashrc&lt;/code&gt;文件末尾加上定义即可&lt;/p&gt;

&lt;h4&gt;2. 读取函数文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;source&lt;/code&gt;或者点操作符来加载函数文件&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/29/chapter16-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/29/chapter16-lclss</guid>
                <pubDate>2013-01-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>控制脚本 chapte15 LCLSS</title>
                <description>&lt;h1&gt;第15章 控制脚本&lt;/h1&gt;

&lt;h2&gt;15.1 处理信号&lt;/h2&gt;

&lt;h3&gt;15.1.1 重温Linux信号&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; &lt;/th&gt;
&lt;th&gt;信号&lt;/th&gt;
&lt;th&gt; 值   &lt;/th&gt;
&lt;th&gt;   描述     &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;1  &lt;/td&gt;
&lt;td&gt;SIGUP &lt;/td&gt;
&lt;td&gt;挂起进程     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;2  &lt;/td&gt;
&lt;td&gt;SIGINT&lt;/td&gt;
&lt;td&gt;终止进程     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;3  &lt;/td&gt;
&lt;td&gt;GIGQUIT&lt;/td&gt;
&lt;td&gt;停止进程    |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;9  &lt;/td&gt;
&lt;td&gt;SIGKILL&lt;/td&gt;
&lt;td&gt;无条件终止进程|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;15 &lt;/td&gt;
&lt;td&gt;SIGTERM&lt;/td&gt;
&lt;td&gt;无可能的话终止进程|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;17 &lt;/td&gt;
&lt;td&gt;SIGSTOP&lt;/td&gt;
&lt;td&gt;无条件停止进程,但不终止进程|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;18 &lt;/td&gt;
&lt;td&gt;SIGTSTP&lt;/td&gt;
&lt;td&gt;停止或暂停进程,但不终止进程|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;19 &lt;/td&gt;
&lt;td&gt;SIGCONT&lt;/td&gt;
&lt;td&gt;继续运行停止的进程|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;15.1.2 产生信号&lt;/h3&gt;

&lt;h4&gt;1.终止进程&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CTRL-C&lt;/code&gt; 产生SIGINT信号,终止当前进程&lt;/p&gt;

&lt;h4&gt;2. 暂停进程&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CTRL-Z&lt;/code&gt; 产生SIGTSTP信号,停止当前进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PS&lt;/code&gt;命令中&lt;code&gt;T&lt;/code&gt;状态的进程表示停止的进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -9 PID&lt;/code&gt; 饭送SIGKILL信号终止进程&lt;/p&gt;

&lt;h3&gt;15.1.3 捕捉信号&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;trap&lt;/code&gt; 命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;trap commands signals&lt;/code&gt; 指定shell脚本要观察那些Linux信号并从shell中拦截, 如果脚本收到trap命令中列出的信号,他会阻止它被shell处理,而在本地处理它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trap &quot;echo ' Sorry! I have traped Ctrl-C'&quot; SIGINT SIGTERM
echo this is a test program
count=1
while [ $count -le 10 ]
do
    echo &quot;Loop #$count&quot;
    sleep 5
    count=$[ $count + 1 ]
done
echo This is the end of the test program
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次使用'CTRIL-C'组合键,脚本都会执行trap命令中指定的echo语句,而不是忽略此信号并允许shell停止该脚本&lt;/p&gt;

&lt;h3&gt;15.1.4 捕捉脚本的退出&lt;/h3&gt;

&lt;p&gt;捕捉shell脚本的退出, 在&lt;code&gt;trap&lt;/code&gt;命令后面加上EXIT就行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trap &quot;echo byebye&quot; EXIT

count=1
while [ $count -le 5 ]
do
  echo &quot;Loop #$count&quot;
  sleep 3
  count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;15.1.5 移除捕捉&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;trap &quot;echo byebye&quot; EXIT

count=1
while [ $count -le 5 ]
do
  echo &quot;Loop #$count&quot;
  sleep 3
  count=$[ $count + 1 ]
done

trap - EXIT  #移除捕捉EXIT信号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果捕捉到信号在移除之前那么信号还是会本处理&lt;/p&gt;

&lt;h2&gt;15.2 以后台模式运行脚本&lt;/h2&gt;

&lt;p&gt;后台(background)&lt;/p&gt;

&lt;h3&gt;15.2.1 后台运行脚本&lt;/h3&gt;

&lt;p&gt;在命令后加&lt;code&gt;&amp;amp;&lt;/code&gt;符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./test &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;15.2.2 运行多个后台作业&lt;/h3&gt;

&lt;p&gt;可以通过&lt;code&gt;ps&lt;/code&gt;命令来查看运行中的脚本&lt;/p&gt;

&lt;h3&gt;15.2.3 退出终端&lt;/h3&gt;

&lt;p&gt;ps命令的输出中,每个后台进程都绑定到了该终端会话的终端上(pts/0),如果进程会话退出,后台进程也会退出&lt;/p&gt;

&lt;h3&gt;15.3 在非控制台下运行脚本&lt;/h3&gt;

&lt;p&gt;在终端会话中启动脚本,然后让进程一直以后台模式运行,直到其完成,即使退出了终端&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nohup&lt;/code&gt; 命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nohup&lt;/code&gt; 命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup ./test1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;STDOUT和STDERR被重定向到nohup.out文件&lt;/p&gt;

&lt;h2&gt;15.4 作业控制&lt;/h2&gt;

&lt;p&gt;启动,停止,无条件终止,恢复作业--作业控制&lt;/p&gt;

&lt;h3&gt;15.4.1 查看作业&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jobs&lt;/code&gt; 命令,显示当前作业&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-l 列出进程PID和作业号&lt;/li&gt;
&lt;li&gt;-n 列出上次shell发出的通知后改变了状态的作业&lt;/li&gt;
&lt;li&gt;-p 只列出作业的PID&lt;/li&gt;
&lt;li&gt;-r 只列出运行中的作业&lt;/li&gt;
&lt;li&gt;-s 只列出已停止的作业&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;+&lt;/code&gt;表示默认作业&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-&lt;/code&gt;表示下一个默认作业&lt;/p&gt;

&lt;h3&gt;15.4.2 重启停止的作业&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bg 作业号&lt;/code&gt; 后台重启&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fg 作业号&lt;/code&gt; 前台重启&lt;/p&gt;

&lt;h2&gt;15.5 调度谦让度&lt;/h2&gt;

&lt;p&gt;默认所有进程具有相同的&lt;strong&gt;调度优先级(schduling priority)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-20(最高优先级)到+20(最低优先级),默认使用0级来启动&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nice&lt;/code&gt; 命令,调整优先级&lt;/p&gt;

&lt;h3&gt;15.5.1 nice命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;nice -n 10 ./test4 &amp;gt; test4out &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;貌似普通用户只能降低优先级&lt;/p&gt;

&lt;h3&gt;15.5.2 renice命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;renice&lt;/code&gt; 改变系统上已经运行命令的优先级&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;renice 10 -p PID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将PID进程的优先级调整到10&lt;/p&gt;

&lt;h2&gt;15.6 定时运行作业&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;at&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cron&lt;/code&gt;表&lt;/p&gt;

&lt;h3&gt;15.6.1 用at命令来计划执行作业&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;at&lt;/code&gt;的守护进程&lt;code&gt;atd&lt;/code&gt;以后台模式运行,并检查作业队列来运行作业&lt;/p&gt;

&lt;p&gt;&lt;code&gt;atd&lt;/code&gt; 会检查系统上的一个特殊目录(通常位于/var/spool/at)来获取用&lt;code&gt;at&lt;/code&gt;命令提交的作业,如果作业时间和当前时间匹配,atd守护进程会运行此作业&lt;/p&gt;

&lt;h4&gt;1. at命令的格式&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;at [ -f filename ] time&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;默认情况下&lt;code&gt;at&lt;/code&gt;会将STDIN的输入放到队列中,可以用&lt;code&gt;-f&lt;/code&gt;参数来指定读取的命令(脚本)的文件名&lt;/p&gt;

&lt;p&gt;时间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;小时分钟格式, 如10:15&lt;/li&gt;
&lt;li&gt;~AM/~PM指示符,比如10:15~AM&lt;/li&gt;
&lt;li&gt;特定可命名的时间,比如now,noon,midnight或者teatime(4~PM)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果时间已经过去,那么会在第二天运行该作业&lt;/p&gt;

&lt;p&gt;日期&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;标准日期格式MMDDYY, MM/DD/YY或DD.MM.YY&lt;/li&gt;
&lt;li&gt;文本格式,比如Jul 4或Dec 25&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;时间增量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前时间+25min&lt;/li&gt;
&lt;li&gt;明天10:15~25min&lt;/li&gt;
&lt;li&gt;10:15+7天&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(应该是英文吧…)&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;at&lt;/code&gt;命令,作业会被提交到&lt;strong&gt;作业队列(job queue)&lt;/strong&gt;中&lt;/p&gt;

&lt;p&gt;针对不同的优先级,有26种不同的作业队列,a-z&lt;/p&gt;

&lt;p&gt;字母排序越高,优先级越低,&lt;code&gt;-q&lt;/code&gt;参数指定优先级&lt;/p&gt;

&lt;h4&gt;2. 获取作业的输出&lt;/h4&gt;

&lt;p&gt;作业默认输出到所有者的mail?,如果脚本没有任何输出,默认不生成邮件,&lt;code&gt;-m&lt;/code&gt;选项使得无论是否有输出都会生成一封邮件&lt;/p&gt;

&lt;h4&gt;3. 列出等待的作业&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;atq&lt;/code&gt; 命令查看系统中有哪些作业在等待&lt;/p&gt;

&lt;h4&gt;4. 删除作业&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;atrm 作业号&lt;/code&gt; 删除作业&lt;/p&gt;

&lt;h3&gt;15.6.2 计划定期执行脚本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cron&lt;/code&gt; 程序定期执行作业&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cron&lt;/code&gt; 在后台运行并检查特殊的称作&lt;strong&gt;cron时间表(cron table)&lt;/strong&gt;,来获得计划执行的作业&lt;/p&gt;

&lt;h4&gt;1. cron 时间表&lt;/h4&gt;

&lt;p&gt;格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min hour dayofmonth month dayofweek command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;允许用特定值,值范围(1~5),通配符(*)来指定条目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;15 10 * * * command  #每天10:15执行命令command

15 16 * * 1 command #每周一16:15分执行,周日是0

00 12 1 * * command #每月第一天中午
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每月最后一天,如何?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00 12 * * * if[`date +%d -d tomorrow` = 01 ];then; command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过一个判断语句来实现&lt;/p&gt;

&lt;p&gt;命令列表必须是命令或者脚本的全路径名,可加重定向符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;15 10 * * * /home/rich/test4 &amp;gt; test4out
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 构建cron时间表&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;crontab&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; 参数列出已有的时间表&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 参数为cron时间表添加条目,会打开一个文本编辑器&lt;/p&gt;

&lt;h4&gt;3. cron目录&lt;/h4&gt;

&lt;p&gt;如果不要求精确的执行时间,用预配置的cron脚本目录会更方便&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/etc/cron.daily&lt;/li&gt;
&lt;li&gt;/etc/cron.hourly&lt;/li&gt;
&lt;li&gt;/etc/cron.monthly&lt;/li&gt;
&lt;li&gt;/etc/cron.weekly&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;4. anacron程序&lt;/h4&gt;

&lt;p&gt;cron对过期的命令不再执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;anacron&lt;/code&gt;知道作业错过了计划好的运行,会尽快执行作业,关机错过执行好的作业会自动运行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;anacron&lt;/code&gt;只处理位于cron目录的程序,比如/etc/cron.monthly, 他用时间戳来决定作业是否在适当的计划间隔内运行了,每个cron目录都有一个时间戳文件,位于/var/spool/anacron&lt;/p&gt;

&lt;p&gt;&lt;code&gt;anacron&lt;/code&gt;有自己用来检查作业目录的表(通常位于/etc/anacrontab)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;anacron&lt;/code&gt;时间表的格式与cron时间表略有不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;period delay identifier command

1 5 cron.daily nice run-parts --report /etc/cron.daily
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;period 多久运行一次,以天为单位&lt;/li&gt;
&lt;li&gt;delay 在系统启动后多久运行错过的脚本&lt;/li&gt;
&lt;li&gt;command 包含run-parts程序和和一个cron脚本目录名, run-parts负责运行目录中传给他的任何脚本&lt;/li&gt;
&lt;li&gt;identifier 是一种特别的非空白字符串,如cron-weekly,用来唯一识别日志消息和错误E-mail中的作业&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;anacron不运行hourly的脚本,因为它不处理小于一天的脚本&lt;/p&gt;

&lt;h2&gt;15.7 启动运行&lt;/h2&gt;

&lt;h3&gt;15.7.1 开机时运行脚本&lt;/h3&gt;

&lt;h4&gt;1. 开机过程&lt;/h4&gt;

&lt;p&gt;内核加载到内存并运行,第一件事情就是开始UNIX System V init过程或Upstart init过程,然后这个进程负责启动Linux系统上的所有其他进程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;System V init过程&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;读取&lt;code&gt;/etc/inittab&lt;/code&gt;文件, inittab列出系统运行级(run level), 不同的运行级启动不同的程序和脚本&lt;/p&gt;

&lt;p&gt;Red Hat&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;运行级   &lt;/th&gt;
&lt;th&gt;描述      &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0       &lt;/td&gt;
&lt;td&gt; 关机     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1       &lt;/td&gt;
&lt;td&gt;单用户    |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2       &lt;/td&gt;
&lt;td&gt;多用户,不支持网络|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3       &lt;/td&gt;
&lt;td&gt;全功能多用户,支持网络|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4       &lt;/td&gt;
&lt;td&gt;可定义用户         |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5       &lt;/td&gt;
&lt;td&gt;多用户模式,支持网络和图形化X Window会话|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6       &lt;/td&gt;
&lt;td&gt;重启      |&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;Debian发行版,如ubuntu和Linux Mint,不区分2-5级&lt;/p&gt;

&lt;p&gt;Ubuntu甚至没有/etc/inittab文件,默认运行级2, 可以创建一个/etc/inittab文件来修改默认优先级&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开机脚本(startup script)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有些发行版本将开机脚本放在&lt;code&gt;/etc/rc#.d&lt;/code&gt;目录, #是运行级&lt;/p&gt;

&lt;p&gt;其他使用&lt;code&gt;/etc/init.d&lt;/code&gt;目录&lt;/p&gt;

&lt;p&gt;还有些使用&lt;code&gt;/etc/init.d/rc.d&lt;/code&gt;目录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Upstart init 过程&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;不关心运行级,而关注时间&lt;/p&gt;

&lt;p&gt;系统开机称为&lt;code&gt;开机事件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/event.d&lt;/code&gt;或者&lt;code&gt;/etc/init&lt;/code&gt;目录下的文件来启动&lt;/p&gt;

&lt;p&gt;许多Upstart实现仍然会调用位于&lt;code&gt;/etc/init.d&lt;/code&gt;和&lt;code&gt;/etc/rc#.d&lt;/code&gt;目录总的脚本&lt;/p&gt;

&lt;h4&gt;2. 定义自己的开机脚本&lt;/h4&gt;

&lt;p&gt;最好不要和Linux发行版上已有的独立开机脚本文件混起来&lt;/p&gt;

&lt;p&gt;大多数发行版本提供了一个本地开机文件专门让系统管理员添加开机时运行脚本&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;发行版  &lt;/th&gt;
&lt;th&gt;文件位置&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;debian &lt;/td&gt;
&lt;td&gt;/ect/init.d/rc.local|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Fedora &lt;/td&gt;
&lt;td&gt;/etc/rc.d/rc.local|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Mandriva &lt;/td&gt;
&lt;td&gt;/etc/rc.local|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;openSuse&lt;/td&gt;
&lt;td&gt;/etc/init.d/boot.local|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Ubuntu &lt;/td&gt;
&lt;td&gt;/etc/rc.local|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;centos &lt;/td&gt;
&lt;td&gt;/etc/rc.local|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;15.7.2 在新shell中启动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;.bash_profile  新shell是&lt;em&gt;新登陆&lt;/em&gt;生成&lt;/li&gt;
&lt;li&gt;.bashrc 新shell启动,包括新登录生成&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;为所有用户运行一个脚本,&lt;code&gt;/etc/bashrc&lt;/code&gt;文件&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/29/chapter15-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/29/chapter15-lclss</guid>
                <pubDate>2013-01-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>呈现数据 chapter14 LCLSS</title>
                <description>&lt;h1&gt;第14章 呈现数据&lt;/h1&gt;

&lt;h2&gt;14.1 理解输入和输出&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在显示器上显示输出&lt;/li&gt;
&lt;li&gt;将输出重定向到文件中&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;14.1.1 标准文件描述符&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;来标示每个文件对象&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;文件描述符 &lt;/th&gt;
&lt;th&gt;缩写   &lt;/th&gt;
&lt;th&gt;描述    &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0        &lt;/td&gt;
&lt;td&gt;STDIN &lt;/td&gt;
&lt;td&gt;标准输入 |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1        &lt;/td&gt;
&lt;td&gt;STDOUT&lt;/td&gt;
&lt;td&gt;标准输出 |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2        &lt;/td&gt;
&lt;td&gt;STDERR&lt;/td&gt;
&lt;td&gt;标准错误 |&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h4&gt;1. STDIN&lt;/h4&gt;

&lt;p&gt;输入重定向(&lt;code&gt;&amp;lt;&lt;/code&gt;),Linux会用重定向指定的文件来替换标准输入文件描述符.&lt;/p&gt;

&lt;h4&gt;2. STDOUT&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;输出重定向&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;重定向追加&lt;/p&gt;

&lt;h4&gt;3. STDERR&lt;/h4&gt;

&lt;p&gt;标准错误输出&lt;/p&gt;

&lt;h3&gt;14.1.2 重定向错误&lt;/h3&gt;

&lt;h4&gt;1.只重定向错误&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;2&amp;gt;&lt;/code&gt; 将错误消息重定向&lt;/p&gt;

&lt;h4&gt;2.重定向错误和数据&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;ls -al test1 test2 test3 badtest 2&amp;gt; test6 1&amp;gt; test7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别重定向&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; 错误和输出重定向到同一个文件&lt;/p&gt;

&lt;p&gt;错误消息优先级较高,错误一般都在输出文件的头部&lt;/p&gt;

&lt;h2&gt;14.2 在脚本中重定向输出&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;临时重定向每行输出&lt;/li&gt;
&lt;li&gt;永久重定向脚本中的所有命令&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;14.2.1 临时重定向&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;This is an error&quot; &amp;gt;&amp;amp;2  注意有&amp;amp;符号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会使这条文本重定向到STDERR文件描述符所指的位置&lt;/p&gt;

&lt;h3&gt;14.2.2 永久重定向&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 重定向&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec 1&amp;gt;testout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;会重新启动一个shell,并将STDOUT文件描述符重定向到文件,脚本中所有STDOUT的输出都会被重定向到文件&lt;/p&gt;

&lt;h2&gt;14.3 在脚本中重定向输入&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;exec 0&amp;lt; testfile&lt;/code&gt;  将STDIN重定向为文件testfile&lt;/p&gt;

&lt;h2&gt;14.4 创建自己的重定向&lt;/h2&gt;

&lt;h3&gt;14.4.1 创建输出文件描述符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;exec 3&amp;gt;test13out

echo &quot;this should display on the monitor&quot;
echo &quot;and this  should be stored in the file &quot; &amp;gt;&amp;amp;3
echo &quot;Then this should be back on the monitor&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;exec&lt;/code&gt;创建文件描述符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exec 3&amp;gt;&amp;gt;test13out&lt;/code&gt; 追加文件&lt;/p&gt;

&lt;h3&gt;14.4.2 重定向文件描述符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;exec3&amp;gt;&amp;amp;1  将3重定向到1,类似于保存1到3
exec 1&amp;gt;test14out
echo &quot;This should store in the output file&quot;
echo &quot;along with this line.&quot;

exec 1&amp;gt;&amp;amp;3  从3恢复
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么有的时候有&lt;code&gt;&amp;amp;&lt;/code&gt;, 有的时候没有&lt;/p&gt;

&lt;h3&gt;14.4.3 创建输入文件描述符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;exec 6&amp;lt;&amp;amp;0

exec0&amp;lt;testfile

count=1
while read line
do
  echo &quot;Line #$count: $line&quot;
  count=$[ $count + 1 ]
done
exec 0&amp;lt;&amp;amp;6
read -p &quot;Are you done now?&quot; answer
echo $answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;14.4.4 创建读写文件描述符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;exec 3&amp;lt;&amp;gt; testfile
read line &amp;lt;&amp;amp;3
echo &quot;Read: $line&quot;
echo &quot;This is a test line&quot; &amp;gt;&amp;amp;3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;维护一个当前位置指针,写的时候会覆盖&lt;/p&gt;

&lt;h3&gt;14.4.5 关闭文件描述符&lt;/h3&gt;

&lt;p&gt;重定向到特殊符号&lt;code&gt;&amp;amp;-&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exec 3&amp;gt;&amp;amp;-&lt;/code&gt;  关闭文件描述符3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec 3&amp;gt; test17file
echo &quot;this is a test line of data&quot; &amp;gt;&amp;amp;3

exec 3&amp;gt;&amp;amp;-
echo &quot;this won't work&quot; &amp;gt;&amp;amp;3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果重新将3定向到test17file,那么文件被覆盖&lt;/p&gt;

&lt;h2&gt;14.5 列出打开的文件描述符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 显示当前linux系统上打开的每个文件的有关信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/sbin/lsof&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 指定PID&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 指定显示的文件描述符的个数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$&lt;/code&gt; 当前进程的PID&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;选项对两个选项结果执行AND运算&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/sbin/lsof -a -p $$ -d 0.1.2

exec 3&amp;gt; test18file1
exec 6&amp;gt; test18file2
exec 7&amp;lt;testfile

lsof -a -p $$ -d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;14.6 阻止命令输出&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以输入重定向,也可以输出重定向&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/dev/null &amp;gt; testfile&lt;/code&gt; 删除testfile中的数据&lt;/p&gt;

&lt;h2&gt;14.7 创建临时文件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/tmp&lt;/code&gt; 在启动时自动删除其中所有文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mketmp&lt;/code&gt; 在/tmp中创建一个唯一的临时文件, 不用默认的umask值,把文件的读写权分配给属主,其他人没法访问它&lt;/p&gt;

&lt;h3&gt;14.7.1 创建本地临时文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mktemp testing.XXXXXX&lt;/code&gt;  6个X&lt;/p&gt;

&lt;p&gt;返回创建的文件名&lt;/p&gt;

&lt;p&gt;要在脚本中使用,保存输出的文件名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tempfile=`mktemp test19.XXXXXX`

exec 3&amp;gt;&amp;amp;tempfile

echo &quot;This script writes to temp file $tempfile&quot;

echo &quot;This is the first ling&quot; &amp;gt;&amp;amp;3
echo &quot;This is the second line&quot; &amp;gt;&amp;amp;3
echo &quot;This is the third line&quot; &amp;gt;&amp;amp;3
exec 3&amp;gt;&amp;amp;-

echo &quot;Done creating temp file. The contents are&quot;

cat $tempfile

rm-f $tempfile 2&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;14.7.2 在/tmp目录创建临时文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; 选项会强制&lt;code&gt;mktemp&lt;/code&gt;在系统的临时目录来创建文件,并且返回全路径名&lt;/p&gt;

&lt;h3&gt;14.7.3 创建临时目录&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;选项告诉&lt;code&gt;mktemp&lt;/code&gt;来创建一个临时目录而不是临时文件,可以对目录进行操作&lt;/p&gt;

&lt;h2&gt;14.8 记录消息&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tee&lt;/code&gt; 相当于管道的一个T型接头, 将从STDIN过来的数据同时发送给两个目的地,一个是STDOUT,一个是&lt;code&gt;tee&lt;/code&gt;命令行指定的文件名:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tee filename&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为数据是从STDIN来的,因此可以用管道,重定向等&lt;/p&gt;

&lt;p&gt;默认情况下是覆盖的,使用&lt;code&gt;-a&lt;/code&gt;选项来进行追加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tempfile=test22file

echo &quot;This is the start of the test&quot; | tee $tempfile
echo &quot;This is the second line of the test&quot; | tee -a $tempfile
echo &quot;This is the third line of the test&quot; | tee -a $tempfile
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/26/chapter14-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/26/chapter14-lclss</guid>
                <pubDate>2013-01-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>处理用户输入 chapte13 LCLSS</title>
                <description>&lt;h1&gt;第13章 处理用户输入&lt;/h1&gt;

&lt;h2&gt;13.1 命令行参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./addem 10 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向脚本addem传递了两个参数10和30&lt;/p&gt;

&lt;h3&gt;13.1.1 读取参数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;位置参数(positional parameter)&lt;/code&gt; 分配给命令行输入的所有参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$0&lt;/code&gt;是程序名,&lt;code&gt;$1&lt;/code&gt;是第一个参数,&lt;code&gt;$2&lt;/code&gt;是第二个参数,...,&lt;code&gt;$9&lt;/code&gt;是第九个参数 (最多只有9个参数吗?)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;factorial=1
for(( number = 1; number &amp;lt;= $1; number++)
do
  factorial=$$[ $factorial *  $number ]
done
echo The factorial of $1 is $factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多个命令行参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total=$[ $1 * $2 ]
echo the first parameter is $1
echo the second parameter is $2
echo the total value is $total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数当然也可以是&lt;strong&gt;字符串&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参数使用空格分隔的,当一个参数中包含空格时,参数要用引号包含&lt;/p&gt;

&lt;p&gt;当参数多于9个的时候还是可以应用,但是方式要简单转换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${11}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;13.1.2 读取程序名&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$0&lt;/code&gt;参数来获取程序的名字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo The command entered is: $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./test    调用的结果是./test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/rich/test 调用的结果是/home/rich/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;basename&lt;/code&gt;命令,只返回程序名而不包括路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name=`basename $0`
echo the command entered is: $name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样返回的就是test了&lt;/p&gt;

&lt;h3&gt;13.1.3 测试参数&lt;/h3&gt;

&lt;p&gt;使用数据之前有必要测试数据是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ -n $1 ]
then
    echo Hello $1, glad to meet you
else
    echo &quot;Sorry, you did not identify yourself.&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;13.2 特殊参数变量&lt;/h2&gt;

&lt;h3&gt;13.2.1 参数计数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$#&lt;/code&gt; 特殊变量含有脚本运行时就有的命令行参数个数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ $# -ne 2 ]
then
   echo Usage: test9 a b
else
    total=$[ $1 + $2 ]
    echo the total is $total
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取命令行最后一个参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${!#}   注意$#不能使用,换成!#才能正常工作
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;13.2.2 抓取所有的数据&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$*&lt;/code&gt;和&lt;code&gt;$@&lt;/code&gt;抓取命令行上所有参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$*&lt;/code&gt; 将所有参数存储为&lt;em&gt;一个&lt;/em&gt;字符串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$@&lt;/code&gt; 将所有参数存为一张表,参数之间相互分离&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count=1
for param in &quot;$*&quot;
do
   echo &quot;\$* Parameter #$count = $param&quot; 这里只执行一次
   count=$[ $count + 1 ]
done

count=1
for param in &quot;$@&quot;
do 
    echo &quot;\$@ Parameter #$count = $param&quot; 执行$#次
    count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;13.3 移动变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;shift&lt;/code&gt; 命令会根据它们的相对位置来移动命令行参数&lt;/p&gt;

&lt;p&gt;默认情况下将每个参数变量减一,$3会变成$2,$2会变成$1,$1被删除,$0还是命令的名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count=1
while [ -n &quot;$1&quot; ]
do
    echo &quot;Parameter #$count = $1&quot;
    count=$[ $count + 1 ]
    shift
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shift n&lt;/code&gt; 来移动n位&lt;/p&gt;

&lt;h2&gt;13.4 处理选项&lt;/h2&gt;

&lt;h3&gt;13.4.1 查找选项&lt;/h3&gt;

&lt;h4&gt;1. 处理简单的选项&lt;/h4&gt;

&lt;p&gt;可以像处理参数一样用&lt;code&gt;shift&lt;/code&gt;来处理选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;Found the -a option&quot; ;;
    -b) echo &quot;Found the -b option&quot; ;;
    -c) echo &quot;Fount the -c option&quot; ;;
    *) echo &quot;$1 is not an option&quot; ;;
    esac
    shift
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 分离参数和选项&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;--&lt;/code&gt;来表明选项结束,参数开始&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;Found the -a option&quot; ;;
    -b) echo &quot;Found the -b option&quot; ;;
    -c) echo &quot;Found the -c option&quot; ;;
    --) shift
        break ;;
    *) echo &quot;$1 is not an option&quot; ;;
    esac
    shift
done

count=1
for param in $@
do
    echo &quot;Parameter #$count: $param&quot;
    count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 处理带值的选项&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;./test -a test1 -b -c -d test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些选项会带上一个额外的参数值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;Found the -a option&quot;;;
    -b) param=&quot;$2&quot;
        echo &quot;Found the -b option, with parameter value $param&quot;
        shift 2;;
    -c) echo &quot;Found the -c option&quot;;;
    *) echo &quot;$1 is not an option&quot;;;
    esac
    shift
done

count=1
for param in &quot;$@&quot;
do
    echo &quot;Parameter #$count: $param&quot;
    count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是不能处理多个选项合并在一起的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./test -ac
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;13.4.2 使用getopt命令&lt;/h3&gt;

&lt;p&gt;识别命令行参数&lt;/p&gt;

&lt;h4&gt;1. 命令的格式&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;getopt options optstring parameters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;optstring 定义了命令行有效的选项字母, 还定义了哪些选项字母需要参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getopt ab:cd -a -b test1 -cd test2 test3&lt;/code&gt; 冒号表示有参数&lt;/p&gt;

&lt;p&gt;上面的optstring定义了4个有效选项字母, a,b,c,d,b需要一个参数,会将-cd自动分成两个单独的选项,并插入双破折号来分开行中的额外参数.&lt;/p&gt;

&lt;p&gt;如果指定了一个不再optstring中的选项,默认情况下会产生一条错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getopt ab:cd -a -b test1 -cde test2 test3
getopt: invalid option --e
-a -b test1 -c -d -- test2 test3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令后面加&lt;code&gt;-q&lt;/code&gt;忽略这条信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getopt -q ab:cd -a -b test1 -cde test2 test3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 在脚本中使用getopt&lt;/h4&gt;

&lt;p&gt;使用getopt生成格式化输入给脚本的命令行选项,替换已有的命令行选项和参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set&lt;/code&gt;命令的选项之一'--', 会将命令行参数替换成set命令的命令行的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -- `getopts -q ab:cd &quot;$@&quot;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原始的命令行参数变量的值会被getopt命令的输出替换,而getopt已经格式化了命令行参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -- `getopt -q ab:c &quot;$@&quot;`
while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;Found the -a option&quot;;;
    -b) param=&quot;$2&quot;
        echo &quot;Found the -b option, with parameter value $param&quot;;;
    -c) echo &quot;Found the -c option&quot;;;
    --) shift
        break;;
    *) echo &quot;$1 is not an option&quot;
    esac
    shift
done

count=1
for param in &quot;$@&quot;
do
    echo &quot;Parameter #$count: $param&quot;
    count=$[ $count + 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getopt不擅长处理带空格的参数值,它会将空格当成参数的分隔符,而不是根据双引号将二者当成一个参数.&lt;/p&gt;

&lt;h3&gt;13.4.2 使用更高级的getopts&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;getopts optstring variable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;optstring 和getopt中的optstring类似. 要去掉错误消息,在optstring之前加一个冒号., getopts会将当前参数保存在命令行中定义的&lt;code&gt;variable&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;getopts命令会用到两个环境变量,如果选项需要一个参数值,&lt;code&gt;OPTARG&lt;/code&gt;环境变量会保存这个值, &lt;code&gt;OPTIND&lt;/code&gt;环境变量保存了参数列表中getopts正在处理的参数位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while getopts :ab:c opt #最前面的:是忽略错误消息,当前选项在opt中
do
    case &quot;$opt&quot; in
    a) echo &quot;Found the -a option&quot;;;
    b) echo &quot;Found the -b option, with value $OPTARG&quot;;;
    c) echo &quot;Found the -c option&quot;;;
    *) echo &quot;Unknown option: $opt&quot;;;
    esac
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getopts会返回状态码&lt;/p&gt;

&lt;p&gt;getopts会移除选项开头的&lt;code&gt;-&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;getopts可以处理带空格的命令参数&lt;/p&gt;

&lt;p&gt;getopts将命令行上未定义的选项同一输出成问号&lt;/p&gt;

&lt;p&gt;在处理完选项后可以使用OPTIND和shift来移去已经处理过的选项&lt;/p&gt;

&lt;h2&gt;13.5 将选项标准化&lt;/h2&gt;

&lt;p&gt;当然可以自定义所有选项,但是有些字母选项已然约定俗成,遵守这样的规则可以更友好&lt;/p&gt;

&lt;h2&gt;13.6 获得用户的输入&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;read&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;13.6.1 基本的读取&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;read&lt;/code&gt;命令接受从标准输入或另一个文件描述符的输入,在收到输入后,read命令会将数据放进一个标准变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo -n &quot;Enter your name&quot;
read name #读入的值存在name中
echo &quot;Hello $name, welcome to my program.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;echo -n&lt;/code&gt;移除了末尾的换行符,是的输出末尾不换行.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;read -p &quot;Please enter your age: &quot; age # 直接指定了提示符&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;`read -p &quot;Please enter your age: &quot; first last #可以指定多个变量,如果输入的值多余变量值,那么多多的值会被分配到最后一个变量中.&lt;/p&gt;

&lt;p&gt;如果不指定任何变量,那么得到的数据将被存储在&lt;strong&gt;REPLY&lt;/strong&gt;环境变量中&lt;/p&gt;

&lt;h3&gt;13.6.2 超时&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;选项指定read命令等待输入的秒数,当计时器过期后,read命令会返回一个非零状态退出码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if read -t 5 -p &quot;Please enter your name: &quot; name
then
    echo &quot;Hello $name, welcome to my script&quot;
else
    echo
    echo &quot;Sorry. too slow!&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以让read命令来对输入的字符进行计数,而非对输入过程进行计时,当输入的字符达到预设的字符数时,它会自动退出,将输入的数据赋给变量.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read -n1 -p &quot;Do you want to continue[Y/N]? &quot; answer
case $answer in
Y | y) echo
       echo &quot;fine. continue on...&quot;;;
N | n) echo
       echo OK.goodbye
       exit;;   
esac
echo &quot;This is the end of the script&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n1表示输入一个字符read就结束&lt;/p&gt;

&lt;h3&gt;13.6.3 隐藏方式读取&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-s&lt;/code&gt;选项阻止将read命令的数据显示在显示器上(实际上,数据会被显示,read将文本颜色设成跟背景颜色一样)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read -s -p &quot;Enter your password: &quot; pass
echo
echo &quot;Is your password really $pass? &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;13.6.4 从文件中读取&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;cat&lt;/code&gt;命令将文件传给&lt;code&gt;read&lt;/code&gt;命令,&lt;code&gt;read&lt;/code&gt;每次读一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count=1
cat test | while read line
do
    echo &quot;Line $count: $line&quot;
    count=$[ $count + 1 ]
done
echo &quot;Finished processing the file&quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/21/chapter13-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/21/chapter13-lclss</guid>
                <pubDate>2013-01-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>设计与实现</title>
                <description>&lt;h1&gt;第3章 设计与实现&lt;/h1&gt;

&lt;p&gt;Brooks认为数据结构设计是程序构造过程的中心环节,一旦数据结构安排好了, 算法就像瓜熟蒂落,编码也比较容易&lt;/p&gt;

&lt;p&gt;程序的设计当然可以通过语言来修饰,但是通常不会为语言所左右&lt;/p&gt;

&lt;h2&gt;3.1 马尔科夫链算法&lt;/h2&gt;

&lt;h2&gt;3.2 数据结构的选择&lt;/h2&gt;

&lt;h2&gt;3.3 在C中构造数据结构&lt;/h2&gt;

&lt;p&gt;memmove删除数组中间元素(应该是个类似覆盖的操作,比自己循环快)&lt;/p&gt;

&lt;h2&gt;3.4 生成输出&lt;/h2&gt;

&lt;p&gt;总应该设法处理数据中各种可能的非正常情况,意外情况和特殊情况.编出正确代码很不容易,因此应该尽量使控制流程简单和规范&lt;/p&gt;

&lt;p&gt;代码确实写得不错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void generate(int nwords)
{
    State *sp;
    Suffix *suf;
    char *prefix[NPREF], *w;
    int i, nmatch;

    for(i = 0; i &amp;lt; NPREF; i++)
        prefix[i] = NONWORD;

    for(i = 0; i &amp;lt; nwords; i++)
    {
        sp = lookup(prefix, 0);
        nmatch = 0;
        for(suf = sp-&amp;gt;suf; suf != NULL; suf = suf-&amp;gt;next)
            if(rand()% ++nmatch == 0)
                w = suf-&amp;gt;word;
        if(strcmp(w, NONWORD) == 0)
            break;
        printf(&quot;%s\n&quot;, w);
        memmove(prefix, prefix+1), (NPREF-1)*sizeof(prexif[0]);
        prefix[NPREF-1] = w;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将字符串存入一个散列表，用字符串在散列中的位置作为字符串的Key进行比较，可以比直接将字符串进行比较要快，并且节省空间。&lt;/p&gt;

&lt;h2&gt;3.5 Java&lt;/h2&gt;

&lt;h2&gt;3.6 c++&lt;/h2&gt;

&lt;h2&gt;3.7 Awk和Perl&lt;/h2&gt;

&lt;p&gt;awk中的关联数组的键支持字符串,数或者字符串和数由逗号分隔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;statetab[w1,w2,++nsuffix[w1,w2]] = $i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;练习3-7 这样的修改比较困难,尤其是对语言细节不够了解的时候&lt;/p&gt;

&lt;h2&gt;3.8 性能&lt;/h2&gt;

&lt;h2&gt;3.9 经验教训&lt;/h2&gt;

&lt;p&gt;马尔科夫程序,文献分析&lt;/p&gt;

&lt;p&gt;一个程序的设计根源与它的数据的形式, 数据结构并没有定义所有的细节,但是他们确实规定了整个解的基本结构&lt;/p&gt;

&lt;p&gt;选择简单算法和数据结构的重要性,应该选择那些能在合理时间内解决具有预期规模的问题的最简单的东西,如果有库,那么就调用库&lt;/p&gt;

&lt;p&gt;最好是从数据结构开始,在关于可以使用哪些算法的知识的指导下进行详细设计,当数据结构安置好后,代码就比较容易组织&lt;/p&gt;

&lt;p&gt;要想先把一个程序完全设计好,然后再构造它,是非常困难的.构造现实的程序总需要&lt;strong&gt;重复&lt;/strong&gt;和&lt;strong&gt;试验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;做产品代码要花费的精力比做原型多得多,产品质量要求我们付出的努力要比个人使用的程序高一两个数量级&lt;/p&gt;

&lt;p&gt;练习3-8 通过不同的语言来实现马尔科夫程序,可以看到其特殊的挑战性和优越性&lt;/p&gt;

&lt;p&gt;编写马尔科夫程序时发现,命名非常重要,尤其是在程序较长的时候,相对于高级语言C实在是太难写了,查错要非常谨慎,总而言之,程序欠写的多得多&lt;/p&gt;

&lt;p&gt;Java由于数据结构已经实现的较好,直接使用语言本身的数据结构来的方便的多,思路也要简单很多,而c数据结构都要自己实现,使得注意力不能完全集中在问题本身,各种细节要考虑,命名太烂的话连名字都记不清楚了,还有结构体,没有补全到后来都不知道一个结构里面有那些要素,使得整体结构非常的混乱,程序在50行以上基本上搞不清楚哪个是哪个了,长期不写导致对语言细节也不甚了解,总之写的很慢就是了.现在最大的问题是代码写的实在是太少太少了,要抓紧时间写代码&lt;/p&gt;

&lt;p&gt;Markov是一个不错的训练,考察的点蛮多的&lt;/p&gt;
</description>
                <link>http://username.github.com/TPOP/2013/01/18/design-and-implementation</link>
                <guid>http://username.github.com/TPOP/2013/01/18/design-and-implementation</guid>
                <pubDate>2013-01-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>风格</title>
                <description>&lt;h1&gt;第1章 风格&lt;/h1&gt;

&lt;p&gt;程序不仅需要给计算机读， 也要给程序员读。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直截了当的逻辑&lt;/li&gt;
&lt;li&gt;自然地表达方式&lt;/li&gt;
&lt;li&gt;通行的语言使用方式&lt;/li&gt;
&lt;li&gt;有意义的名字&lt;/li&gt;
&lt;li&gt;有帮助作用的注释&lt;/li&gt;
&lt;li&gt;避免耍小聪明的花招&lt;/li&gt;
&lt;li&gt;不使用非正规的结构&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1.1 名字&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;非形式的&lt;/li&gt;
&lt;li&gt;简练的&lt;/li&gt;
&lt;li&gt;容易记忆&lt;/li&gt;
&lt;li&gt;能够拼读&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;作用域越大名字携带的信息就应该越多&lt;/p&gt;

&lt;p&gt;&lt;em&gt;全局变量使用具有说明性的名字,局部变量用短名字&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;全局变量最好有个简短注释（全局函数，类，结构也都应该有说明性的名字）&lt;/p&gt;

&lt;p&gt;并不是所有地方都需要使用长的变量名，清晰性经常是随着简洁而来的&lt;/p&gt;

&lt;p&gt;保持&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相关的东西应该给以相关的名字&lt;/p&gt;

&lt;p&gt;boolean型返回函数名字要标明返回的意义&lt;/p&gt;

&lt;p&gt;要&lt;strong&gt;准确&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;名字不仅是个标记，还携带给读程序人的信息&lt;/p&gt;

&lt;h2&gt;1.2 表达式和语句&lt;/h2&gt;

&lt;p&gt;用&lt;strong&gt;缩进&lt;/strong&gt;显示程序的结构，采用一致的缩进风格&lt;/p&gt;

&lt;p&gt;使用表达式的&lt;strong&gt;自然形式&lt;/strong&gt;，表达式应该能大声念出来。 否定运算要谨慎使用&lt;/p&gt;

&lt;p&gt;用加&lt;strong&gt;括号&lt;/strong&gt;的方式排除二义性&lt;/p&gt;

&lt;p&gt;利用优先级比较复杂，还会有陷阱，还是多加括号&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分解&lt;/strong&gt;复杂的表达式，不要再一个表达式里面包含很多意思，即使这样写回较短&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要清晰&lt;/strong&gt;,目标是写出最清晰的代码,而不是最巧妙的代码.&lt;/p&gt;

&lt;p&gt;谨慎的使用&lt;code&gt;?:&lt;/code&gt;运算符, 适用于短的表达式&lt;/p&gt;

&lt;p&gt;当心&lt;strong&gt;副作用&lt;/strong&gt;, ++这类运算,还有I/O也有这种问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?  scanf(&quot;%d %d&quot;, &amp;amp;yr, &amp;amp;profit[yr]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为是函数调用,传入函数的值是调用函数一瞬间的值,&amp;amp;profit[yr]不会因为读入yr而改变&lt;/p&gt;

&lt;h2&gt;1.3 一致性和习惯用法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;使用一致的缩排和加括号风格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;特定的风格远没有一致地使用它们重要&lt;/p&gt;

&lt;p&gt;在修改别人的程序时要保留原来的风格&lt;/p&gt;

&lt;p&gt;为了一致性,使用&lt;strong&gt;习惯用法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;绝对不要使用函数gets&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;? char *p, buf[256];
? gets(buf);
? p = malloc(strlen(buf));   //strlen不计最后的'/0'
? strcpy(p, buf);            //strcpy计最后的'/0'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际程序中,调用malloc,realloc,strdup等牵涉到内存分配的函数,都要对返回值进行检测.&lt;/p&gt;

&lt;p&gt;else-if表达多路选择&lt;/p&gt;

&lt;p&gt;else垂直对齐,一系列嵌套的if通常是一段粗劣笨拙的代码&lt;/p&gt;

&lt;p&gt;一个判断应该尽可能接近它所对应的动作&lt;/p&gt;

&lt;h2&gt;1.4 函数宏&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;避免函数宏&lt;/strong&gt;, 现在已经没有意义了&lt;/p&gt;

&lt;p&gt;一个参数被多次调用,这个参数有可能被多次求值, 若参数带有副作用,会产生难以捉摸的错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;给宏的体和参数都加上括号&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1.5 神秘的数&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;给神秘的数起个名字&lt;/li&gt;
&lt;li&gt;把数定义为常数而不是定义为宏, C++中用const,Java中时final,C也有const但是不能用来做为数组边界,因此要使用enum&lt;/li&gt;
&lt;li&gt;使用字符常量而不是用整数,最好直接使用库函数,类似的还有0,用null来表示空指针,'\0'表示字符串结尾&lt;/li&gt;
&lt;li&gt;利用语言去计算对象的大小,不要直接用数字来表示类型的大小,sizeof(array[0])比sizeof(int)来的好,即使改变了数组类型也没什么关系&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;1.6 注释&lt;/h2&gt;

&lt;p&gt;简洁地点明程序的突出特性,或提供一种概观,帮助别人理解程序&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要大谈明显的东西&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注释应该提供那些不能一下子从代码中看到的东西,或者把那些散布在许多代码里的信息收集到一起.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;给函数和全局数据加注释&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要注释差的代码,重写它&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应该注释所有不同寻常的或者可能迷惑人的内容,但是如果注释长度超过代码本身,可能说明代码应该修改了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要与代码矛盾&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;澄清情况,不要添乱&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应该在需要的地方进行注释,注释不容易通过代码本身直接看到的意义.&lt;/p&gt;

&lt;h2&gt;1.7 为何对此费心&lt;/h2&gt;

&lt;p&gt;好的代码更容易阅读和理解,几乎可以保证其中错误更少&lt;/p&gt;

&lt;p&gt;仔细推敲代码会更短小&lt;/p&gt;

&lt;p&gt;养成写好风格代码的习惯.&lt;/p&gt;
</description>
                <link>http://username.github.com/TPOP/2013/01/17/style</link>
                <guid>http://username.github.com/TPOP/2013/01/17/style</guid>
                <pubDate>2013-01-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>算法与数据结构</title>
                <description>&lt;h1&gt;第2章 算法与数据结构&lt;/h1&gt;

&lt;p&gt;算法和数据结构的研究是计算机科学的重要基石.&lt;/p&gt;

&lt;p&gt;如果你正要进入一个新领域去开发程序,那么首先需要弄清楚在这里已经有了什么,以免无谓的把时间浪费在别人早已做好的东西上&lt;/p&gt;

&lt;h2&gt;2.1 检索&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;二分检索&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以看到这种标准算法的写法几乎都是一致的,这使得阅读优秀的代码变得尤为重要.&lt;/p&gt;

&lt;h2&gt;2.2 排序&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有些算法的行为对输入数据有很强的依赖性。如果遇到反常的、不好的输入数据，一个平常工作得很好的算法就可能运行极长时间，或者耗费极多存储。&lt;/p&gt;

&lt;h2&gt;2.3 库&lt;/h2&gt;

&lt;p&gt;用库的好处在于库正确性比较高,多年的历史证明,程序员能把二分检索程序写正确也是很不容易的.&lt;/p&gt;

&lt;p&gt;循环实现快排,貌似非常复杂啊.有一种快排不是从上到下,而是从下到上的,这种快排本身就是用循环实现的.&lt;/p&gt;

&lt;h2&gt;2.4 一个Java的快速排序&lt;/h2&gt;

&lt;h2&gt;2.5 大O记法&lt;/h2&gt;

&lt;h2&gt;2.6 可增长数组&lt;/h2&gt;

&lt;h2&gt;2.7 表&lt;/h2&gt;

&lt;p&gt;函数的指针倒是可以实现函数式编程,但是略麻烦了&lt;/p&gt;

&lt;h2&gt;2.8 树&lt;/h2&gt;

&lt;h2&gt;2.9 散列表&lt;/h2&gt;
</description>
                <link>http://username.github.com/TPOP/2013/01/17/algorithm-and-data-structure</link>
                <guid>http://username.github.com/TPOP/2013/01/17/algorithm-and-data-structure</guid>
                <pubDate>2013-01-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>更多的结构化命令 chapte12 LCLSS</title>
                <description>&lt;h1&gt;第12章 更多的结构化命令&lt;/h1&gt;

&lt;h2&gt;12.1 for命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;for var in list
do
  commands
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list参数指定了迭代中要用的一系列值,可以通过几种不同的途径来指定列表中的值.&lt;/p&gt;

&lt;p&gt;var包含列表中的当前值,第一个迭代使用列表中的第一个值,第二个迭代用列表中的第二个值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for var in list; do
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;12.1.1 读取列表中的值&lt;/h3&gt;

&lt;p&gt;直接列出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for test in A B C D E F
do
  echo $test
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出循环后test保持最终的值F,并且可以在后面的命令中使用&lt;/p&gt;

&lt;h3&gt;12.1.2 读取列表中复杂的值&lt;/h3&gt;

&lt;p&gt;列表中的值有&lt;code&gt;'&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;会被忽略,要用&lt;code&gt;&quot;&lt;/code&gt;来引用包含&lt;code&gt;'&lt;/code&gt;的部分,或这用&lt;code&gt;\'&lt;/code&gt;转义&lt;/p&gt;

&lt;p&gt;列表中的值是按&lt;strong&gt;空格&lt;/strong&gt;来分的,如果元素本身含有空格,那得到的结果不是我们想要的,用&lt;code&gt;&quot;&lt;/code&gt;或者&lt;code&gt;'&lt;/code&gt;来将整个值包围&lt;/p&gt;

&lt;h3&gt;12.1.3 从变量读取列表&lt;/h3&gt;

&lt;p&gt;可以将一系列值都存储在一个变量中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list=&quot;A B C D E F G&quot;
list=$list&quot; H&quot;   拼接字符串的常用方法
for test in $list
do
  echo $test
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;12.1.4 从命令读取&lt;/h3&gt;

&lt;p&gt;还记得&lt;code&gt;`&lt;/code&gt;可以用来引用任何命令输出的结果吗,这个结果也可以用在循环列表中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for state in `cat $file`
do
  echo &quot;Visit beautiful $state&quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出file变量中存储的文件中的内容,貌似是按单词分的而不是按行分的&lt;/p&gt;

&lt;h3&gt;12.1.3 更改字段分隔符&lt;/h3&gt;

&lt;p&gt;环境变量IFS, &lt;strong&gt;内部字段分割符(internal field separator)&lt;/strong&gt;, IFS定义了bash shell用作字段分隔符的一系列字符&lt;/p&gt;

&lt;p&gt;默认情况下使用&lt;strong&gt;空格&lt;/strong&gt;,&lt;strong&gt;制表符&lt;/strong&gt;,&lt;strong&gt;换行符&lt;/strong&gt; 作为分割符&lt;/p&gt;

&lt;p&gt;可以在shell脚本中临时换一下IFS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IFS=$'\n'  不是直接 IFS='\n'这个不太搞得懂
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般可以先保存原来的IFS,用完后再赋值回来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IFS.OLD=$IFS
IFS=$'\n'
&amp;lt;use the new IFS value in code&amp;gt;
IFS=$IFS.OLD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IFS=:&lt;/code&gt;将IFS设定为&lt;code&gt;:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IFS=$'\n:;'&quot;&lt;/code&gt; 将换行符,冒号,分号,双引号设定为分隔符 仔细看看&lt;/p&gt;

&lt;h3&gt;12.1.16 用通配符读取目录&lt;/h3&gt;

&lt;p&gt;可以用for命令来自动遍历满是文件的目录,可以在文件名或路径名中使用通配符.它会强制shell使用文件扩展匹配(file globbing), 文件扩展匹配是生成匹配指定的通配符的文件名或路径名的过程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for file in /home/dexctor/*
do
   if [ -d &quot;$file&quot; ]   这里要用双引号是因为$file可能有空格
   then
     echo &quot;$file is a directory&quot;
   elif [ -f &quot;$file&quot; ]
   then
     echo &quot;$file is a file&quot;
   fi
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以将目录查找方法和列表方法合并进同一个for语句中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for file in /home/rich/.b* /home/rich/badtest
....
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;12.2 C语言风格的for命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;for (( a = 1; a &amp;lt; 10; a++))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;给变量赋值可以用空格&lt;/li&gt;
&lt;li&gt;条件中的变量不以&lt;code&gt;$&lt;/code&gt;开头&lt;/li&gt;
&lt;li&gt;&lt;p&gt;算式不必用expr命令格式&lt;/p&gt;

&lt;p&gt;  for (( i = 1; i &amp;lt;= 10; i++))
  do
    echo &quot;The next number is $i&quot;
  done
  ehco &quot;$i&quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;i最后为11&lt;/p&gt;

&lt;h3&gt;12.2.2 使用多个变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;for(( a = 1, b = 10; a &amp;lt;= 10; a++, b--))
do
  echo &quot;$a - $b&quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;12.3 while命令&lt;/h2&gt;

&lt;h3&gt;12.3.1 while的基本格式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;while test command
do
  other command
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while中定义的test命令和if-then定义的格式是一样的,和if-then语句中一样,你可以使用任何普通的bash shell命令,或者用test命令作为条件,比如变量值&lt;/p&gt;

&lt;p&gt;while命令的关键是,指定的test命令的退出状态码必须随着循环中运行的命令改变,如果退出状态码不变,那while循环将会一直不停地循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var1=10
while [ $var1 -gt 0 ]
do
  echo $var1
  var1=$[ $var1 - 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;12.3.2 使用多个测试命令&lt;/h3&gt;

&lt;p&gt;while命令允许在while语句行定义多个测试命令,只有最后一个测试命令的状态码会被用来决定什么时候结束循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var1=10
while echo $var1
      [ $var1 -ge 0 ]
do
    echo &quot;this is in the loop&quot;
    $var1=$[ $var1 - 1 ]
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个测试都在单独的一行上&lt;/p&gt;

&lt;h2&gt;12.4 until命令&lt;/h2&gt;

&lt;p&gt;until和while工作方式相反,until命令要求指定一个通常输出非零退出状态的测试命令,只有测试命令的退出状态码非零,bash shell才会指定循环中列出的那些命令,一旦测试命令返回退出状态码为0, 循环就结束了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until test commands
do
   other commands
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;until亦可以有多个测试命令,由最后一个命令的退出状态码决定&lt;/p&gt;

&lt;h2&gt;12.5 嵌套循环&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;嵌套循环(nested loop)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(( a = 1; a &amp;lt;= 3; ++a))
do
  echo &quot;Starting loop $a:&quot;
  for(( b = 1; b &amp;lt;=3; ++b))
  do
    echo &quot;   Inside loop: $b&quot;
  done
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;12.6 循环处理文件数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用嵌套循环&lt;/li&gt;
&lt;li&gt;修改IFS环境变量&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如处理/etc/passwd文件中的数据,先用&lt;code&gt;'\n'&lt;/code&gt;来划分,再用&lt;code&gt;':'&lt;/code&gt;来划分,可以得到每一项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IFS.OLD=$IFS
IFS=$'\n'
for entry in `cat /etc/passwd`
do
  echo &quot;Values in $entry -&quot;
  IFS=:
  for value in $entry
  do
    echo &quot;  $value&quot;
  done
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;12.7 循环控制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;break命令&lt;/li&gt;
&lt;li&gt;continue命令&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;12.7.1 break命令&lt;/h3&gt;

&lt;h4&gt;1. 跳出单个循环&lt;/h4&gt;

&lt;h4&gt;2. 跳出内部循环&lt;/h4&gt;

&lt;h4&gt;3. 跳出外部循环&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;break n&lt;/code&gt; 跳出n层循环,默认为1&lt;/p&gt;

&lt;h3&gt;12.7.2 continue命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;contine&lt;/code&gt; 也可以使用多层, &lt;code&gt;continue n&lt;/code&gt;定义了要继续的循环层级.&lt;/p&gt;

&lt;h2&gt;12.8 处理循环的输出&lt;/h2&gt;

&lt;p&gt;可以在&lt;code&gt;done&lt;/code&gt;命令之后添加一个处理命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for file in /home/rich*
do
  if [ -d &quot;$file&quot; ]
  then
    ehco &quot;$file is a directory&quot;
  elif
    echo &quot;$file is a file&quot;
  fi
done &amp;gt; output.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shell会将for命令的结果重定向到文件output.txt中.&lt;/p&gt;

&lt;p&gt;还可以管接到另一个命令&lt;/p&gt;

&lt;p&gt;'done | sort'&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2013/01/06/chapter12-lclss</link>
                <guid>http://username.github.com/LCLSS/2013/01/06/chapter12-lclss</guid>
                <pubDate>2013-01-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>pro git</title>
                <description>&lt;h1&gt;第一章&lt;/h1&gt;

&lt;h2&gt;1.1 关于版本控制&lt;/h2&gt;

&lt;h3&gt;1.1.1 本地版本控制系统&lt;/h3&gt;

&lt;h3&gt;1.1.2 集中化的版本控制系统&lt;/h3&gt;

&lt;h3&gt;1.1.3 分布式版本控制系统&lt;/h3&gt;

&lt;p&gt;Distributed Version Control System DVCS&lt;/p&gt;

&lt;h2&gt;1.2 Git 的历史&lt;/h2&gt;

&lt;h2&gt;1.3 Git 基础要点&lt;/h2&gt;

&lt;h3&gt;1.3.1 直接快照,而非比较差异&lt;/h3&gt;

&lt;p&gt;Git只关心文件数据的整体是否发生变化&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/figure/git/p1.4.png&quot; alt=&quot;其他系统&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其他系统在每个版本中记录着各个文件的具体差异&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/figure/git/p1.5.png&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git保存每次更新时的文件快照&lt;/p&gt;

&lt;h3&gt;1.3.2 近乎所有操作都可以本地执行&lt;/h3&gt;

&lt;h3&gt;1.3.3 时刻保持数据完整性&lt;/h3&gt;

&lt;p&gt;在保存到git之前,所有数据都要进行内容的校验和(checksum)计算,并将结果作为数据的唯一标识和索引&lt;/p&gt;

&lt;p&gt;所有保存在Git数据库总的东西都是由哈希值来索引的,而不是靠文件名&lt;/p&gt;

&lt;h3&gt;1.3.4 多数操作仅添加数据&lt;/h3&gt;

&lt;p&gt;因此可靠性比较高,几乎所有操作都可以回退&lt;/p&gt;

&lt;h3&gt;1.3.5 三种状态&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;已递交(committed)&lt;/li&gt;
&lt;li&gt;已修改(modified)&lt;/li&gt;
&lt;li&gt;已暂存(staged)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;根据三种状态有三个工作区域&lt;strong&gt;Git的本地数据目录&lt;/strong&gt;, &lt;strong&gt;工作目录&lt;/strong&gt;, &lt;strong&gt;暂存区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/figure/git/p1.6.png&quot; alt=&quot;状态与目录&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git的基本工作流程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在工作目录总修改某些文件&lt;/li&gt;
&lt;li&gt;对这些修改了的文件作快照,保存到暂存区&lt;/li&gt;
&lt;li&gt;提交更新,将保存在暂存区域的文件快照转存到git目录中&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;1.4 安装Git&lt;/h2&gt;

&lt;h2&gt;1.5 初次运行Git前的配置&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;git config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;变量存放在三个文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/etc/gitconfig文件, 对系统中所有用户都普遍适用 &lt;code&gt;--system&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;~/.gitconfig文件, 用户目录下的配置文件只适用于该用户, &lt;code&gt;--global&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;.git/config文件,对当前项目有效, &lt;code&gt;--local&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;每一个级别的配置都会覆盖上层的相同配置&lt;/p&gt;

&lt;h3&gt;1.5.1 用户信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;name&quot;
git config --global user.email &quot;email@email.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.5.2 文本编辑器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git config --global core.editor emacs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认编辑器设定为emacs&lt;/p&gt;

&lt;h3&gt;1.5.3 差异分析工具&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git config --global merge.tool vimdiff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把默认差异分析工具改为&lt;strong&gt;vimdiff&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;1.5.4 查看配置信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.6 获取帮助&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git help &amp;lt;verb&amp;gt;
git &amp;lt;verb&amp;gt; --help
man git-&amp;lt;verb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/git/2013/01/01/pro-git</link>
                <guid>http://username.github.com/git/2013/01/01/pro-git</guid>
                <pubDate>2013-01-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用结构化命令 chapter11 LCLSS</title>
                <description>&lt;h1&gt;第11章 使用结构化命令&lt;/h1&gt;

&lt;p&gt;结构化命令（structured command）&lt;/p&gt;

&lt;h2&gt;11。1 使用if-then语句&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;if command1
then
   command2
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果command的退出状态码是0，那么运行command2，否则直接跳过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if date
then 
  echo &quot;it worked&quot;
 fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;then&lt;/code&gt;语句块中可以有多条命令&lt;/p&gt;

&lt;p&gt;也可以写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if command1; then
    command2
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;11.2 if-then-else 语句&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;if command1
then
    command2
else
    command3
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;11.3 嵌套if&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;if command1
then
    command2
elif  command3
then
    more commands
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;11.4 test命令&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if-then&lt;/code&gt;不能测试跟命令的退出状态码无关的条件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;test&lt;/code&gt; 命令提供了在&lt;code&gt;if-then&lt;/code&gt; 语句总测试不同条件的途径.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;test condition&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if test condition
then
    commands
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash提供了一种更为方便的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ condition ]   注意左括号右侧和右括号左侧有空格
then
    commands
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;test&lt;/code&gt;命令可以判断3类条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数值比较&lt;/li&gt;
&lt;li&gt;字符串比较&lt;/li&gt;
&lt;li&gt;文件比较&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;11.4.1 数值比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;n1 -eq n2&lt;/li&gt;
&lt;li&gt;n1 -ge n2&lt;/li&gt;
&lt;li&gt;n1 -gt n2&lt;/li&gt;
&lt;li&gt;n1 -le n2&lt;/li&gt;
&lt;li&gt;n1 -lt n2&lt;/li&gt;
&lt;li&gt;n1 -ne n2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;test 无法处理由&lt;code&gt;bc&lt;/code&gt;计算出来的浮点数&lt;/p&gt;

&lt;p&gt;bash中只能使用整数&lt;/p&gt;

&lt;h3&gt;11.4.2 字符串比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;str1 = str2&lt;/li&gt;
&lt;li&gt;str1 != str2&lt;/li&gt;
&lt;li&gt;str1 &amp;lt; str2&lt;/li&gt;
&lt;li&gt;str1 &gt; str2&lt;/li&gt;
&lt;li&gt;-n str1  检查str1的长度是否非0&lt;/li&gt;
&lt;li&gt;-z str1  检查str1的长度是否为0&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;谨慎,这里大于号小于号要转义,否则会被当成重定向&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ baseball &amp;gt; hockey ]
then
    echo wrong
else
    echo right
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会输出wrong,但事实上 baseball 比 hockey小, &lt;code&gt;&amp;gt;&lt;/code&gt;被解释为重定向输出,产生了hockey文件,命令被执行完成了,所以状态码是&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ baseball \&amp;gt; hockey ]
then
    echo wrong
else
    echo right
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;这里的大小写处理方式和sort不同, 这里是大写&amp;lt; 小写, 而sort是小写 &amp;lt; 大写&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;貌似现在一致了啊,都是按照ascii来进行了&lt;/p&gt;

&lt;p&gt;如果用数学比较符号来比较数值,会被当成字符串,数值比较要用文本代码,这里好诡异&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;-n&lt;/code&gt; 和 &lt;code&gt;-z&lt;/code&gt;来确定变量是否有值&lt;/p&gt;

&lt;h3&gt;11.4.3 文件比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-d file 检查file是否存在并是一个目录&lt;/li&gt;
&lt;li&gt;-e file 检查file是否存在&lt;/li&gt;
&lt;li&gt;-f file 检查file是否存在并是一个文件&lt;/li&gt;
&lt;li&gt;-r file 检查file是否存在并可读&lt;/li&gt;
&lt;li&gt;-s file 检查file是否存在并非空&lt;/li&gt;
&lt;li&gt;-w file 检查file是否存在并且可读&lt;/li&gt;
&lt;li&gt;-x file 检查file是否存在并且可执行&lt;/li&gt;
&lt;li&gt;-O file 检查file是否存在并属当前用户所有&lt;/li&gt;
&lt;li&gt;-G file 检查file是否存在并且默认组与当前用户相同&lt;/li&gt;
&lt;li&gt;file1 -nt file2 检查file1是否比file2新&lt;/li&gt;
&lt;li&gt;file1 -ot file2 检查file1是否比file2旧&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在检查 &lt;code&gt;-nt&lt;/code&gt; 和 &lt;code&gt;-ot&lt;/code&gt;之前先确认文件存在&lt;/p&gt;

&lt;h2&gt;11.5 复合条件检测&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[ condition1 ] &amp;amp;&amp;amp; [ condition2 ]&lt;/li&gt;
&lt;li&gt;[ condition1 ] || [ condition2 ]&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;11.6 if-then的高级特性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用于数学表达式的双尖括号&lt;/li&gt;
&lt;li&gt;用于高级字符串处理功能的双方括号&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;11.6.1 使用双尖括号&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;(( expression ))&lt;/code&gt; 允许更高级数学表达式放入比较中&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;双尖括号命令符号&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;不需要将双尖括号的大于号转义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val1=10
if (( $val1 ** 2 &amp;gt; 90 ))
then
    (( val2 = $val1 ** 2 ))
    echo &quot;The square of $val1 is $val2&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;11.6.2 使用双方括号&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;[[ experssion ]]&lt;/code&gt; 提供了针对字符串比较的高级特性&lt;/p&gt;

&lt;p&gt;&lt;code&gt;模式匹配(pattern matching)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [[ $USER == d* ]] 
then
   echo &quot;Hello $USER&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;11.7 case命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;case variable in
pattern1 | pattern2) commands1;;
patter3) command2;;
*) default command;;
esac
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/28/chapter11-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/28/chapter11-lclss</guid>
                <pubDate>2012-12-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>构建基本脚本 chapter10 LCLSS</title>
                <description>&lt;h1&gt;第10章构建基本脚本&lt;/h1&gt;

&lt;h2&gt;10.1 使用多个命令&lt;/h2&gt;

&lt;p&gt;两个命令一起运行,用&lt;code&gt;;&lt;/code&gt;分隔&lt;/p&gt;

&lt;p&gt;但是每行不能超过255个字符&lt;/p&gt;

&lt;h2&gt;10.2 创建shell脚本文件&lt;/h2&gt;

&lt;p&gt;文件第一行指定要使用的shell&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#&lt;/code&gt;用作注释行,shell中的注释行是不被shell执行的,然而第一行是一个特例,&lt;code&gt;#&lt;/code&gt;后的&lt;code&gt;!&lt;/code&gt;告诉shell用哪个shell来运行脚本&lt;/p&gt;

&lt;p&gt;要让shell找到脚本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将shell脚本文件所处的目录添加到PATH环境变量中&lt;/li&gt;
&lt;li&gt;在提示符中用绝对或相对文件路径来引用文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;还有权限问题,&lt;code&gt;chmod&lt;/code&gt;给脚本增加可执行权限&lt;/p&gt;

&lt;h2&gt;10.3 显示消息&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;echo&lt;/code&gt; 命令来显示消息&lt;/p&gt;

&lt;p&gt;一般不用用&lt;code&gt;'&lt;/code&gt;或&lt;code&gt;&quot;&lt;/code&gt;圈起来,但是当字符串中有这个两个符号时,要用另一个把字符串圈起来&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 参数使得下一行命令的输出紧接着字符串结束的地方&lt;/p&gt;

&lt;h2&gt;10.4 使用变量&lt;/h2&gt;

&lt;h3&gt;10.4.1 环境变量&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;set&lt;/code&gt; 显示环境变量(局部和全局的)&lt;/p&gt;

&lt;p&gt;在环境变量名称之前加&lt;code&gt;$&lt;/code&gt;来使用这些环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo UID: $UID

echo &quot;User info for userid: $USER&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;&quot;&lt;/code&gt;内也可以使用,要显示&lt;code&gt;&amp;amp;&lt;/code&gt;符号使用&lt;code&gt;\&lt;/code&gt;转义&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;'&lt;/code&gt;内会照原样输出&lt;/p&gt;

&lt;p&gt;可以通过&lt;code&gt;${变量}&lt;/code&gt;的方式来引用变量&lt;/p&gt;

&lt;h3&gt;10.4.2 用户变量&lt;/h3&gt;

&lt;p&gt;大小写敏感&lt;/p&gt;

&lt;p&gt;值通过等号来赋值给变量,变量,等号,值之间不出现空格.&lt;/p&gt;

&lt;p&gt;在脚本的整个生命周期力,shell脚本中定义的变量会一直保持他们的值,但是shell脚本完成时删除掉&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;$&lt;/code&gt;符号引用变量&lt;/p&gt;

&lt;h3&gt;10.4.3 反应号&lt;/h3&gt;

&lt;p&gt;shell脚本中最有用的就是&lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;反引号允许你将shell命令的输出赋值给变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;testing=`date`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个典型的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;today=`date +%y%m%d`

ls /usr/bin -al &amp;gt; log.$today
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以生成一个跟时间有关的变量名,这都是字符串连接吗&lt;/p&gt;

&lt;h2&gt;10.5 重定向输入和输出&lt;/h2&gt;

&lt;h3&gt;10.5.1 输出重定向&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 符号来完成标准输出的重定向&lt;/p&gt;

&lt;p&gt;&lt;code&gt;command &amp;gt; outputfile&lt;/code&gt; command的输出会重定向到outputfile文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 输出追加到文件,而不是覆盖&lt;/p&gt;

&lt;h3&gt;10.5.2 输入重定向&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 输入重定向&lt;/p&gt;

&lt;p&gt;&lt;code&gt;command &amp;lt; inputfile&lt;/code&gt; inputfile内容流向command命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wc&lt;/code&gt; 对数据文本的计数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行数&lt;/li&gt;
&lt;li&gt;词数&lt;/li&gt;
&lt;li&gt;字节数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;内联重定向,不是从文件而是从命令行得到输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command &amp;lt;&amp;lt; marker
data
marker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;marker&lt;/code&gt;表示输入的开始和结束,可以任意选择,但是必须是一致的&lt;/p&gt;

&lt;h2&gt;10.6 管道&lt;/h2&gt;

&lt;p&gt;将某个命令的输出作为另一个命令的输入,重定向可以搞个中间文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;管道连接(piping)&lt;/code&gt; 会方便的多&lt;/p&gt;

&lt;p&gt;&lt;code&gt;command1 | command2&lt;/code&gt; command1的输出输入到command2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -qa | sort | more
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;10.7 执行数学运算&lt;/h2&gt;

&lt;h3&gt;10.7.1 expr命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;`expr 1 + 5`
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;expr命令操作符&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;但是类似&lt;code&gt;*&lt;/code&gt;等符号在shell中有其他用途,要用&lt;code&gt;\&lt;/code&gt;转义&lt;/p&gt;

&lt;p&gt;将数学算式的结果赋值给一个变量,要用&lt;code&gt;`&lt;/code&gt;来获取expr 命令的输出&lt;/p&gt;

&lt;h3&gt;10.7.2 使用方括号&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$[ operation]&lt;/code&gt; 使用&lt;code&gt;$&lt;/code&gt;和&lt;code&gt;[]&lt;/code&gt;来引用表达式&lt;/p&gt;

&lt;p&gt;而且不用担心&lt;code&gt;*&lt;/code&gt;等的误解&lt;/p&gt;

&lt;p&gt;但是bash shell的数学运算只支持整数运算&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;z shell支持完成的浮点数操作
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;10.7.3 浮点解决方案&lt;/h3&gt;

&lt;p&gt;最常用的方法是使用bash内建计算器&lt;code&gt;bc&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;1. bc的基本用法&lt;/h4&gt;

&lt;p&gt;bc计算器能够识别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数字(整数和浮点数)&lt;/li&gt;
&lt;li&gt;变量(简单变量和数组)&lt;/li&gt;
&lt;li&gt;注释(以井号开头或者&lt;code&gt;/* */&lt;/code&gt; 对)&lt;/li&gt;
&lt;li&gt;表达式&lt;/li&gt;
&lt;li&gt;编程语言(如if-then)&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这就是一门语言&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scale&lt;/code&gt;内建变量,设置浮点数的小数点位数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;print&lt;/code&gt;可以打印&lt;/p&gt;

&lt;h4&gt;2. 在脚本中使用bc&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;variable=`echo &quot;options; expression&quot; | bc`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;|&lt;/code&gt;来传递参数,通过&lt;code&gt;`&lt;/code&gt;来引用输出&lt;/p&gt;

&lt;p&gt;   var1=&lt;code&gt;echo &quot; scale=4; 3.44/5&quot; | bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;;&lt;/code&gt;来分隔输入的语句, 在语句中可以使用shell脚本的变量&lt;/p&gt;

&lt;p&gt;但是有很多语句时,同时列出这么多语句会比较复杂,可以使用重定向,但是要单独写一个表达式的文件&lt;/p&gt;

&lt;p&gt;最方便的是使用&lt;code&gt;内联重定向&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variable=`bc &amp;lt;&amp;lt; EOF

options

statements

expressions

EOF
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要忘了使用&lt;code&gt;`&lt;/code&gt; 来引用命令的结果&lt;/p&gt;

&lt;p&gt;在语句块里面还可以使用变量,但是变量是存在于bc中的,一旦退出,变量不能在shell脚本中使用&lt;/p&gt;

&lt;h2&gt;10.8 退出脚本&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;退出状态码(exit status)&lt;/code&gt;,0-225之间,告诉shell它完成了处理&lt;/p&gt;

&lt;h3&gt;10.8.1 查看退出状态码&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$?&lt;/code&gt; 来查看退出状态码,最后一条命令的退出状态码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo $?&lt;/code&gt; 显示退出状态码&lt;/p&gt;

&lt;h3&gt;10.8.2 exit命令&lt;/h3&gt;

&lt;p&gt;默认情况下脚本会以最后一条命令的退出状态码退出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exit&lt;/code&gt; 来改变退出状态码 &lt;code&gt;exit 5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以在&lt;code&gt;exit&lt;/code&gt;命令参数中使用变量,但是退出码的返回0-255,超过这个范围会取256的模&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/25/chapter10-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/25/chapter10-lclss</guid>
                <pubDate>2012-12-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>安装软件程序 chapter8 LCLSS</title>
                <description>&lt;h1&gt;第8章 安装软件程序&lt;/h1&gt;

&lt;p&gt;包管理系统(Package Management System, PMS)&lt;/p&gt;

&lt;h2&gt;8.1 包管理基础&lt;/h2&gt;

&lt;p&gt;PMS记录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;已安装软件包&lt;/li&gt;
&lt;li&gt;每个包安装了什么文件&lt;/li&gt;
&lt;li&gt;每个已安装软件包的版本&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;软件包存储在服务器上 &lt;strong&gt;库(repository)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;依赖关系,PMS会自动检测依赖关系,并安全额外需要的软件包&lt;/p&gt;

&lt;p&gt;PMS现在还没有标准工具&lt;/p&gt;

&lt;p&gt;现存主要的PMS基础工具是&lt;code&gt;dpkg&lt;/code&gt;和&lt;code&gt;rpm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;基于Debian的发行版, 如Ubuntu和Linux Mint, PMS工具的底层用的是dpkg命令,与PMS交互,安装,管理和删除软件包&lt;/p&gt;

&lt;p&gt;基于Red Hat的发行版, 比如Fedra,openSUSE和Mandriva, PMS工具的底层是rpm命令&lt;/p&gt;

&lt;p&gt;这两个命令是PMS的核心,但不是全部,还会有一些额外的工具,使得管理简单&lt;/p&gt;

&lt;h2&gt;8.2 基于Debian的系统&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dpkg&lt;/code&gt; 是基于Debian系PMS工具的核心&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apt-get&lt;/li&gt;
&lt;li&gt;apt-cache&lt;/li&gt;
&lt;li&gt;aptitude&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;aptitude&lt;/code&gt; 本质上是apt工具和dpkg的前端, dpkg是一个软件包管理系统工具, aptitude则是一个完整的软件包管理系统&lt;/p&gt;

&lt;p&gt;aptitude可以避免一些问题,如软件依赖关系缺失,系统环境不稳定以及其他一些不必要的麻烦&lt;/p&gt;

&lt;h3&gt;8.2.1 用aptitude管理软件包&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aptitude&lt;/code&gt; 来开启交互式程序&lt;/p&gt;

&lt;p&gt;如果知道了系统上的那些软件包,显示特定包的详细信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aptitude show package_name&lt;/code&gt; 显示package_name包的详细信息,并不表示这个包已经安装了,只是显示从软件库中得到的详细的软件包信息&lt;/p&gt;

&lt;p&gt;无法通过aptitude看到的一个细节是所有跟摸个特定软件包关联的所有文件的列表,要得到这个列表需要用&lt;code&gt;dpkg&lt;/code&gt;命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dpke -L package_name&lt;/code&gt; 查找和package_name相关的所有文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dpkg --search absolute_file_name&lt;/code&gt; 可以反向查找某个特定文件属于哪个软件包&lt;/p&gt;

&lt;p&gt;相当犀利啊&lt;/p&gt;

&lt;h3&gt;8.2.2 用aptitude安装软件包&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aptitude search package_name_key_word&lt;/code&gt; 查找特性的软件包&lt;/p&gt;

&lt;p&gt;每个软件包前面有一个标示符&lt;code&gt;i&lt;/code&gt;表示已经安装了,&lt;code&gt;p&lt;/code&gt;表示未安装,&lt;code&gt;v&lt;/code&gt;表示什么呢?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo aptitude install package_name&lt;/code&gt; 安装package&lt;/p&gt;

&lt;p&gt;要确认是否安装,用aptitude search搜索一下,标示符是否为&lt;code&gt;i&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;本地安装
&lt;code&gt;sudo dpkg -i software_name&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;8.2.3 用aptitude更新软件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;aptitude safe-upgrade&lt;/code&gt; 将包所有包更新到最新&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aptitude full-upgrade&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aptitude dist-upgrade&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;将所有软件包升级到到最新,于safe-upgrade的区别是不检查包与包之间的依赖关系.&lt;/p&gt;

&lt;p&gt;刚安装完的系统尤其需要safe-upgrade&lt;/p&gt;

&lt;h3&gt;8.2.4 用aptitude卸载软件&lt;/h3&gt;

&lt;p&gt;只删除软件包但不删除数据和配置文件,可以用aptitude的&lt;code&gt;remove&lt;/code&gt;选项,要删除软件包和相关数据和配置文件,可以用&lt;code&gt;purge&lt;/code&gt;选项&lt;/p&gt;

&lt;p&gt;看软件包是否删除,也可以用&lt;code&gt;aptitude search&lt;/code&gt;选项, 如果软件包前面的标示符是&lt;code&gt;c&lt;/code&gt;,意味着软件删除了,但是配置文件未删除,&lt;code&gt;p&lt;/code&gt;表示配置文件也删除了&lt;/p&gt;

&lt;h3&gt;8.2.5 aptitude库&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/etc/apt/sources.list&lt;/code&gt; 存储着软件库&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://us.archive.ubuntu.com/ubuntu/ maverick main restricted

deb (or deb-src) address distribution_name package_type_list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;deb(or deb-src)&lt;/code&gt; 表明了软件包的类型,deb说明是编译后程序的源,deb-src是源代码源&lt;/p&gt;

&lt;p&gt;&lt;code&gt;address&lt;/code&gt; 是软件库的web地址&lt;/p&gt;

&lt;p&gt;&lt;code&gt;distribution_name&lt;/code&gt; 是特定软件库的发行版版本的名称,如这里是&lt;code&gt;maverick&lt;/code&gt;,但是并不能说明你使用的是Ubuntu Maverick Mint, 只是说明Linux发行版本在用Linux Maverick Meercat软件库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package_type_list&lt;/code&gt; 可能不止一个词,表名库里面有什么类型的包, main restricted universe partner&lt;/p&gt;

&lt;h2&gt;8.3 基于Red Hat 的系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;yum&lt;/li&gt;
&lt;li&gt;urpm&lt;/li&gt;
&lt;li&gt;zypper&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些前端都是基于rpm命令行工具的&lt;/p&gt;

&lt;h3&gt;8.3.1 列出已安装包&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;yum list installed&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rpm -qa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zypper search -I&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum list package&lt;/code&gt; 列出package,不一定已经安装&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum list installed package&lt;/code&gt; 列出package是否安装&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum provides file_name&lt;/code&gt; 查看file_name文件是什么软件的文件&lt;/p&gt;

&lt;h3&gt;8.3.2 用yum安装软件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;yum install package_name&lt;/code&gt; 安装package_name,自动安装依赖关系&lt;/p&gt;

&lt;p&gt;&lt;code&gt;su -&lt;/code&gt; 切换好root用户&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本地安装(local installation)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum local install package_name.rpm&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;8.3.3 用yum更新软件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;yum list updates&lt;/code&gt; 列出所有针对已安装包的可用更新&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum update package_name&lt;/code&gt; 更新package_name软件包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum update&lt;/code&gt; 更新所有软件&lt;/p&gt;

&lt;h3&gt;8.3.4 用yum卸载软件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;yum remove package_name&lt;/code&gt; 删除软件包,但保留配置文件和数据文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum erase package_name&lt;/code&gt; 删除软件和数据&lt;/p&gt;

&lt;h3&gt;8.3.5 处理损坏的包依赖关系&lt;/h3&gt;

&lt;p&gt;在同时安装多个软件包时,某个包的软件以来关系可能会被另一个包的安装覆盖掉,&lt;strong&gt;损坏的包依赖关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum clear all&lt;/code&gt; 先试试这个命令,这命令干什么的?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum update&lt;/code&gt; 在试试更新&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum deplist package_name&lt;/code&gt; 命令显示所有包的依赖关系以及什么软件可以提供这些库依赖关系,一旦知道某个包需要的库后就可以安装他们了&lt;/p&gt;

&lt;p&gt;如果这些都还没解决&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum update --skip-broken&lt;/code&gt; 忽略依赖关系损坏的包,更新其他软件包&lt;/p&gt;

&lt;h3&gt;8.3.6 yum软件库&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;yum repolist&lt;/code&gt; 显示当前使用的软件库,库位于&lt;code&gt;/etc/yum.repos.d&lt;/code&gt;, 需要添加正确的URL并获得必要的加密密匙&lt;/p&gt;

&lt;h2&gt;8.4 从源码安装&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; 解压下载的软件包&lt;/p&gt;

&lt;p&gt;阅读README&lt;/p&gt;

&lt;p&gt;&lt;code&gt;./configure&lt;/code&gt; 根据系统配置软件,如使用正确的编译器, 正确的包以来关系等等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 安装文件,将源码编译成二进制可执行文件,完成后在目录下有可用程序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make install&lt;/code&gt; 安装到Linux的一个常见的位置.&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/23/chapter8-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/23/chapter8-lclss</guid>
                <pubDate>2012-12-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>管理文件系统 chapter7 LCLSS</title>
                <description>&lt;h1&gt;第7章 管理文件系统&lt;/h1&gt;

&lt;h2&gt;7.1 探索Linux文件系统&lt;/h2&gt;

&lt;p&gt;Linux支持多种类型的文件系统来管理文件和目录&lt;/p&gt;

&lt;h3&gt;7.1.1 基本的Linux文件系统&lt;/h3&gt;

&lt;h4&gt;1. ext文件系统&lt;/h4&gt;

&lt;p&gt;扩展文件系统(extended filesystem, ext)&lt;/p&gt;

&lt;p&gt;使用虚拟目录来操作硬件设备,在物理设备上按定长的块来存储数据&lt;/p&gt;

&lt;p&gt;ext文件系统采用&lt;strong&gt;索引节点&lt;/strong&gt;来存放虚拟目录中所存储文件的信息&lt;/p&gt;

&lt;p&gt;索引节点系统在每个物理设备中创建一个单独的表(索引节点表)来存储这些文件的信息.存储在虚拟目录中的每一个文件在索引节点表中都有一个条目.条目名称的扩展部分来自其跟踪每个文件的课外数据,包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文件名&lt;/li&gt;
&lt;li&gt;文件大小&lt;/li&gt;
&lt;li&gt;文件的属主&lt;/li&gt;
&lt;li&gt;文件的属组&lt;/li&gt;
&lt;li&gt;文件的访问权限&lt;/li&gt;
&lt;li&gt;指向存有文件数据的每个硬盘块的指针&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Linux通过唯一的数值(索引节点号)来引用索引节点表中的每个索引节点,这个值在创建时由文件系统分配,文件系统通过索引节点号而不是文件全名及路径来标识文件&lt;/p&gt;

&lt;h4&gt;2. ext2文件系统&lt;/h4&gt;

&lt;p&gt;ext文件大小不能超过2GB,ext升级到第二扩展文件系统,ext2&lt;/p&gt;

&lt;p&gt;ext2是ext基本功能的一个扩展, 扩展了索引节点表的格式来保存系统上每个文件的更多信息&lt;/p&gt;

&lt;p&gt;添加了创建时间值,修改时间值,最后访问时间值来帮助系统管理员追踪文件的访问情况,最大文件大小增加到2TB(后期版本增加到32TB)&lt;/p&gt;

&lt;p&gt;ext2还改变了文件在数据块中存储的方式. ext文件系统常见的问题是在文件写入物理设备时,存储数据用的块很容易就分散在整个设备上(碎片化),降低文件系统的性能. ext2通过按组分配磁盘块来减轻碎片化,通过数据块分组,文件系统就不需要为了数据块查找整个物理设备来读取文件&lt;/p&gt;

&lt;p&gt;ext文件系统脆弱,每次存储或更新文件,要用新信息来更新索引节点表,但是并不是连成一气的,在存储文件和更新索引节点表的过程中,计算机系统发生了什么事情,这二者就不同步了&lt;/p&gt;

&lt;h3&gt;7.1.2 日志文件系统&lt;/h3&gt;

&lt;p&gt;取代了先将数据直接写入存储设备再更新索引节点表的作法&lt;/p&gt;

&lt;p&gt;日志文件系统会先将文件的更改写入临时文件(日志,journal)中,然后在数据成功写到存储设备和索引节点表之后,再删除对应的日志条目.&lt;/p&gt;

&lt;p&gt;如果系统在数据被写入到存储设备之前崩溃了或断电了,日志文件系统下次会读取日志文件并处理上次留下的未写入的数据&lt;/p&gt;

&lt;p&gt;3种日志 方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据模式&lt;/li&gt;
&lt;li&gt;排序模式&lt;/li&gt;
&lt;li&gt;回写模式&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;7.1.3 扩展的Linux日志文件系统&lt;/h3&gt;

&lt;p&gt;与ext2文件系统兼容,并且可以转换&lt;/p&gt;

&lt;h4&gt;1 ext3 文件系统&lt;/h4&gt;

&lt;p&gt;采用和ext2文件系统相同的索引节点结构,但是给每个设备增加了一个日志文件&lt;/p&gt;

&lt;p&gt;默认使用排序模式&lt;/p&gt;

&lt;p&gt;ext3 仍然缺一些东西,比如无法恢复误删的文件,没有内建的数据压缩功能,也不支持加密文件&lt;/p&gt;

&lt;h4&gt;2 ext4 文件系统&lt;/h4&gt;

&lt;p&gt;除了支持数据压缩和加密,ext4还支持一个称作&lt;strong&gt;区段(extent)&lt;/strong&gt;的特性. 区段在存储设备上按块分配空间, 但在索引节点表总只保存起始块的位置,无需列出所有用来存储文件中数据的数据块,可以在索引节点表中节省一些空间&lt;/p&gt;

&lt;p&gt;ext4 还整合了&lt;strong&gt;块预分配(block preallocation)&lt;/strong&gt; ,如果你想在存储上给一个你知道要变大的文件预留空间,通过ext4文件系统你可以为文件分配所有期望的块,不只是物理上存在的块,ext4文件系统用0填满预留的数据块,并知道不要将它们分配给其他文件&lt;/p&gt;

&lt;p&gt;如何加密,压缩,恢复, 我比较好奇&lt;/p&gt;

&lt;h4&gt;3 Reiser文件系统&lt;/h4&gt;

&lt;p&gt;ReiserFS, 只支持回写日志模式, Linux上最快的日志文件系统之一.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以在线调整已有文件系统的大小.&lt;/li&gt;
&lt;li&gt;尾部压缩(tail packing)技术, 可以将一个文件的数据填进另一个文件的数据块中的空白空间&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;4 JFS 文件系统&lt;/h4&gt;

&lt;p&gt;JFS(Journaled File System, 日志文件系统)&lt;/p&gt;

&lt;p&gt;排序日志模式&lt;/p&gt;

&lt;p&gt;基于区段的文件分配&lt;/p&gt;

&lt;h4&gt;5 XFS文件系统&lt;/h4&gt;

&lt;p&gt;回写日志模式&lt;/p&gt;

&lt;h2&gt;7.2 操作文件系统&lt;/h2&gt;

&lt;h3&gt;7.2.1 创建分区&lt;/h3&gt;

&lt;p&gt;分区可以是整个硬盘,也可以是硬盘的一部分,来容纳虚拟目录的一部分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fdisk&lt;/code&gt; 工具用来帮助安装管理在系统上的任何存储设备上的分区&lt;/p&gt;

&lt;p&gt;启动&lt;code&gt;fdisk&lt;/code&gt; 命令,要指定分区的存储设备的设备名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sdc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次给存储设备分区,会警告设备上没有分区表&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;fdisk命令&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;fdisk 分区设备名&lt;/code&gt; 进入交互式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主分区(primary partition)&lt;/strong&gt; 或者 &lt;strong&gt;扩展分区(extended partition)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主分区可以被文件系统直接格式化,扩展分区只能容纳其他主分区,扩展分区出现的原因是每个存储设备上只能有4个分区,可以创建多个扩展分区,然后在扩展分区内创建主分区来进行扩展&lt;/p&gt;

&lt;p&gt;IDE硬盘 /dev/hdx x为a,b,c等&lt;/p&gt;

&lt;p&gt;SATA和SCSI硬盘 /dev/sdx  x为a,b,c等&lt;/p&gt;

&lt;p&gt;格式化分区之前,要再三检查,保证正确&lt;/p&gt;

&lt;h3&gt;7.2.2 创建文件系统&lt;/h3&gt;

&lt;p&gt;数据存储到分区之前,先要用文件系统格式化它,这样才能用,不同格式用不同的命令行程序来格式化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mkefs ext文件系统&lt;/li&gt;
&lt;li&gt;mke2fs ext2文件系统&lt;/li&gt;
&lt;li&gt;mkfs.ext3 ext3文件系统&lt;/li&gt;
&lt;li&gt;mkfs.ext4 ext4文件系统&lt;/li&gt;
&lt;li&gt;mkreiserfs ReiserFS文件系统&lt;/li&gt;
&lt;li&gt;jfs_mkfs JFS文件系统&lt;/li&gt;
&lt;li&gt;mkfs.xfd XFS文件系统&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;未分区创建文件系统后,下一步是要将它挂载到虚拟目录下的某个挂载点,这样就可以将数据存储在新文件,可以将新文件系统挂载到虚拟目录中需要额外空间的任何位置.&lt;/p&gt;

&lt;p&gt;挂载当然还是&lt;code&gt;mount&lt;/code&gt; 命令&lt;/p&gt;

&lt;p&gt;用mount只是临时挂载文件系统,重启后不会自动挂载,要强制在启动时自动挂载,可以就爱那个文件系统添加到/etc/fstab文件总&lt;/p&gt;

&lt;h3&gt;7.2.3 如果出错了&lt;/h3&gt;

&lt;p&gt;每个文件系统都有自己的和文件系统交互的恢复命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fsck&lt;/code&gt;命令用来检查和修复任意类型的Linux文件系统&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fsck options filesystem&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;文件系统可以通过设备名,虚拟目录挂载点,分配给文件系统的唯一UUID值来引用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fsck&lt;/code&gt;命令使用&lt;code&gt;/etc/fstab&lt;/code&gt; 文件来决定挂载到系统上的存储设备的文件系统,如果设备通常不挂载,使用&lt;code&gt;-t&lt;/code&gt;  选项来指定文件系统类型.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;fsck的命令行选项&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;只能在为挂载的文件系统上运行fsck命令,对于大多数文件系统,只需卸载文件系统来进行检查,完成了重新挂载就好了,但是根文件系统含有所有核心的Linux命令和日志文件,不能在运行的系统上卸载它,这时使用Linux LiveCD 是个好时机&lt;/p&gt;

&lt;h2&gt;7.3 逻辑卷管理器&lt;/h2&gt;

&lt;p&gt;Linux逻辑卷管理器(Logical Volume Manager, LVM), 无需重新构建整个文件系统而操作硬盘空间&lt;/p&gt;

&lt;h3&gt;7.3.1 逻辑卷管理布局&lt;/h3&gt;

&lt;p&gt;在逻辑卷管理的世界里,硬盘称为&lt;strong&gt;物理卷(Physical Volume, PV)&lt;/strong&gt;, 每个物理卷都会映射到硬盘上创建的某个物理分区&lt;/p&gt;

&lt;p&gt;多个物理卷元素集中到一起可以组成一个&lt;strong&gt;卷组(Volume Group, VG)&lt;/strong&gt;. 逻辑卷管理系统会把卷组当做物理硬盘一样对待,但事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成的.卷组提供了一个创建逻辑分区的平台,而这些逻辑分区事实上包含了文件系统&lt;/p&gt;

&lt;p&gt;整个结构中的最后一层是&lt;strong&gt;逻辑卷(Logical Volume, LV)&lt;/strong&gt;, 为Linux提供了创建文件系统的分区环境, 作用类似于之前讨论的物理硬盘. Linux将逻辑卷当成物理分区对待,可以用任意一种标准Linux文件系统来格式化逻辑卷,再将它在某个挂载点添加进Linux虚拟目录中&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;逻辑卷管理环境 这图值得研究&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;7.3.2 Linux的LVM&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LVM1&lt;/li&gt;
&lt;li&gt;LVM2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;LVM2还提供了额外的功能&lt;/p&gt;

&lt;h4&gt;1. 快照&lt;/h4&gt;

&lt;p&gt;将一个已有逻辑卷在逻辑卷在线的状态下复制到另一个设备&lt;/p&gt;

&lt;p&gt;LVM1只允许创建只读快照&lt;/p&gt;

&lt;p&gt;LVM2 允许创建在线逻辑卷的可读写快照&lt;/p&gt;

&lt;p&gt;这个功能对快速故障转移或要修改数据的程序实验(一旦失败,就要重启系统)非常有用&lt;/p&gt;

&lt;h4&gt;2. 条带化&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;条带化(striping)&lt;/strong&gt;, 有了条带化课跨多个物理硬盘创建逻辑卷,当Linux LVM将文件写入逻辑卷时, 文件总的数据块会被分散到多个硬盘上, 每个后继数据块会被写到下一个硬盘&lt;/p&gt;

&lt;p&gt;条带化有助于提高硬盘的性能,可以将一个文件的多个数据块同时些入多个硬盘,读取数据也可以从多个硬盘读取&lt;/p&gt;

&lt;h4&gt;3. 镜像&lt;/h4&gt;

&lt;p&gt;和物理分区一样, LVM逻辑卷也会受到断电和硬盘崩溃的影响.&lt;/p&gt;

&lt;p&gt;镜像是一个实时更新的逻辑卷的一份完整副本,当穿件镜像逻辑卷时,LVM会将原始逻辑卷同步到镜像副本中&lt;/p&gt;

&lt;p&gt;一旦原始同步完成,LVM会为文件系统的每次写过程进行两次写过程--一个写到主逻辑卷,一个写到镜像副本. 当然这个过程会降低系统的写入性能,但是可靠性很高&lt;/p&gt;

&lt;h3&gt;7.3.3 使用Linux LVM&lt;/h3&gt;

&lt;h4&gt;1. 定义物理卷&lt;/h4&gt;

&lt;p&gt;第一步, 将硬盘上的物理分区转换成Linux LVM使用的物理卷区段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fdisk&lt;/code&gt; 的&lt;code&gt;t&lt;/code&gt;命令改变分区类型(8e, 表示分区将会被用作LVM的一部分,而不是直接的文件系统&lt;/p&gt;

&lt;p&gt;第二步,用分区来创建真实的物理卷,通过&lt;code&gt;pvcreate&lt;/code&gt;命令来完成&lt;/p&gt;

&lt;h4&gt;2. 创建卷组&lt;/h4&gt;

&lt;p&gt;第三步,从物理卷中创建一个或多个卷组, 卷组数量没有限制&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vgcreate Vol1 /dev/sdc1&lt;/code&gt; 命令创建卷组Vol1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vgdisplay&lt;/code&gt; 显示卷组的细节&lt;/p&gt;

&lt;h4&gt;3. 创建逻辑卷组&lt;/h4&gt;

&lt;p&gt;逻辑卷是Linux系统用来模拟物理分区以及保存文件系统的, Linux系统会像处理物理分区一样处理逻辑卷,允许定义逻辑卷中的文件系统,然后将文件系统挂载到虚拟目录上&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lvcreate&lt;/code&gt; 创建逻辑卷&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;lvcreate的选项&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;lvdisplay&lt;/code&gt; 查看创建的逻辑卷的信息情况&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; 参数指定了要使用的逻辑卷占卷组的空闲空间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 指定逻辑卷的名称&lt;/p&gt;

&lt;h4&gt;4. 创建文件系统&lt;/h4&gt;

&lt;p&gt;要做文件系统,使用创建文件系统对应的命令行程序&lt;code&gt;mfs.ext4&lt;/code&gt;之类的&lt;/p&gt;

&lt;p&gt;创建完成后可以使用mount来挂载&lt;/p&gt;

&lt;p&gt;路径使用卷组名和逻辑卷名一起来标识,而不是用物理分区的路径.&lt;/p&gt;

&lt;h4&gt;5. 修改LVM&lt;/h4&gt;

&lt;p&gt;LVM可以动态修改文件系统&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vgchange 激活和禁用卷组&lt;/li&gt;
&lt;li&gt;vgremove 删除卷组&lt;/li&gt;
&lt;li&gt;vgextent 将物理卷加到卷组中&lt;/li&gt;
&lt;li&gt;vgreduce 从卷组总删除物理卷&lt;/li&gt;
&lt;li&gt;lvexend 增加逻辑卷的大小&lt;/li&gt;
&lt;li&gt;lvreduce 减小逻辑卷的大小&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在手动增加或者减小逻辑卷的大小时,要小心,存储在逻辑卷中的文件系统需要手动修复来处理大小上的改变,大多数文件系统包含重新调整文件系统格式的命令行程序,比如ext2和ext3的resize2fs程序&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/21/chapter7-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/21/chapter7-lclss</guid>
                <pubDate>2012-12-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>理解Linux文件权限 chapter6 LCLSS</title>
                <description>&lt;h1&gt;第6章 理解Linux文件权限&lt;/h1&gt;

&lt;h2&gt;6.1 Linux的安全性&lt;/h2&gt;

&lt;p&gt;Linux安全系统的核心是用户账户,每个进入Linux系统的用户都会被分配一个唯一的用户账户,用户对系统上对象的访问权限取决于他们登录系统时用的账户&lt;/p&gt;

&lt;p&gt;用户权限是通过创建用户时分配的&lt;strong&gt;用户ID(User ID, UID)&lt;/strong&gt;来跟踪的&lt;/p&gt;

&lt;p&gt;每个用户都有唯一的UID,登录时不用UID登录,而用&lt;strong&gt;登录名(login name)&lt;/strong&gt;,登录名关联一个对应的密码&lt;/p&gt;

&lt;h3&gt;6.1.1 /etc/passwd文件&lt;/h3&gt;

&lt;p&gt;文件管理登录名和UID的对应&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;root&lt;/strong&gt;是系统管理员,UID为0&lt;/p&gt;

&lt;p&gt;linux会为各种各样的功能创建不同的用户账户,这些账户不是真正的用户,是&lt;strong&gt;系统账户&lt;/strong&gt;,是系统上运行的各种服务进程访问资源用的特殊账户, 所有运行在后台的服务都需要一个系统用户账户登录到Linux系统.&lt;/p&gt;

&lt;p&gt;Linux为系统账户预留了500一下的UID值,有些服务甚至要特定的UID才能正常工作.&lt;/p&gt;

&lt;p&gt;为不同用户创建账户时,大多数Linux系统会将500起始的第一个可用UID分配给这个账户&lt;/p&gt;

&lt;p&gt;/etc/passwd 包含&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;登录用户名&lt;/li&gt;
&lt;li&gt;用户密码&lt;/li&gt;
&lt;li&gt;用户账户UID&lt;/li&gt;
&lt;li&gt;用户账户GID&lt;/li&gt;
&lt;li&gt;用户账户的文本描述&lt;/li&gt;
&lt;li&gt;用户的HOME目录位置&lt;/li&gt;
&lt;li&gt;用户的默认shell&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;密码显示为x,现在的密码一般保存在另一个单独文件中(shadow文件,/etc/shadow),只有特定的程序才能访问这个文件&lt;/p&gt;

&lt;p&gt;虽然/etc/passwd 可以直接编辑,但是最好不要,一旦损坏系统就无法读取他了,甚至连root也无法登陆了.&lt;/p&gt;

&lt;h3&gt;6.1.2 /etc/shadow文件&lt;/h3&gt;

&lt;p&gt;/etc/shadow 能对Linux系统如何管理密码有更多的控制,只有root可以访问&lt;/p&gt;

&lt;p&gt;为系统上的每个用户账户保存了一条记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dexctor:$1$lUhhbcOL$udjVN09RCa3YVagoJgGt91:15567:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9个字段&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;登录名&lt;/li&gt;
&lt;li&gt;加密后的密码&lt;/li&gt;
&lt;li&gt;自1970年1月1日(上次修改密码的日期)到当天的天数&lt;/li&gt;
&lt;li&gt;多少天后才能修改密码&lt;/li&gt;
&lt;li&gt;多少天后必须修改密码&lt;/li&gt;
&lt;li&gt;密码过期前提前多少天提醒用户更换密码&lt;/li&gt;
&lt;li&gt;密码过期后多少天禁用用户账户&lt;/li&gt;
&lt;li&gt;用户账户被禁用的日期&lt;/li&gt;
&lt;li&gt;预留字段,给将来使用&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;6.1.3 添加新用户&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 命令来添加新用户.&lt;/p&gt;

&lt;p&gt;有可能在/usr/sbin/useradd,有可能不在PATH下.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;useradd -D&lt;/code&gt; 查看系统默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GROUP=100     //新用户添加到GID为100的组
HOME=/home    //HOME目录为/home/loginname
INACTIVE=-1   //密码过期后不会禁用
EXPIRE=       //未被设置为某个日期后过期
SHELL=/bin/sh //bash 作为默认shell
SKEL=/etc/skel //系统会将/etc/skel目录下的内容复制到HOME下
CREATE_MAIL_SPOOL=no //不创建mail目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不在命令行制定,useradd会使用默认设置&lt;/p&gt;

&lt;p&gt;倒数第二个配置,useradd允许管理员创建一份默认的HOME目录配置,然后把它作为创建新用户HOME目录的模板.&lt;/p&gt;

&lt;p&gt;默认useradd不创建HOME目录,&lt;code&gt;-m&lt;/code&gt;选项会叫他创建HOME目录&lt;/p&gt;

&lt;p&gt;要想在创建用户时改变默认值或默认行为,可以使用命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;useradd命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;修改默认值&lt;code&gt;useradd -D 参数&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`useradd -D -s /bin/tsch` 默认shell改为tsch
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6.1.4 删除用户&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;userdel&lt;/code&gt; 删除用户&lt;/p&gt;

&lt;p&gt;默认情况只是删除/ect/passwd文件总的用户信息,而不会删除属于该账户的任何文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-r&lt;/code&gt;参数,删除HOME和mail目录, 然而系统上仍然可能存在归已删除用户所有的文件,这有可能导致问题&lt;/p&gt;

&lt;h3&gt;6.1.5 修改用户&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;usermod 修改用户账户字段,并可以指定主要组以及附加组的所属关系&lt;/li&gt;
&lt;li&gt;passwd 改密码&lt;/li&gt;
&lt;li&gt;chpasswd 从文件中读取登录名密码对,并更新密码&lt;/li&gt;
&lt;li&gt;chage 修改密码的过期日期&lt;/li&gt;
&lt;li&gt;chfn 修改用户账户的备注信息&lt;/li&gt;
&lt;li&gt;chsh 修改默认shell&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1 usermod&lt;/h4&gt;

&lt;p&gt;可以修改/etc/passwd 中的大部分字段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-c&lt;/code&gt; 修改备注字段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 修改过期日期&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-g&lt;/code&gt; 修改默认登录组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; 修改用户账户的登录名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-L&lt;/code&gt; 锁定用户账户, 这样用户就无法登录了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 修改密码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-U&lt;/code&gt; 解出锁定&lt;/p&gt;

&lt;h4&gt;2 passwd和chpasswd&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;passwd test&lt;/code&gt; 修改test用户的密码&lt;/p&gt;

&lt;p&gt;无参数是修改当前用户的密码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 选项能强制用户下次登录时修改密码, 可以先给用户设置一个简单的密码,再让他下次登录时改成更复杂的密码&lt;/p&gt;

&lt;p&gt;若要为系统中的大量用户来修改密码, chpasswd命令能让事情变简单,&lt;code&gt;chpasswd&lt;/code&gt;能从标准输入读取登录名和密码对(冒号分割)列表,给密码加密.也可用重定向&lt;/p&gt;

&lt;h4&gt;3 chsh, chfn 和 chage&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;chsh&lt;/code&gt; 修改默认的shell, 要用shell的完整路径&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chfn&lt;/code&gt; 提供了在/etc/passwd文件备注字段中存储信息的标准方法,&lt;code&gt;chfn&lt;/code&gt;会将&lt;code&gt;finger&lt;/code&gt;命令用到的信息存进备注字段.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;finger&lt;/code&gt; 可以简单的查看Linux系统的用户信息,但是处于安全性考虑,这个命令一般会被禁&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chage&lt;/code&gt; 命令帮助用户管理用户账户的有效期&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;YYYY-MM-DD格式日期&lt;/li&gt;
&lt;li&gt;从1970.1.1 到该日期的天数的数值&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;用&lt;code&gt;chage&lt;/code&gt;可以设定临时用户,到日期后就失效&lt;/p&gt;

&lt;h2&gt;6.2 使用Linux组&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;组(Group)&lt;/strong&gt; 在一组用户共享资源时使用有效&lt;/p&gt;

&lt;p&gt;组权限允许多个用户共享一组共用的权限来访问系统上的对象,比如文件,目录,设备&lt;/p&gt;

&lt;p&gt;每个组有一个唯一的GID,和唯一的组名&lt;/p&gt;

&lt;h3&gt;6.2.1 /etc/group文件&lt;/h3&gt;

&lt;p&gt;`/etc/group包含系统上的每个组的信息&lt;/p&gt;

&lt;p&gt;系统账户的组通常会分配低于500的GID,而用户组从500开始分配&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组名&lt;/li&gt;
&lt;li&gt;组密码&lt;/li&gt;
&lt;li&gt;GID&lt;/li&gt;
&lt;li&gt;属于该组的用户列表(要小心的是并不是所有用户都会列在这里,如果/etc/passwd文件中制定某个组作为默认组时,用户账户不会作为该组的成员再次出现在/etc/group文件中.)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;组密码允许非组内成员通过它临时性的称为该组成员,但这个功能不常用&lt;/p&gt;

&lt;p&gt;不要直接修改/etc/group文件来添加用户到一个组,而要用usermod.&lt;/p&gt;

&lt;p&gt;在添加用户到组之前,先要创建组&lt;/p&gt;

&lt;h3&gt;6.2.2 创建新组&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;groupadd&lt;/code&gt; 创建新组&lt;/p&gt;

&lt;p&gt;创建新组时,默认没有用户属于该组成员,groupadd没有提供将用户添加到组的选项,但是可以用&lt;code&gt;usermod&lt;/code&gt;命令将用户添加到组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;usermod -G test dexctor&lt;/code&gt; 将dexctor,添加到test&lt;/p&gt;

&lt;p&gt;如果更改已登录系统账户的所属用户组,重新登录后,组关系才会生效&lt;/p&gt;

&lt;p&gt;将组添加到用户账户要格外小心,如果加了&lt;code&gt;-g&lt;/code&gt;参数,那么默认组将被替换,而&lt;code&gt;-G&lt;/code&gt;将该组添加到用户的属组列表,不会影响默认组&lt;/p&gt;

&lt;h3&gt;6.2.3 修改组&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;groupmod&lt;/code&gt; 修改已有组的GID&lt;code&gt;-g&lt;/code&gt;参数,或组名&lt;code&gt;-n&lt;/code&gt;参数&lt;/p&gt;

&lt;p&gt;修改组名,GID和成员不变,只有组名改变,所有安全权限都是基于GID的,可以随意修改组名而不会影响文件的安全性(&lt;em&gt;那么修改GID呢?&lt;/em&gt;)&lt;/p&gt;

&lt;h2&gt;6.3 理解文件权限&lt;/h2&gt;

&lt;h3&gt;6.3.1 使用文件权限符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ls -l&lt;/code&gt; 第一个字段是描述文件和目录权限的码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 代表文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; 代表目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; 代表链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 代表字符型设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 代表块设备&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 代表网络设备&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;r&lt;/code&gt; 代表对象是可读的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 代表对象是可写的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 代表对象是可执行的&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;没有某种权限,会出现单破折号&lt;/p&gt;

&lt;p&gt;三组三字码分别对应对象的3个安全级别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对象的属主&lt;/li&gt;
&lt;li&gt;对象的属组&lt;/li&gt;
&lt;li&gt;&lt;p&gt;系统其他用户&lt;/p&gt;

&lt;p&gt;  -rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;rwx: 文件的属主(设为登录名rich)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;rwx: 文件的属组(设为组名rich)&lt;/li&gt;
&lt;li&gt;r-x: 系统其他人&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;rich用户可读可写可执行文件,rich组用户可读可写可执行文件,其他可读可执行&lt;/p&gt;

&lt;h3&gt;6.3.2 默认文件权限&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;umask&lt;/code&gt; 设置用户创建文件和目录的默认权限&lt;/p&gt;

&lt;p&gt;&lt;code&gt;umask&lt;/code&gt; 可以显示和设置这个默认权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umake
0022
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一位代表了一项特别的安全特性,叫做&lt;strong&gt;粘着位(sticky bit)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后面三位表示文件或目录umask的八进制值.&lt;/p&gt;

&lt;p&gt;但是为什么新建文件的权限是644呢?&lt;/p&gt;

&lt;p&gt;umask值只是个掩码,它会屏蔽掉不想授予该安全级别的权限,umask值会从对象的全权限中减掉,对文件来说全权限是666,对目录来说全权限是77&lt;/p&gt;

&lt;p&gt;umask通常设定在/etc/profile启动文件中,也可通过umask命令设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;umask 026&lt;/code&gt;  将umask设定为026&lt;/p&gt;

&lt;h2&gt;6.4 改变安全性设置&lt;/h2&gt;

&lt;h3&gt;6.4.1 改变权限&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;chmod options mode file&lt;/code&gt; 改变文件和目录的安全性设置&lt;/p&gt;

&lt;p&gt;mode参数后可跟八进制模式或符号模式来设置安全性设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod 760 newfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将newfile权限改为760&lt;/p&gt;

&lt;p&gt;符号权限就比较麻烦了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[ugoa...][[+-=][rwxXstugo...]&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u 代表用户&lt;/li&gt;
&lt;li&gt;g 代表组&lt;/li&gt;
&lt;li&gt;o 代表其他&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a 代表所有&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;增加权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;移除权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;= 设定权限&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X 如果对象是目录或者它已有执行权限,赋予执行权限&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;s 运行时重设UID或GID &lt;strong&gt;重要&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;t 保留问及或目录&lt;/li&gt;
&lt;li&gt;u 将权限设置为跟属主一样&lt;/li&gt;
&lt;li&gt;g 将权限设置为跟属组一样&lt;/li&gt;
&lt;li&gt;&lt;p&gt;o 将权限设置为跟其他用户一样&lt;/p&gt;

&lt;p&gt;  chmod o+r newfile  other增加读权限&lt;/p&gt;

&lt;p&gt;  chmod u-r newfile  user移除读权限&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;options&lt;/code&gt; 参数为chmod命令提供额外的功能, &lt;code&gt;-R&lt;/code&gt;参数可以让权限的改变递归的作用到文件和子目录&lt;/p&gt;

&lt;h3&gt;6.4.2 改变所属关系&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;chown&lt;/code&gt; 改变属主&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chgrp&lt;/code&gt; 改变默认属组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chown options owner[.group] file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;chown也同时支持改变文件属组,加.group&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chown .rich newfile&lt;/code&gt; 改变目录的默认属组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chown rich. newfile&lt;/code&gt; 改变目录属主和属组为rich&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-R&lt;/code&gt; 递归改变子目录和文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-h&lt;/code&gt;参数改变该文件所有符号链接文件的所属关系&lt;/p&gt;

&lt;p&gt;只有root能改属主, 属主可以改属组,但是属主必须属于源和目标属组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chgrp group file&lt;/code&gt; 改变属组&lt;/p&gt;

&lt;h2&gt;6.5 共享文件&lt;/h2&gt;

&lt;p&gt;创建组是Linux系统上共享文件访问权限的方法&lt;/p&gt;

&lt;p&gt;改变文件的属组,或者将用户加到文件属组, 不一定,还有更好的方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置用户ID(SUID) 当文件被用户使用时,程序会以文件属主的权限运行&lt;/li&gt;
&lt;li&gt;设置组ID(SGID) 对文件来说,程序会以文件属组的权限运行,对目录来说,目录创建的新文件会以目录的默认属主作为默认属主&lt;/li&gt;
&lt;li&gt;粘着位, 进程结束后文件还会在内存中&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;SGID&lt;/strong&gt; 对文件共享非常重要,使能SGID位, 在共享目录下创建的新文件属于该目录的属组,也就是每个用户的组&lt;/p&gt;

&lt;p&gt;SGID 通过chmod命令设置,加到标准3位8进制之前(组成4位8进制),或者在符号模式下使用符号s&lt;/p&gt;

&lt;p&gt;  1    2     3
SUID SGID 粘着位&lt;/p&gt;

&lt;p&gt;共享文件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建共享目录&lt;/li&gt;
&lt;li&gt;chgrp 默认属组改为含有所有所需共享文件用户的组&lt;/li&gt;
&lt;li&gt;设置目录的SGID 为,新建文件以共享组为属组&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;为了能正常工作,要把umask设为属组可写&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/19/chapter6-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/19/chapter6-lclss</guid>
                <pubDate>2012-12-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用linux环境变量 chapter5 LCLSS</title>
                <description>&lt;h1&gt;第5章 使用linux环境变量&lt;/h1&gt;

&lt;h2&gt;5.1 什么是环境变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;环境变量(environment variables)&lt;/code&gt; bash shell用来存储有关shell会话和工作环境的信息&lt;/p&gt;

&lt;p&gt;它允许你在内存中存储数据,这些数据可以用来标识用户账户,系统,shell的特性及其其他存储的数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;5.1.1 全局变量&lt;/h3&gt;

&lt;p&gt;全局变量不仅对shell会话可见,对shell创建的子进程也可见. 局部变量只对shell可见&lt;/p&gt;

&lt;p&gt;系统环境变量大写,区别于普通用户的环境变量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printenv&lt;/code&gt; 查看全局变量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo $HOME&lt;/code&gt; 显示HOME环境变量的值&lt;/p&gt;

&lt;h3&gt;5.1.2 局部环境变量&lt;/h3&gt;

&lt;p&gt;局部环境变量只能在定义他们的进程中可见.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set&lt;/code&gt; 显示进程的所有环境变量(局部,全局),貌似没有方法访问单个局部变量,可以用&lt;code&gt;grep&lt;/code&gt;啊&lt;/p&gt;

&lt;h2&gt;5.2 设置环境变量&lt;/h2&gt;

&lt;h3&gt;5.2.1 设置局部环境变量&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;test=testing&lt;/code&gt; 设置&lt;strong&gt;test&lt;/strong&gt;环境变量的值为&lt;strong&gt;testing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$test&lt;/code&gt; 来引用test环境变量, 很简单&lt;/p&gt;

&lt;p&gt;&lt;code&gt;test = 'testing a long string'&lt;/code&gt; 将含有空格的字符串赋值给变量,要用&lt;code&gt;'&lt;/code&gt;界定字符串的开始和结束&lt;/p&gt;

&lt;p&gt;自己创建的环境变量用小写,系统环境变量用大写,有助于区分&lt;/p&gt;

&lt;p&gt;环境变量,等号,值之间没有空格,否则错误,各部分被当成命令&lt;/p&gt;

&lt;p&gt;新建进程中无法使用之前的环境变量&lt;/p&gt;

&lt;h3&gt;5.2.2 设置全局环境变量&lt;/h3&gt;

&lt;p&gt;先创建一个局部环境变量,再把它导出到全局变量中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt; 命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $test=testing
 $echo $test //有
 $bash //新建进程
 $echo $test //无,因为是局部变量
 $exit //退回到主进程
 $export test //将环境变量导出到全局变量
 $bash
 $echo $test //有
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5.3 删除环境变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;unset&lt;/code&gt; 命令来删除环境变量&lt;/p&gt;

&lt;p&gt;在处理全局环境变量时比较麻烦,如果在子进程中删除了一个全局变量,它只对子进程有效,全局变量在父进程中依然有效&lt;/p&gt;

&lt;p&gt;因此要在父进程中删除?&lt;/p&gt;

&lt;h2&gt;5.4 默认shell环境变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HOME&lt;/li&gt;
&lt;li&gt;PATH&lt;/li&gt;
&lt;li&gt;PS1&lt;/li&gt;
&lt;li&gt;PS2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;PATH环境变量是以&lt;code&gt;:&lt;/code&gt;分割的shell查找命令的目录的列表,相当重要&lt;/p&gt;

&lt;p&gt;并不是说有变量都会在set时输出,因为不是说有变量都有值&lt;/p&gt;

&lt;h2&gt;5.5 设置PATH环境变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PATH&lt;/code&gt; 定义的命令行输入命令的搜索路径,如果找不到命令,会产生错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; echo $PATH
 PATH=$PATH:/home/user/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在PATH后面添加&lt;code&gt;/home/user/test&lt;/code&gt; 目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=$PATH:.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将当前目录加到PATH,但是最好不要这样,会出问题的&lt;/p&gt;

&lt;h2&gt;5.6 定位系统环境变量&lt;/h2&gt;

&lt;p&gt;启动bash shell时,默认情况下bash在几个文件中查找命令,这些文件被称为&lt;strong&gt;启动文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;bash shell 3三种启动方式&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;登录时当做默认登录shell&lt;/li&gt;
&lt;li&gt;作为非登录shell的交互式shell&lt;/li&gt;
&lt;li&gt;作为运行脚本的非交互shell&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;5.6.1 登录shell&lt;/h3&gt;

&lt;p&gt;4个启动文件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;/etc/profile&lt;/li&gt;
&lt;li&gt;$HOME/.bash_profile&lt;/li&gt;
&lt;li&gt;$HOME/.bash_login&lt;/li&gt;
&lt;li&gt;$HOME/.profile&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;1是系统上默认的bash shell主启动文件,2,3,4是用户专有的启动文件&lt;/p&gt;

&lt;h4&gt;1. /etc/profile&lt;/h4&gt;

&lt;p&gt;bash shell的主启动文件,系统上每个用户登录时都会执行这个启动文件,执行里面的命令,不同的发行版放了不同的命令&lt;/p&gt;

&lt;h4&gt;2. $HOME目录下的启动文件&lt;/h4&gt;

&lt;p&gt;提供用户专属的启动文件来定义用户专有的环境变量&lt;/p&gt;

&lt;h3&gt;5.6.2 交互式shell&lt;/h3&gt;

&lt;p&gt;shell不是在登录时启用,而是通过&lt;code&gt;bash&lt;/code&gt;命令启动的,称为交互式shell&lt;/p&gt;

&lt;p&gt;交互式shell不启动/etc/profile,而是去查看&lt;code&gt;$HOME/.bashrc&lt;/code&gt;是否存在&lt;/p&gt;

&lt;h3&gt;5.6.3 非交互式shell&lt;/h3&gt;

&lt;p&gt;系统执行脚本时使用的shell&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BASH_ENV&lt;/code&gt; 检查要启动的文件&lt;/p&gt;

&lt;h2&gt;5.7 可变数组&lt;/h2&gt;

&lt;p&gt;环境变量一个功能就是可以当做数组使用,值可以按单个值或整个数组来引用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mytest=(one two three four five)&lt;/code&gt; 括号包围,空格分隔&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;echo mytest&lt;/code&gt; 只显示&lt;code&gt;one&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo ${test[2]}&lt;/code&gt; 引用test的第二个值(从0开始), 注意是大括号包围&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo ${test[*]}&lt;/code&gt; 显示整个数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;test[2]=seven&lt;/code&gt; 改变第二个值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;unset test[2]&lt;/code&gt; 删除第二个值,但是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo ${test[2]}&lt;/code&gt; 是空,而不是后面的前移,其他的不变&lt;/p&gt;

&lt;p&gt;&lt;code&gt;unset test&lt;/code&gt; 来删除整个数组&lt;/p&gt;

&lt;p&gt;可变数组和其他shell环境不通用,在多种shell环境下编写大量脚本会不便,因此不常用&lt;/p&gt;

&lt;h2&gt;5.8 使用命令别名&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;命令别名&lt;/strong&gt; 允许为通用命令(和他们的参数在一起)创建一个别名,这样就能通过最少的键入调用想要的命令了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias -p&lt;/code&gt; 查看别名列表&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias li='ls -il'&lt;/code&gt; 创建li别名&lt;/p&gt;

&lt;p&gt;和局部环境变量差不多,自在定义他们的shell中有效&lt;/p&gt;

&lt;p&gt;当然可以在&lt;code&gt;.bashrc&lt;/code&gt; 文件里定义别名,这样启动时运行这个文件的shell都会有这个别名&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/19/chapter5-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/19/chapter5-lclss</guid>
                <pubDate>2012-12-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>更多的bash shell命令 chapter4 LCLSS</title>
                <description>&lt;h1&gt;第4章 更多的bash shell命令&lt;/h1&gt;

&lt;h2&gt;4.1 监测程序&lt;/h2&gt;

&lt;h3&gt;4.1.1 探查进程&lt;/h3&gt;

&lt;p&gt;进程(process) 是程序运行在系统上&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; 显示系统上所有程序的许多信息&lt;/p&gt;

&lt;p&gt;参数多,非常复杂&lt;/p&gt;

&lt;p&gt;默认情况下只显示当前用户的进程&lt;/p&gt;

&lt;p&gt;进程号(PID, Process ID)&lt;/p&gt;

&lt;p&gt;终端(TTY)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps&lt;/code&gt;命令曾经有两个版本,现在两个版本融合在一起了,使得问题更为复杂.&lt;/p&gt;

&lt;p&gt;3种不同的命令行参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unix风格的参数,前面加单破折号&lt;/li&gt;
&lt;li&gt;BSD风格的参数,前面不加破折号&lt;/li&gt;
&lt;li&gt;GNU风格的长参数,前面加双破折号&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;1. Unix风格的参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A&lt;/code&gt; 显示所有&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt; 显示与指定参数不符的所有进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; 显示除控制进程(session leader)和无终端的进程外的所有进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 显示除控制进程外的所有进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; 显示所有进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C cmdlist&lt;/code&gt; 显示包含在&lt;em&gt;cmdlist&lt;/em&gt;列表中的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-G grplist&lt;/code&gt; 显示组ID在&lt;em&gt;grplist&lt;/em&gt;列表中的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-U userlist&lt;/code&gt; 显示属主的用户ID在&lt;em&gt;userlist&lt;/em&gt;列表中的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g grplist&lt;/code&gt; 显示会话或组ID在&lt;em&gt;grplist&lt;/em&gt;列表中的进程&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;跪了,都列出来有意义吗?&lt;/p&gt;

&lt;p&gt;想多了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps -ef&lt;/code&gt; 显示所有进程的完整格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps -l&lt;/code&gt; 长格式输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-H&lt;/code&gt; 可以把输出进程组织成一个层级格式&lt;/p&gt;

&lt;h4&gt;2. BSD风格的参数&lt;/h4&gt;

&lt;h4&gt;3. GNU全字参数&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;--forest&lt;/code&gt; 参数,显示进程的层级信息&lt;/p&gt;

&lt;h3&gt;4.1.2 实时监测进程&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ps&lt;/code&gt;只能看某一时间点的进程及其状态&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top&lt;/code&gt; 可以观察频繁换进换出内存的进程的趋势&lt;/p&gt;

&lt;p&gt;系统概况:当前时间,系统运行时间,登入的用户数,系统平均负载&lt;/p&gt;

&lt;p&gt;系统平均负载: 1分钟,5分钟,15分钟&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top&lt;/code&gt; 交互式命令&lt;/p&gt;

&lt;h3&gt;4.1.3 结束进程&lt;/h3&gt;

&lt;p&gt;Linux上,进程间通过&lt;strong&gt;信号&lt;/strong&gt;来通信&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1  HUP   挂起&lt;/li&gt;
&lt;li&gt;2  INT   中断&lt;/li&gt;
&lt;li&gt;3  QUIT  结束运行&lt;/li&gt;
&lt;li&gt;9  KILL  无条件终止&lt;/li&gt;
&lt;li&gt;11 SEGV  段错误&lt;/li&gt;
&lt;li&gt;15 TERM  尽可能终止&lt;/li&gt;
&lt;li&gt;17 STOP  无条件停止运行,但不终止&lt;/li&gt;
&lt;li&gt;18 TSTP  停止或暂停, 但继续在后台运行&lt;/li&gt;
&lt;li&gt;19 CONT  在STOP或TSTP之后恢复执行&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;两个命令可以向进程发送信号: &lt;code&gt;kill&lt;/code&gt; 和 &lt;code&gt;killall&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;1 kill命令&lt;/h4&gt;

&lt;p&gt;通过PID给进程发送信号,默认发送TERM信号, 只能用PID不能用命令名&lt;/p&gt;

&lt;p&gt;要发送信号,必须是root或者进程的属主&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill PID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果程序忽略TERM信号,就要用其他信号,通常先试试TERM信号,再试试HUP或者INT信号,KIll信号最强,直接终止进程,有可能损坏文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kill -s HUP 309&lt;/code&gt; 挂起309进程&lt;/p&gt;

&lt;h4&gt;2 killall命令&lt;/h4&gt;

&lt;p&gt;支持通过进程名来结束进程,支持通配符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;killall http*&lt;/code&gt; 结束http开头的所有进程&lt;/p&gt;

&lt;h2&gt;4.2 检测磁盘空间&lt;/h2&gt;

&lt;h3&gt;4.2.1 挂载存储媒体&lt;/h3&gt;

&lt;p&gt;把存储媒体放在虚拟目录下,成为&lt;strong&gt;挂载&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可移动存储媒体  自动挂载&lt;/p&gt;

&lt;h4&gt;mount命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;mount&lt;/code&gt;  默认输出所有当前挂载的媒体&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;媒体的设备文件名&lt;/li&gt;
&lt;li&gt;媒体挂载到虚拟目录的挂载点&lt;/li&gt;
&lt;li&gt;文件系统类型&lt;/li&gt;
&lt;li&gt;已挂载媒体的访问状态&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;mount -t type device directory&lt;/code&gt; 手动挂载命令  type指定了磁盘被格式化的文件系统类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vfat&lt;/li&gt;
&lt;li&gt;ntfs&lt;/li&gt;
&lt;li&gt;iso9660&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;mount -t vfat /dev/sdb1 /media/disk&lt;/code&gt; 将vfat类型sdb1 挂载到 /media/disk目录&lt;/p&gt;

&lt;h4&gt;umount命令&lt;/h4&gt;

&lt;p&gt;移除一个设备要先卸载&lt;/p&gt;

&lt;p&gt;&lt;code&gt;umount [directory | device ]&lt;/code&gt; 支持通过设备文件或挂载点来指定要卸载的设备,若有程序在运行则不允许卸载(device is busy)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lsof [directory | device]&lt;/code&gt; 可以查看访问或者使用设备的进程,无法卸载时,先使用该命令看进程&lt;/p&gt;

&lt;h3&gt;4.2.2 使用df命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;df&lt;/code&gt; 命令查看已挂载磁盘的使用情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设备的设备文件位置&lt;/li&gt;
&lt;li&gt;能容纳多少个x块  (x不一定有1k,有500)&lt;/li&gt;
&lt;li&gt;已使用&lt;/li&gt;
&lt;li&gt;未使用&lt;/li&gt;
&lt;li&gt;使用空间比&lt;/li&gt;
&lt;li&gt;挂载到了哪个挂载点上&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt; 比较容易读的形式&lt;/p&gt;

&lt;h4&gt;du命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;du&lt;/code&gt; 显示特定目录(默认为当前目录)的磁盘使用情况&lt;/p&gt;

&lt;p&gt;这个列表是从一个目录层级的最底部开始的,然后按文件,子目录,目录逐级向上的&lt;/p&gt;

&lt;p&gt;默认命令并没有太大用处&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-c&lt;/code&gt; 显示所有已列出文件总的大小
&lt;code&gt;-h&lt;/code&gt; 人类可读方式输出
&lt;code&gt;-s&lt;/code&gt; 显示每个输出参数的总计&lt;/p&gt;

&lt;p&gt;&lt;code&gt;du -sh *&lt;/code&gt; 可以显示当前目录下每个文件和目录的大小&lt;/p&gt;

&lt;h2&gt;4.3 处理数据文件&lt;/h2&gt;

&lt;h3&gt;4.3.1 数据排序&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sort file&lt;/code&gt; 对file文件内容进行默认排序,貌似是按照字符串进行排序的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort -n file&lt;/code&gt; 按照数字进行排序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort -M file&lt;/code&gt; 按照月份(month)进行排序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-k&lt;/code&gt; 和 &lt;code&gt;-t&lt;/code&gt; 参数也比较有用,&lt;code&gt;-t&lt;/code&gt;确定域的分隔符,&lt;code&gt;-k&lt;/code&gt;确定按第几个域进行排序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort -t ':' -k 3 -n /etc/passwd&lt;/code&gt; 对passwd每行按&lt;code&gt;:&lt;/code&gt;进行分割,按第三个域进行排序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;du sh * | sort -nr&lt;/code&gt; 可以按大小查看当前目录下文件和目录的大小&lt;/p&gt;

&lt;h3&gt;4.3.2 搜索数据&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;grep [options] pattern [file]&lt;/code&gt; 命令来搜索某一行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; 选项显示那些不匹配的行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 选项在行前显示行号&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-c&lt;/code&gt; 仅显示搜索到的行数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 可以添加多个pattern, 或操作&lt;code&gt;grep -e [pattern1] -e [pattern2] file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;egrep&lt;/code&gt; 命令是&lt;code&gt;grep&lt;/code&gt;的一个分支,允许POSIX正则表达式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fgrep&lt;/code&gt; 允许将一系列字符串作为pattern, 比如输入一个含多个字符串的文件.&lt;/p&gt;

&lt;h3&gt;4.3.3 数据压缩&lt;/h3&gt;

&lt;h4&gt;bzip2工具&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bzip2&lt;/code&gt; 压缩文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bzcat&lt;/code&gt; 显示压缩文件的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bunzip2&lt;/code&gt; 解压&lt;code&gt;.bz2&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bzip2recover&lt;/code&gt; 尝试修复损坏的文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;默认压缩文件会替换源文件&lt;/p&gt;

&lt;h4&gt;gzip 工具&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;gzip&lt;/li&gt;
&lt;li&gt;gzcat&lt;/li&gt;
&lt;li&gt;gunzip&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;zip工具&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zip&lt;/code&gt; 压缩文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zipcloak&lt;/code&gt; 加密压缩&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zipnote&lt;/code&gt; 解压注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zipsplit&lt;/code&gt; 将大的zip文件分成小的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unzip&lt;/code&gt; 解压文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;zip的好处是可以用&lt;code&gt;-r&lt;/code&gt;命令压缩整个文件夹&lt;/p&gt;

&lt;h3&gt;4.3.4 归档数据&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tar function [options] object1 object2 ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;function参数决定&lt;code&gt;tar&lt;/code&gt;命令做什么工作&lt;/p&gt;

&lt;p&gt;function&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A&lt;/code&gt; 将一个归档文件连接到另一个归档文件之后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 新建归档文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 检查一个归档文件和文件系统的差别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--delete&lt;/code&gt; 从归档文件中删除文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 将文件压缩添加到一个归档文件的末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; 用新文件替换旧文件,更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x&lt;/code&gt; 解压文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Option&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-C dir&lt;/code&gt; 转换到一个特定的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f file&lt;/code&gt; 输出到文件file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-j&lt;/code&gt; 重定向输出到bzip2进行压缩(tar 只进行归档不进行压缩?)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; 保留文件许可(permission)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 列出正在进行处理的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-z&lt;/code&gt; 重定向到gzip进行压缩&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://username.github.com/LCLSS/2012/12/17/chapter4-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/17/chapter4-lclss</guid>
                <pubDate>2012-12-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>基本的bash shell命令 chapter3 LCLSS</title>
                <description>&lt;h1&gt;chapter3 基本的bash shell命令&lt;/h1&gt;

&lt;h2&gt;3.1 启动shell&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/etc/passwd&lt;/code&gt;文件包含了所有系统用户账户列表以及每个用户的基本配置信息.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; root:*:0:0:System Administrator:/var/root:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;七个字段&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户名&lt;/li&gt;
&lt;li&gt;密码&lt;/li&gt;
&lt;li&gt;用户的系统UID(用户ID)&lt;/li&gt;
&lt;li&gt;用户的系统GID(组ID)&lt;/li&gt;
&lt;li&gt;用户的全名&lt;/li&gt;
&lt;li&gt;用户的默认主目录&lt;/li&gt;
&lt;li&gt;用户默认的shell程序&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;bash程序同样使用命令行参数来修改所启动shell的类型,bash支持的可定义启动shell类型的命令行参数&lt;/p&gt;

&lt;table&gt;

  &lt;tr&gt;
    &lt;td&gt;-c string&lt;/td&gt;
    &lt;td&gt;从string中读取命令并处理他们&lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;-r&lt;/td&gt;
    &lt;td&gt;启动限制性shell,限制用户在默认目录下活动&lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;-i&lt;/td&gt;
    &lt;td&gt;启动交互行shell,允许用户输入&lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;-s&lt;/td&gt;
    &lt;td&gt;从标准输入读取命令&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;默认情况下,bash shell启动时会自动处理用户主目录下的&lt;code&gt;.bashrc&lt;/code&gt;文件中的命令.许多linux发行版在此文件中加载特殊的&lt;strong&gt;共用文件&lt;/strong&gt;,在共用文件中保存着针对所有系统用户的命令和设置,共用文件位于&lt;code&gt;/etc/bashrc&lt;/code&gt;,它经常设置各种应用程序中用到的环境变量&lt;/p&gt;

&lt;h2&gt;3.2 shell提示符&lt;/h2&gt;

&lt;p&gt;bash shell提示符(默认$)&lt;/p&gt;

&lt;p&gt;有两个环境变量用来控制命令行提示符的格式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PS1: 控制默认命令提示符的格式&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PS2: 控制后续命令提示符的格式&lt;/p&gt;

&lt;p&gt;   echo $PS1&lt;/p&gt;

&lt;p&gt;   echo $PS2&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt;bash shell提示符字符&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;可以通过设定PS1和PS2来改变提示符,但是这个提示符只在当前shell下有用,重新开启后又是默认的提示符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; PS1=&quot;\t&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示符变为时间&lt;/p&gt;

&lt;h2&gt;3.3 bash手册&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; man date
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找&lt;code&gt;date&lt;/code&gt;命令的bash 手册&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;man bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过空格下翻,也可以通过上下键来翻页,&lt;code&gt;q&lt;/code&gt;退出&lt;/p&gt;

&lt;h2&gt;3.4 浏览文件系统&lt;/h2&gt;

&lt;h3&gt;3.4.1 Linux文件系统&lt;/h3&gt;

&lt;p&gt;Linux将文件存储在单个目录结构中,这个目录我们称为&lt;strong&gt;虚拟目录(virtual directory)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根(root)&lt;/strong&gt;目录&lt;/p&gt;

&lt;p&gt;Linux用&lt;code&gt;/&lt;/code&gt;来划分目录.&lt;code&gt;\&lt;/code&gt;用来转义&lt;/p&gt;

&lt;p&gt;第一块硬盘为&lt;strong&gt;根&lt;/strong&gt;驱动器,包含了虚拟目录的核心,其他目录都是从这里开始构建的.&lt;/p&gt;

&lt;p&gt;虚拟目录会让文件和目录出现在这些挂载点目录中,然而实际上他们却存储在另外一个驱动器中.&lt;/p&gt;

&lt;p&gt;通常系统文件会存储在根驱动器中,而用户文件则存储在另一驱动器中.&lt;/p&gt;

&lt;p&gt;常见linux目录名称&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;/&lt;/td&gt;
   &lt;td&gt;虚拟目录的根目录&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/bin&lt;/td&gt;
   &lt;td&gt;二进制目录,存放许多GNU用户级工具&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/boot&lt;/td&gt;
   &lt;td&gt;启动目录,存放启动文件&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/dev&lt;/td&gt;
   &lt;td&gt;设备目录,Linux在这里创建设备节点&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/etc&lt;/td&gt;
   &lt;td&gt;系统配置文件目录&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/home&lt;/td&gt;
   &lt;td&gt;主目录,Linux在这里创建用户目录&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/lib&lt;/td&gt;
   &lt;td&gt;库目录,存放系统和应用程序的库文件&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/media&lt;/td&gt;
   &lt;td&gt;媒体目录,存放可移动媒体设备挂载点的地方&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/mnt&lt;/td&gt;
   &lt;td&gt;挂载目录,另一个存放可移动媒体设备挂载点的地方&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/opt&lt;/td&gt;
   &lt;td&gt;可选目录,通常用于存放可选的软件包&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/root&lt;/td&gt;
   &lt;td&gt;根主目录&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/sbin&lt;/td&gt;
   &lt;td&gt;系统二进制目录,存放许多GNU管理员级工具&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/tmp&lt;/td&gt;
   &lt;td&gt;临时目录,可以在该目录中创建和删除临时工作文件&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/usr&lt;/td&gt;
   &lt;td&gt;用户安装软件的目录&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;/var&lt;/td&gt;
   &lt;td&gt;可变目录,用于存放经常彼岸花的文件,比如日志文件&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;3.4.2 遍历目录&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cd destination&lt;/code&gt; 命令来切换目录到destination&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;绝对文件路径 以虚拟目录的根目录开始,相当于目录的全名&lt;/li&gt;
&lt;li&gt;相对文件路径 基于当前位置的文件路径

&lt;ul&gt;
&lt;li&gt;单点符(.),当前目录&lt;/li&gt;
&lt;li&gt;双点符(..), 当前目录的父目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3.5 文件和目录列表&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 命令显示系统上有哪些文件&lt;/p&gt;

&lt;h3&gt;3.5.1 基本列表功能&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 最基本的格式会显示当前目录下的文件和目录&lt;/p&gt;

&lt;p&gt;输出列表按字母排序(按列排序,而不是按行排序)&lt;/p&gt;

&lt;p&gt;还支持不同的颜色区分不同类型的文件,&lt;code&gt;LS_COLORS&lt;/code&gt; 环境变量控制这个功能&lt;/p&gt;

&lt;p&gt;如果终端不支持彩色,可以用&lt;code&gt;-F&lt;/code&gt;参数来区分文件和目录&lt;/p&gt;

&lt;p&gt;隐藏文件以&lt;code&gt;.&lt;/code&gt;开始,不会在一般ls下显示&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ls -a&lt;/code&gt; 显示所有文件,包括隐藏文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-R&lt;/code&gt; 列出目录下包含的目录中的文件&lt;/p&gt;

&lt;h3&gt;3.5.2 修改输出信息&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; 参数产生长列表格式,包含更多信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文件类型&lt;/li&gt;
&lt;li&gt;文件权限&lt;/li&gt;
&lt;li&gt;文件硬链接总数&lt;/li&gt;
&lt;li&gt;文件属主的用户名&lt;/li&gt;
&lt;li&gt;文件属组的组名&lt;/li&gt;
&lt;li&gt;文件的大小(字节为单位)&lt;/li&gt;
&lt;li&gt;文件上次修改时间&lt;/li&gt;
&lt;li&gt;文件名或目录名&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.5.3 完整的参数列表&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt; 之&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单字母 通常&lt;code&gt;-&lt;/code&gt;开始&lt;/li&gt;
&lt;li&gt;全字参数 通常&lt;code&gt;--&lt;/code&gt;开始&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;文件或目录的索引节点是内核分配给文件系统中每个对象的唯一标识符.&lt;/p&gt;

&lt;h3&gt;3.5.4 过滤输出列表&lt;/h3&gt;

&lt;p&gt;过滤器就是进行简单文字匹配的字符串,在命令行参数之后添加过滤器&lt;/p&gt;

&lt;p&gt;通配符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;问号代表一个字符&lt;/li&gt;
&lt;li&gt;星号代表零个或多个字符&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3.6 处理文件&lt;/h2&gt;

&lt;h3&gt;3.6.1 创建文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;touch test&lt;/code&gt; 创建test文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;touch&lt;/code&gt; 还可以改变文件的访问时间和修改时间,而不改变文件的内容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 参数只改变访问时间,&lt;code&gt;-m&lt;/code&gt; 参数只改变修改时间, &lt;code&gt;-t&lt;/code&gt; 参数指定要修改的成的时间&lt;/p&gt;

&lt;h3&gt;3.6.2 复制文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cp source destination&lt;/code&gt; 从源对象复制到目标对象&lt;/p&gt;

&lt;h3&gt;3.6.3 链接文件&lt;/h3&gt;

&lt;p&gt;虚拟副本-&lt;strong&gt;链接&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;符号链接,即软链接&lt;/li&gt;
&lt;li&gt;硬链接&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;硬链接会创建一个独立的文件,包含源文件的信息以及位置,应用链接文件等同于引用源文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cp -l test1 test2&lt;/code&gt; test2是test1的硬链接,两个文件的索引节点相同,链接计数增加&lt;/p&gt;

&lt;p&gt;只能在同种存储媒体上的文件之间创建硬链接&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; 创建软连接&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ln&lt;/code&gt; 也可创建链接,默认创建硬链接,&lt;code&gt;-s&lt;/code&gt; 创建软链接&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cp&lt;/code&gt; 命令来复制一个链接到另一个源文件的文件,复制的是源文件的副本,而不是链接文件.&lt;/p&gt;

&lt;p&gt;可以创建指向源文件的新链接,而不用复制链接文件,可以创建指向同一文件的多个链接,但不要创建指向符号链接文件的多个符号链接,这样会生成一个链接文件链,容易混淆,而且容易断&lt;/p&gt;

&lt;h3&gt;3.6.4 重命名文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mv source dest&lt;/code&gt; 将源文件移动到目标位置&lt;/p&gt;

&lt;p&gt;移动有软链接指向的文件要小心,链接会失效&lt;/p&gt;

&lt;h3&gt;3.6.5 删除文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rm test&lt;/code&gt; 删除test文件&lt;/p&gt;

&lt;p&gt;硬链接会一直维持索引节点号,直到删除最后一个硬链接它的文件.软连接会无效&lt;/p&gt;

&lt;h2&gt;3.7 处理目录&lt;/h2&gt;

&lt;h3&gt;3.7.1 创建目录&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mkdir&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;3.7.2 删除目录&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rmdir&lt;/code&gt; 默认只删除空目录&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rm -r dir2&lt;/code&gt; 删除dir2目录下的文件和目录本身,但是会有提醒,加&lt;code&gt;-f&lt;/code&gt;参数&lt;/p&gt;

&lt;h3&gt;3.8 查看文件内容&lt;/h3&gt;

&lt;h3&gt;3.8.1 查看文件统计信息&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;stat&lt;/code&gt; 命令查看文件的所有状态信息&lt;/p&gt;

&lt;h3&gt;3.8.2 查看文件类型&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 命令查看文件类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文本文件&lt;/li&gt;
&lt;li&gt;可执行文件&lt;/li&gt;
&lt;li&gt;数据文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.8.3 查看整个文件&lt;/h3&gt;

&lt;h4&gt;1 cat命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 显示文件的内容 &lt;code&gt;-n&lt;/code&gt; 行号&lt;/p&gt;

&lt;h4&gt;2 more命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;more&lt;/code&gt; 显示文件&lt;/p&gt;

&lt;h4&gt;3 less命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; less is more
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.8.4 查看部分文件&lt;/h3&gt;

&lt;h4&gt;1 tail命令&lt;/h4&gt;

&lt;p&gt;文件末尾部分,默认10行,可以参数&lt;code&gt;-n&lt;/code&gt;设定&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 参数让tail程序一直保持活动状态,有新内容加到末尾就显示&lt;/p&gt;

&lt;h4&gt;2 head命令&lt;/h4&gt;

&lt;p&gt;文件开头的几行&lt;/p&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/12/chapter3-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/12/chapter3-lclss</guid>
                <pubDate>2012-12-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>markdown tutorial</title>
                <description>&lt;h2&gt;markdown&lt;/h2&gt;

&lt;h3&gt;兼容HTML&lt;/h3&gt;

&lt;p&gt;可以在markdown文档中直接添加HTML标签&lt;/p&gt;

&lt;p&gt;要注意的是一些HTML区块元素,比如&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;等标签,必须在前后加上空行与其他内容隔开,开始标签和结尾标签不能用制表符或空格来缩进&lt;/p&gt;

&lt;p&gt;例如,在markdown文件中加上一段HTML表格:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markdown文档

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;Bar&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Tic&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;Puu&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

markdown文档
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下&lt;/p&gt;

&lt;p&gt;markdown文档&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
        &lt;td&gt;Bar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Tic&lt;/td&gt;
        &lt;td&gt;Puu&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;markdown文档&lt;/p&gt;

&lt;p&gt;在HTML区块标签中的markdown格式语法不会被处理,但是markdown区块中的HTML是有效的&lt;/p&gt;

&lt;p&gt;HTML的区段(行内)标签如&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt;可以在markdown的段落,列表或是标题内随意使用.依照个人习惯,甚至可以不用markdown格式,而直接使用HTML标签来格式化.比如可以使用HTML的&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;或者&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;del&amp;gt;test del&amp;lt;/del&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;test del&lt;/del&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;特殊字符的自动转换&lt;/h3&gt;

&lt;p&gt;在HTML中&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;要特殊处理. &lt;code&gt;&amp;lt;&lt;/code&gt;用于起始标签,&lt;code&gt;&amp;amp;&lt;/code&gt;用于标记HTML实体,如果只是想显示这些字符就要使用&lt;code&gt;&amp;amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;比如&lt;code&gt;AT&amp;amp;T&lt;/code&gt;要用&lt;code&gt;AT&amp;amp;amp;T&lt;/code&gt;,比较复杂的的如连接&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;必须要转换成&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://images.google.com/images?num=308&amp;amp;amp;q=larry+bird&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;才能放到链接标签&lt;code&gt;href&lt;/code&gt;属性里,这样是很容易出错的&lt;/p&gt;

&lt;p&gt;markdown会自动转换,当&lt;code&gt;&amp;amp;&lt;/code&gt;是HTML字符实体的一部分时,它会保留原状,否则会被转换成&lt;code&gt;&amp;amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;若要在文档里输入©,则要&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;copy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown保留&lt;code&gt;&amp;amp;&lt;/code&gt;符号,而&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`AT&amp;amp;T`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown会把它转换成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`AT&amp;amp;amp;T`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上是书写更自然了.&lt;/p&gt;

&lt;p&gt;类似的状况会发生在&lt;code&gt;&amp;lt;&lt;/code&gt;符号上,因为markdown兼容HTML,如果把&lt;code&gt;&amp;lt;&lt;/code&gt;符号作为HTML标签的界定符,那么markdown不会转换他,但如果是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4 &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown会把它转换成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4 &amp;amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在code范围内,无论是行内还是区块内,&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;都会转换成HTML实体,这样在markdown内写HTML的代码尤为方便,因为在HTML代码内写HTML代码,需要把所有的&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;手动转换为HTML实体.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;区块元素&lt;/h3&gt;

&lt;h4&gt;段落和换行&lt;/h4&gt;

&lt;p&gt;一个markdown段落是由一个或者多个连续的文本行组成的,前后要有一个以上的空行(空行是看起来是空的行,比如只包含空格和制表符,也被视为空行).普通的段落不应该用空格或者制表符来进行缩进(会形成code块的)&lt;/p&gt;

&lt;p&gt;markdown允许段落内的强迫换行(插入换行符),如果要以来markdown来插入&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;标签的话,在插入处先输入两个以上的空格然后回车.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ab  &amp;lt;return&amp;gt;ab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ab&lt;br/&gt;
ab&lt;/p&gt;

&lt;p&gt;而普通的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ab&amp;lt;return&amp;gt;ab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ab
ab&lt;/p&gt;

&lt;p&gt;虽然换行比较麻烦,但是简单的将每个换行都转换成&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;在markdown中并不合适,markdown中的email式的区块引用和多段落的列表在使用换行来排版的时候,不但更好用而且方便阅读.&lt;/p&gt;

&lt;h4&gt;标题&lt;/h4&gt;

&lt;p&gt;markdown支持两种标题语法,类Setext和类atx形式&lt;/p&gt;

&lt;p&gt;类Setext使用底线的形式,&lt;code&gt;=&lt;/code&gt;(最高阶标题)和&lt;code&gt;-&lt;/code&gt;(第二阶标题),任何数量的&lt;code&gt;=&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;都可以,例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is an H1
=============

This is an H2
--------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类Atx形式则是在行首插入1到6个&lt;code&gt;#&lt;/code&gt;,对应1到6阶&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这是H1

## 这是H2

###### 这是H6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以闭合类atx标题,只是为了美观&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这是H1 #

## 这是 H2 #

### 这是 H3 #
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;区块的引用&lt;/h4&gt;

&lt;p&gt;markdown标记区块引用使用类似email中的&lt;code&gt;&amp;gt;&lt;/code&gt;引用方式,在每行前面加上&lt;code&gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;这是一个区块引用.
&amp;gt;
&amp;gt;这是同一个区块引用.
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;这是一个区块引用.&lt;/p&gt;

&lt;p&gt;这是同一个区块引用.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;可以只在整个段落前面加上&lt;code&gt;&amp;gt;&lt;/code&gt;,而不必每行前面加&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;支持嵌套引用,根据层次加上不同数量的&lt;code&gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;第一层引用
&amp;gt;
&amp;gt;&amp;gt;第二层引用
&amp;gt;&amp;gt;
&amp;gt;&amp;gt;第二层引用
&amp;gt;
&amp;gt;第一层引用
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;第一层引用&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;第二层引用&lt;/p&gt;

&lt;p&gt;第二层引用&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;第一层引用&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;引用区块内可以使用markdown语法,包括标题,列表,代码区块等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;## 标题
&amp;gt;
&amp;gt;1. 表项1
&amp;gt;2. 表项2
&amp;gt;
&amp;gt;代码例子
&amp;gt;     return shell_exec(&quot;echo $input  | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;h2&gt;标题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;表项1&lt;/li&gt;
&lt;li&gt;表项2&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;代码例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return shell_exec(&quot;echo $input  | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h4&gt;列表&lt;/h4&gt;

&lt;p&gt;markdown支持有序列表和无序列表&lt;/p&gt;

&lt;p&gt;无序列表使用&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;+&lt;/code&gt;或者&lt;code&gt;-&lt;/code&gt;作为列表标记:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Red
* Green
* Blue
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Greed&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;有序列表用数字加英文句点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Bird
2. McHale
3. Parish
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;重要的是有序列表前面的数字不影响实际生成的HTML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Bird
2. McHale
1. Parish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和前面生成的是一样的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;列表标记通常放在最左边,但是其实可以缩进,最多3个空格,项目标记后面则一定要接至少一个空格或制表符(否则错误,显示非列表)&lt;/p&gt;

&lt;p&gt;如果列表项目间用空行分开,输出HTML时就会将项目内容用&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签包起来&lt;/p&gt;

&lt;p&gt;列表项目可以包含多个段落,但是每个项目下的段落都必须缩进4个空格或是一个制表符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 列表项目1

   列表项目1的第二个段落

2. 列表项目2
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;列表项目1&lt;/p&gt;

&lt;p&gt; 列表项目1的第二个段落&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表项目2&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;列表项目内放进引用&lt;code&gt;&amp;gt;&lt;/code&gt;要缩进&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 含引用的列表项

   &amp;gt;引用
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;含引用的列表项&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;引用&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果要放代码的话就要缩进&lt;em&gt;两次&lt;/em&gt;,也就是8个空格或者两个制表符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 含有代码的列表

    代码
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;含有代码的列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  代码
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;列表中可能会有下面的内容,行首出现了&lt;code&gt;数字.空白&lt;/code&gt;,这是要加反斜杠转义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1986. What a great season
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;. What a great season&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;要改成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1986\. What a great season
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;1986. What a great season&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;代码区块&lt;/h4&gt;

&lt;p&gt;代码一般都已经排好版了,因此希望照原来的样子去显现,markdown会用&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;标签把代码区块包起来.&lt;/p&gt;

&lt;p&gt;代码区块在首部缩进4个空格或是1个制表符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;普通段落

    代码区块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通段落&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;代码区块
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown会转换成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;普通段落&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;代码区块
&amp;lt;/pre&amp;gt;&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一阶的缩进(4个空格或者是1个制表符),都会被移除,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;code example

    tell application &quot;Foo&quot;
         beep
    end tell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被转化成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;code example&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &quot;Foo&quot;
      beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示的时候是代码本身的缩进&lt;/p&gt;

&lt;p&gt;代码区块中的&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;会被转化成HTML实体,这样插入代码只要在前面加上缩进就可以了&lt;/p&gt;

&lt;h4&gt;分隔线&lt;/h4&gt;

&lt;p&gt;下面的都可以建立分隔线&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* * *

***

******

_ _ _

------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3&gt;区段元素&lt;/h3&gt;

&lt;h4&gt;链接&lt;/h4&gt;

&lt;p&gt;markdown支持两种形式的链接语法: 行内式和参考式.&lt;/p&gt;

&lt;p&gt;不管那一种都用[链接文字]来标记&lt;/p&gt;

&lt;p&gt;&lt;em&gt;行内式&lt;/em&gt;:方括号后面接圆括号并插入网址即可,网址后可加&quot;Title&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是[链接](http://google.com.cn/ &quot;Google&quot;) 到google
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会产生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是&amp;lt;a href=&quot;http://google.com.cn/&quot; title=&quot;Google&quot;&amp;gt;链接&amp;lt;/a&amp;gt; 到google&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;a href=&quot;http://google.com.cn/&quot; title=&quot;Google&quot;&gt;链接&lt;/a&gt;到google&lt;/p&gt;

&lt;p&gt;如果是链接到相同的主机资源,可以使用相对路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;See my [About](/about/) page for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;参考式&lt;/em&gt;:在链接文字的括号后面在接一个方括号,第二个方括号内填入用以表示链接的标记,两个方括号之间可以有一个空格:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是[链接][id],参考式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在文件的任意处把标记的链接内容定义出来(这个貌似在同一个链接多吃使用的时候蛮有用的)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id]: http://example.com/ &quot;OptionalTitle Here&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接内容的定义形式为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[方括号]:空格 链接地址 &quot;title&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接表示符可以有字母,数字,空白,标点,但是不区分大小写&lt;/p&gt;

&lt;p&gt;隐式链接标记&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Google][]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Google](http://google.com)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b][] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在任意地方定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b]: http://ab.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://ab.com/&quot;&gt;a b&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;强调&lt;/h4&gt;

&lt;p&gt;markdown使用&lt;code&gt;*&lt;/code&gt;和&lt;code&gt;_&lt;/code&gt;作为标记强调的符号,被&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;_&lt;/code&gt;包围的字词会被转成&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签包围,用两个&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;_&lt;/code&gt;包起来会被转成&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*单星*

_单下划线_

**双星**

__双下划线__
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;单星&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;单下划线&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双星&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双下划线&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;_&lt;/code&gt;两边都有空白的话,会被当成普通的符号&lt;/p&gt;

&lt;p&gt;要在文字前后插入&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;_&lt;/code&gt;,可以使用反斜杠转义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\*非重点\*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*非重点*&lt;/p&gt;

&lt;h4&gt;代码&lt;/h4&gt;

&lt;p&gt;段内代码可以用&lt;code&gt;`&lt;/code&gt;来标记&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用`printf()`函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;printf()&lt;/code&gt;函数&lt;/p&gt;

&lt;p&gt;会产生&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;使用&amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt;函数&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码区段要插入&lt;code&gt;`&lt;/code&gt;, 要用多个&lt;code&gt;`&lt;/code&gt;号来开启和结束代码区段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ``这里有一个反引号(`)``
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码段起始和结束段都可以放入一个空白,这样可以在区段中插入反引号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;代码段为单引号 `` ` ``

代码段开始结束有单引号 `` `foo` ``
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;图片&lt;/h4&gt;

&lt;p&gt;markdown使用和链接相似的方法来插入图片,也分为&lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;行内式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/726f37bejw1dziwtsc6y7j.jpg&quot; alt=&quot;头像&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Alt text][id]

[id]: url/to/image &quot;Optional title attribute&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是markdown无法指定图片宽高,如果要设定就得使用&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&quot;/url/to/image&quot; alt=&quot;Optional title&quot; height=&quot;50&quot; width=&quot;50&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/726f37bejw1dziwtsc6y7j.jpg&quot; alt=&quot;头像&quot; height=&quot;50&quot; width=&quot;50&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;其他&lt;/h3&gt;

&lt;h4&gt;自动链接&lt;/h4&gt;

&lt;p&gt;markdown支持以较短的自动链接的形式来处理网址和电子邮箱,只要用方括号包起来,markdown会自动把它转换为链接,网址的链接文字和链接地址一样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会转化成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;http://example.com&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;邮件地址链接也比较类似,只是markdown会先做一个编码转换的过程,把文字字符转换成16进制位码的HTML实体,这种格式可以糊弄一些不好的邮件手机机器人.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会转成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;a href=&quot;&amp;amp;#x6d;&amp;amp;#x61;&amp;amp;#x69;&amp;amp;#x6c;&amp;amp;#116;&amp;amp;#x6f;&amp;amp;#58;&amp;amp;#x61;&amp;amp;#100;&amp;amp;#100;&amp;amp;#x72;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#x40;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6c;&amp;amp;#101;&amp;amp;#x2e;&amp;amp;#99;&amp;amp;#x6f;&amp;amp;#109;&quot;&amp;gt;&amp;amp;#x61;&amp;amp;#100;&amp;amp;#x64;&amp;amp;#114;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#x40;&amp;amp;#x65;&amp;amp;#x78;&amp;amp;#97;&amp;amp;#109;&amp;amp;#112;&amp;amp;#108;&amp;amp;#101;&amp;amp;#46;&amp;amp;#99;&amp;amp;#111;&amp;amp;#x6d;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;反斜杠&lt;/h4&gt;

&lt;p&gt;markdown可以用反斜杠来插入一些在语法中有其他意义的符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\ 反斜杠

` 反引号

* 星号

_ 底线

{} 花括号

[] 方括号

() 括弧

# 井号

+ 加号

- 减号

. 英文句点

! 惊叹号
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.com/Jekyll/2012/12/07/markdown-tutorial</link>
                <guid>http://username.github.com/Jekyll/2012/12/07/markdown-tutorial</guid>
                <pubDate>2012-12-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>learning emacs</title>
                <description>&lt;h2&gt;Emacs&lt;/h2&gt;

&lt;h3&gt;Key&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Shift&lt;/code&gt;,&lt;code&gt;Control(Ctrl)&lt;/code&gt;,&lt;code&gt;Meta(Alt)&lt;/code&gt;(有时用&lt;code&gt;Esc&lt;/code&gt;来替代)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;C-F1&lt;/code&gt; 同时按&lt;code&gt;Ctrl&lt;/code&gt;和&lt;code&gt;F1&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;S-F1&lt;/code&gt; 同时按&lt;code&gt;Shift&lt;/code&gt;和&lt;code&gt;F1&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;M-F1&lt;/code&gt; 同时按&lt;code&gt;Meta&lt;/code&gt;和&lt;code&gt;F1&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;S-C-M-F1&lt;/code&gt; 或 &lt;code&gt;C-M-S-F1&lt;/code&gt; 按的顺序不重要&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;《Teach Yourself Emacs in 24Hours》一书内容忒旧了，不爽，算了，看手册学吧。&lt;/p&gt;

&lt;h3&gt;emacs快速指南&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;C-h t&lt;/code&gt;开启快速指南。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x C-c&lt;/code&gt;退出emacs&lt;/p&gt;

&lt;h4&gt;移动光标&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-v&lt;/code&gt; 看下一屏文字，移动到下一屏&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-v&lt;/code&gt; 看上一屏文字，移动到上一屏&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-l&lt;/code&gt; 重绘屏幕，将光标置于屏幕中央，连续按会轮回上下中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-p&lt;/code&gt; 光标移动到上一行 previous&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-n&lt;/code&gt; 光标移动到下一行 next&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-b&lt;/code&gt; 光标移动到左一列 backword&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-f&lt;/code&gt; 光标移动到右一列 forward&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-f&lt;/code&gt; 光标往前移动一个词&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-b&lt;/code&gt; 光标往后移动一个词&lt;/p&gt;

&lt;p&gt;惯例是&lt;code&gt;META&lt;/code&gt;系列&lt;em&gt;由语言定义的单位(词 句子 段落)&lt;/em&gt;, &lt;code&gt;CONTROL&lt;/code&gt;系列&lt;em&gt;与语言无关(字符 行)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-a&lt;/code&gt; 光标移动到一行的头部&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-e&lt;/code&gt; 光标移动到一行的尾部&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-a&lt;/code&gt; 光标移动到&quot;一句&quot;的头部&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-e&lt;/code&gt; 光标移动到&quot;一句&quot;的尾部&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-&amp;gt;&lt;/code&gt; 光标移动到文件开始&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-&amp;lt;&lt;/code&gt; 光标移动到文件结束&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-u&lt;/code&gt;+N+&lt;code&gt;命令&lt;/code&gt; 执行N次命令 也可以按住&lt;code&gt;META&lt;/code&gt;输入数字再输命令, &lt;code&gt;C-v&lt;/code&gt;和&lt;code&gt;
M-v&lt;/code&gt;的数值参数制定的是滚动的行数而不是屏数.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-g&lt;/code&gt; 终止命令 和 取消命令&lt;/p&gt;

&lt;p&gt;取消&lt;code&gt;Esc&lt;/code&gt;的方法是按&lt;code&gt;C-g&lt;/code&gt;或者再连按两次&lt;code&gt;Esc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;被禁用的命令&lt;/p&gt;

&lt;p&gt;一些命令被Emacs禁用了,输入这样的命令,Emacs会提醒你是否要继续,想要用就按&lt;code&gt;空格&lt;/code&gt;,否则就按&lt;code&gt;n&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;窗格(windows)&lt;/h4&gt;

&lt;p&gt;Emacs可以有多个窗格&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 1&lt;/code&gt;只保留一个窗格(关掉其他所有窗格)&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;C-x&lt;/code&gt;开头的命令多跟&quot;窗格,文件缓冲区&quot;有关&lt;/p&gt;

&lt;h4&gt;插入和删除&lt;/h4&gt;

&lt;p&gt;插入直接输入就行了, 插入支持多个相同字符的插入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-u 8 *&lt;/code&gt; 输入8个*&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Delback&lt;/code&gt; 删除光标前的一个字符, &lt;code&gt;Delback&lt;/code&gt;就是Backspace`&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-d&lt;/code&gt; 删除光标后的一个字符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-Delback&lt;/code&gt; 删除光标前的一个词&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-d&lt;/code&gt; 删除光标后的一个词&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-k&lt;/code&gt; 删除从光标到&lt;em&gt;行尾&lt;/em&gt;间的字符 单独的&lt;code&gt;C-k&lt;/code&gt;不消除行末的换行符,联系按两次&lt;code&gt;C-k&lt;/code&gt;消除一行及换行符,而&lt;code&gt;C-u 2 C-k&lt;/code&gt;消除两行,及两行的换行符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-k&lt;/code&gt; 删除从光标到&lt;em&gt;句尾&lt;/em&gt;间的字符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;d&lt;/code&gt;是&lt;code&gt;delete(删除)&lt;/code&gt;  &lt;code&gt;k&lt;/code&gt;是&lt;code&gt;kill(移除)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移除缓冲区里的任意一部分:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先把光标移动到想要移除的区域的一端,按&lt;code&gt;C-@&lt;/code&gt;设定mark(也可用&lt;code&gt;C-空格&lt;/code&gt;,但是这个一般被设定成输入法热键了).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将光标移动到另一端,按&lt;code&gt;C-w&lt;/code&gt;移除两段之间的文字&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;移除(kill)的东西可以找回来(只是看起来消失了而已),删除(delete)的东西无法找回. 重新插入被移除的东西被称为&quot;召回(yank)&quot;. 一般来说消除很多文字的命令会把消除的文字记录下来(&quot;可召回&quot;),而只删除一个字符或者直消除空白的命令不会记录被消除的内容(&quot;不可召回&quot;).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-y&lt;/code&gt; 召回(yanking),可以在任何位置召回,多次召回同样的文字.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-y&lt;/code&gt; 切换要召回的内容,先按&lt;code&gt;C-y&lt;/code&gt;再按&lt;code&gt;M-y&lt;/code&gt;会不断轮回召回的内容,下一次&lt;code&gt;C-y&lt;/code&gt;召回的内容和前次召回的内容相同,但是移除的内容太多了怎么办?&lt;/p&gt;

&lt;h4&gt;撤销(undo)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-x u&lt;/code&gt; 撤销命令的效果, 前一条命令有多个效果,如使用了重复数字,那么全都消除.&lt;/p&gt;

&lt;p&gt;两个例外&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;没改变文字的命令不算(移动光标和滚动命令)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从键盘输入的字符以组为单位(每组20个字符)来进行处理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;code&gt;C-_&lt;/code&gt; 也是撤销,和&lt;code&gt;C-x u&lt;/code&gt;作用一样,输入较少,但是较难按&lt;/p&gt;

&lt;h4&gt;文件(file)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-x C-f&lt;/code&gt; 寻找一个文件,屏幕最低端一行为小缓冲区(minibuffer),小缓冲区中也可以用Emacs命令来编辑文件名, 可用&lt;code&gt;C-g&lt;/code&gt;取消&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x C-s&lt;/code&gt; 保存文件&lt;/p&gt;

&lt;p&gt;第一次存盘的时候Emacs会将原文件重命名以备份. 重命名通常为源文件名后面加&quot;~&quot;, 可以通过&lt;code&gt;M-x customize-variable 回车 make-backup-files 回车&lt;/code&gt;来关掉&lt;/p&gt;

&lt;p&gt;查找一个不存在的文件就是新建该文件.&lt;/p&gt;

&lt;h4&gt;缓冲区(buffer)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-x C-f&lt;/code&gt;打开第二个文件后,第一个文件仍然在Emacs中,但是我们无法看到,要切回第一个文档可以用&lt;code&gt;C-x C-f&lt;/code&gt;,但是这样非常麻烦.&lt;/p&gt;

&lt;p&gt;Emacs把编辑中的文件放在&quot;缓冲区(buffer)&quot;, 没寻找到一个文件就在内部开辟一个缓冲区.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x C-b&lt;/code&gt; 列出缓冲区  还记的&lt;code&gt;C-x 1&lt;/code&gt;吗? 只保留一个窗格, 缓冲区没关的.&lt;/p&gt;

&lt;p&gt;不管有多少缓冲区,都只能有一个&lt;em&gt;当前&lt;/em&gt;缓冲区,当前正在编辑的缓冲区.&lt;/p&gt;

&lt;p&gt;切换缓冲区的方法:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x b 缓冲区名字&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;窗格中的任何文字都属于特定的缓冲区,但是缓冲区未必对应文件:比如显示缓冲区列表的缓冲区,或者&quot;&lt;em&gt;Messages&lt;/em&gt;&quot;缓冲区对应的是Emacs底部出现的消息.&lt;/p&gt;

&lt;p&gt;切换到另一缓冲区并不会保存当前缓冲区到文件,因此需要手动用&lt;code&gt;C-x C-s&lt;/code&gt;保存.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x s&lt;/code&gt;保存多个缓冲区&lt;/p&gt;

&lt;h4&gt;命令集的扩展&lt;/h4&gt;

&lt;p&gt;光用&lt;code&gt;control&lt;/code&gt;和&lt;code&gt;meta&lt;/code&gt;键无法表示所有命令,因此Emacs加入了扩展(eXtend)命令来解决这个问题(注意&lt;code&gt;eXtend&lt;/code&gt;), 扩展有两种风格:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 命令&lt;/code&gt; 字符扩展, &lt;code&gt;C-x&lt;/code&gt;之后输入另一个字符或者组合键 如&lt;code&gt;C-x C-f&lt;/code&gt; &lt;code&gt;C-x C-c&lt;/code&gt; &lt;code&gt;C-x C-s&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-x 命令&lt;/code&gt; 命令名扩展, &lt;code&gt;M-x&lt;/code&gt; 之后输入一个命令名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-z&lt;/code&gt; 暂停Emacs 暂时离开Emacs, 可以通过&lt;code&gt;fg&lt;/code&gt;或者&lt;code&gt;%emacs&lt;/code&gt;命令唤回,一般情况下不用&lt;code&gt;C-x C-c&lt;/code&gt;推出,用&lt;code&gt;C-z&lt;/code&gt;暂停就好了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;复习&lt;/em&gt;
&lt;code&gt;C-x C-f&lt;/code&gt; 寻找文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x C-s&lt;/code&gt; 保存文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x C-b&lt;/code&gt; 列出缓冲区&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x C-c&lt;/code&gt; 推出Emacs&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 1&lt;/code&gt; 关掉其他窗格&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x u&lt;/code&gt; 撤销&lt;/p&gt;

&lt;p&gt;命令扩展不常用或者只用在部分模式下&lt;/p&gt;

&lt;p&gt;输入&lt;code&gt;M-x&lt;/code&gt; 再输入&lt;code&gt;replace-string&lt;/code&gt;(&lt;code&gt;repl s TAB&lt;/code&gt;补全)再按回车后如入被替换字符和替换字符.&lt;/p&gt;

&lt;h4&gt;自动保存(auto save)&lt;/h4&gt;

&lt;p&gt;Emacs会定期自动保存,文件名头尾会有&quot;#&quot;,正常存盘后会被删掉.&lt;/p&gt;

&lt;p&gt;加入悲剧发生了,打开源文件(不是自动保存文件)输入&lt;code&gt;M-x recover file 回车&lt;/code&gt;就可以恢复自动保存的文件了.&lt;/p&gt;

&lt;h4&gt;回显区(echo area)&lt;/h4&gt;

&lt;p&gt;如果输入多字符命令节奏很慢，Emacs会在窗格下方最下面一行的&quot;回显区&quot;给出提示&lt;/p&gt;

&lt;h4&gt;状态栏(mode line)&lt;/h4&gt;

&lt;p&gt;位于回显区上面一行&lt;/p&gt;

&lt;p&gt;小括号里的为当前的编辑模式,缺省为Fundamental模式,它是一种&quot;主模式&quot;,任何情况下只能应用一个主模式&lt;/p&gt;

&lt;p&gt;Emacs的主模式很多 Lisp模式, Text模式.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-x fundamental-mode&lt;/code&gt; 开启Fundamental模式&lt;/p&gt;

&lt;p&gt;主模式通常会有些小动作,很多命令完成相同工作,但是在不同环境下有不同的工作方式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h m&lt;/code&gt; 可以查看当前模式的文档&lt;/p&gt;

&lt;p&gt;除了主模式(major)外, 还有&lt;em&gt;辅模式(minor)&lt;/em&gt;,辅模式不能替代主模式,但是可以增加一些辅助功能,每个辅模式可以单独开启和关闭,和其他辅模式无关.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Auto Fill&lt;/code&gt; 自动换行辅模式 &lt;code&gt;M-x auto fill mode&lt;/code&gt;自动开启折行模式,再用这个命令关闭折行模式, 这种开关模式是&quot;开关(toggle)&quot;模式&lt;/p&gt;

&lt;p&gt;行边界通常设定为70个字符,可以使用&lt;code&gt;C-x f&lt;/code&gt; 配合数字参数来重新设定.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-u 20 C-x f&lt;/code&gt; 将行边界设定为20个字符,对英文字符有用,对中文字符无效&lt;/p&gt;

&lt;p&gt;&lt;code&gt;M-q&lt;/code&gt; 进行手动折行&lt;/p&gt;

&lt;h4&gt;搜索(searching)&lt;/h4&gt;

&lt;p&gt;Emacs的搜索是渐进的(incremental)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-s&lt;/code&gt; 前向搜索 按&lt;code&gt;C-s&lt;/code&gt;跳到下一个搜索结果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-r&lt;/code&gt; 后向搜索 按&lt;code&gt;C-r&lt;/code&gt;跳到上一个搜索结果  &lt;code&gt;C-g&lt;/code&gt; 让光标回到搜索开始的位置,而按回车光标到搜索的结果上&lt;/p&gt;

&lt;p&gt;某些终端按&lt;code&gt;C-x C-s&lt;/code&gt;会冻结屏幕,按&lt;code&gt;C-q&lt;/code&gt; 可以解冻&lt;/p&gt;

&lt;h4&gt;多窗格(multiple window)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-u N C-l&lt;/code&gt; 貌似是使当前光标所在行移动到屏幕第N行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 1&lt;/code&gt; 只保留当前窗格&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 2&lt;/code&gt; 水平开一个新的窗格, 窗格内的内容与当前窗格相同&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 3&lt;/code&gt; 垂直开一个新的窗格, 窗格内的内容与当前窗格相同&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-M-v&lt;/code&gt; 滚动下方的窗格, 但是貌似和evernote的热键重了,可以用&lt;code&gt;Esc C-v&lt;/code&gt;来代替的,这个命令在多窗口时很有用的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x o&lt;/code&gt; 光标移动到另一窗格&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 4 C-f 文件名&lt;/code&gt; 可以在新的窗格里面打开文件&lt;/p&gt;

&lt;h4&gt;递归编辑(recursive editing levels)&lt;/h4&gt;

&lt;p&gt;模式名称外面有[]时就是进入了递归编辑,比如用&lt;code&gt;M-%&lt;/code&gt;进行交互式替换的时候又进行了&lt;code&gt;C-s&lt;/code&gt;进行搜索,这是替换模式没有结束,但是你又进入了搜索模式,就是所谓的递归编辑&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;Esc Esc Esc&lt;/code&gt;可以离开递归编辑,这个命令可以用来关闭多于的窗格或者离开小缓冲区&lt;/p&gt;

&lt;p&gt;不能用&lt;code&gt;C-g&lt;/code&gt;来取消递归编辑,因为这是取消&quot;本层递归编辑之内&quot;的命令和参数&lt;/p&gt;

&lt;h4&gt;转码&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-x 回车 r&lt;/code&gt;(也可用&lt;code&gt;M-x revert-buffer-with-coding-system&lt;/code&gt;) 再输入编码方式比如UTF-8或者Chinese-GB等来进行转码&lt;/p&gt;

&lt;h4&gt;特殊字符的输入&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-x 8 R&lt;/code&gt; ® (utf-8)下无法显示?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 8 o&lt;/code&gt; °&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-x 8 C-h&lt;/code&gt; 可以有一份完整的列表&lt;/p&gt;

&lt;h4&gt;获取更多的帮助(getting more help) 这个相当重要啊&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;C-h&lt;/code&gt; 是帮助字符,所有查看命令文档的文档都是以这个字符开头的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h ?&lt;/code&gt; 帮助提供了那些帮助&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h c 组合键&lt;/code&gt; Emacs给出该组合键的简要说明 例如&lt;code&gt;C-h c C-p&lt;/code&gt; 给出了&lt;code&gt;C-p&lt;/code&gt;的功能说明&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h k 组合键&lt;/code&gt; 给出了详细说明&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h f 函数名&lt;/code&gt; 给出函数的解释&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h v&lt;/code&gt; 显示Emacs变量的文档. Emacs可以被用来&quot;定制Emacs的行为&quot;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h a 关键词&lt;/code&gt; 搜索相关的命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-h i&lt;/code&gt; 阅读联机手册(Info), &lt;em&gt;之后就靠Emacs Info了&lt;/em&gt;, &lt;code&gt;C-h i ?&lt;/code&gt;联机手册指导&lt;/p&gt;

&lt;h4&gt;更多精彩(more features)&lt;/h4&gt;

&lt;p&gt;Emacs使用手册 &lt;code&gt;F10 h r&lt;/code&gt; 如 completion(自动补全), dired(目录编辑)&lt;/p&gt;

&lt;h3&gt;暂时结束,先使用,再学习高端技巧,还是需要先看tutorial啊.&lt;/h3&gt;
</description>
                <link>http://username.github.com/learning/2012/12/05/learning-emacs</link>
                <guid>http://username.github.com/learning/2012/12/05/learning-emacs</guid>
                <pubDate>2012-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>初始Linux shell和走进shell chapter1&2 LCLSS</title>
                <description>&lt;h1&gt;第一部分linux命令行&lt;/h1&gt;

&lt;h2&gt;第一章初始Linux shell&lt;/h2&gt;

&lt;h2&gt;1.1 什么是Linux&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;linux内核&lt;/li&gt;
&lt;li&gt;GNU工具逐渐&lt;/li&gt;
&lt;li&gt;图形化桌面环境&lt;/li&gt;
&lt;li&gt;应用软件&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;（擦类，图怎么办？手动画吗？）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;linux系统图&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;内核的基本功能&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统内存管理&lt;/li&gt;
&lt;li&gt;软件程序管理&lt;/li&gt;
&lt;li&gt;硬件设备管理&lt;/li&gt;
&lt;li&gt;文件系统管理&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;系统内存管理&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;物理内存&lt;/code&gt;, &lt;code&gt;虚拟内存&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;交换空间(swap space)&lt;/code&gt;, &lt;code&gt;页面(page)&lt;/code&gt;,&lt;code&gt;换出(swapping out)&lt;/code&gt;,&lt;code&gt;换入(swapping in)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/proc/meminfo&lt;/code&gt;可以查看系统上虚拟内存当前状态&lt;/p&gt;

&lt;p&gt;一般情况下每个进程都有独立的内存页面,但是也可以创建一些共享页面,多个进程可以在同一块公用内存区域进行读取和写入操作.内核负责维护和管理这块公共内存区域并控制每个进程访问共享区域.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ipcs -m&lt;/code&gt;  可以查看系统上当前的共享内存页面.&lt;/p&gt;

&lt;h4&gt;软件程序管理&lt;/h4&gt;

&lt;p&gt;Linux操作系统中的程序是&lt;strong&gt;进程&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;进程-1前台-2后台&lt;/p&gt;

&lt;p&gt;内核创建第一个进程&lt;code&gt;init进程&lt;/code&gt;来启动系统上所有其他进程.&lt;/p&gt;

&lt;p&gt;内核启动,先加载init进程.内核启动其他任何进程,都会在虚拟内存中给新的进程分配一块专有的区域来存储进程用到的数据和代码.&lt;/p&gt;

&lt;p&gt;有些linux发行版使用一个表来管理系统开机是要自动启动的进程.这个表一般在&lt;code&gt;/etc/inittab&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;有些在&lt;code&gt;/etc/init.d&lt;/code&gt;目录中,将开机时启动或停止某个应用的脚本放在这个目录下,这些脚本通过&lt;code&gt;/etc/rcX.d&lt;/code&gt;目录下的入口启动,这里的&lt;code&gt;X&lt;/code&gt;代表运行级(run level).&lt;/p&gt;

&lt;p&gt;Linux 操作系统的init系统采用了运行级.运行级决定了init进程运行&lt;code&gt;/etc/inittab&lt;/code&gt;或&lt;code&gt;/etc/rcX.d&lt;/code&gt;目录中定义好的某些特定类型的进程. Linux有5个运行级.&lt;/p&gt;

&lt;p&gt;运行级1-单用户模式,基本系统进程启动,同时启动唯一一个控制台终端进程, 紧急文件系统维护.&lt;/p&gt;

&lt;p&gt;运行级3-标准模式,大多数应用软件会启动.&lt;/p&gt;

&lt;p&gt;运行级5-会运行X Window系统,允许用户通过图形化桌面窗口登陆系统.&lt;/p&gt;

&lt;p&gt;可以通过调整运行级来控制整个系统的功能.通过将运行级从3调整到5,系统从基于控制台的系统变成图形化X Window系统.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps ax&lt;/code&gt;命令查看当前Linux上的进程.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;进程号&lt;/em&gt;(Process ID, PID), init的进程号是1,每个进程的进程号都唯一,(S睡眠,SW睡眠和等待,R运行),名字外的方括号表示进程被换出.&lt;/p&gt;

&lt;h4&gt;硬件设备管理&lt;/h4&gt;

&lt;p&gt;驱动程序代码(driver code)&lt;/p&gt;

&lt;p&gt;两种方法来插入设备驱动代码:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编译进内核的设备驱动代码&lt;/li&gt;
&lt;li&gt;可插入内核的设备驱动模块&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;设备文件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;字符型设备文件,每次只能处理一个字符,大多数调制解调器和终端&lt;/li&gt;
&lt;li&gt;块设备文件, 每次能处理大块数据的设备,硬盘&lt;/li&gt;
&lt;li&gt;网络设备文件, 采用数据包发送和接受数据的设备,网卡和一个特殊的回环设备.回环设备可以使用通用网络编程协议同自己通信.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Linux为系统上的每个设备都创建一种特殊的文件,&lt;code&gt;节点&lt;/code&gt;.与设备的通信都是通过设备节点完成的.每个节点有一个唯一的数值对,供Linxu内核标记它.数值对包括一个主设备号和一个次设备号.类似的设备被划分在同样的主设备号下.次设备号标识同一主设备号下的特殊设备.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/dev&lt;/code&gt;下是设备文件.文件的信息的第一列表明了设备类型,&lt;code&gt;b&lt;/code&gt; 块设备, &lt;code&gt;c&lt;/code&gt;字符设备.&lt;/p&gt;

&lt;h4&gt;文件系统管理&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;ext3&lt;/td&gt;
        &lt;td&gt;第三扩展文件系统,支持日志功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;ext4&lt;/td&gt;
        &lt;td&gt;第四扩展文件系统,支持高级日志功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;iso9660&lt;/td&gt;
        &lt;td&gt;ISO 9660文件系统(CD-ROM)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;minix&lt;/td&gt;
        &lt;td&gt;minix文件系统&lt;/td&gt;
    &lt;tr&gt;
    &lt;tr&gt;
        &lt;td&gt;msdos&lt;/td&gt;
        &lt;td&gt;微软FAT16文件系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;ntfs&lt;/td&gt;
        &lt;td&gt;支持Microsoft NT文件系统&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;Linux内核采用虚拟文件系统(Virtual File System, VFS)作为和每个文件系统交互的接口.这为linux内核同任何类型文件系统通信提供了一个标准接口,当每个文件系统被挂载和使用时,VFS将信息都缓存在内存中.&lt;/p&gt;

&lt;h3&gt;1.1.2 GNU工具链&lt;/h3&gt;

&lt;p&gt;GNU GNU is not Unix&lt;/p&gt;

&lt;h4&gt;1. 核心GNU工具链&lt;/h4&gt;

&lt;p&gt;为Linux系统提供的一组核心工具被称为&lt;strong&gt;coreutils&lt;/strong&gt;(core utilities)软件包.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用以处理文件的工具&lt;/li&gt;
&lt;li&gt;用以操作文本的工具&lt;/li&gt;
&lt;li&gt;用以管理进程的工具&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;2. shell&lt;/h4&gt;

&lt;p&gt;shell是个交互工具,为用户提供了启动程序,管理文件系统上的文件以及管理管理运行在Linux系统上进程的途径.&lt;/p&gt;

&lt;p&gt;shell的核心是命令行提示符.&lt;/p&gt;

&lt;p&gt;shell脚本&lt;/p&gt;

&lt;table&gt;
 &lt;/tr&gt;
  &lt;td&gt;bash&lt;/td&gt;
  &lt;td&gt;标准shell&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
  &lt;td&gt;ash&lt;/td&gt;
  &lt;td&gt;轻量级shell,与bash兼容&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
  &lt;td&gt;korn&lt;/td&gt;
  &lt;td&gt;与Bourne shell兼容,但是支持一些高级编程特性&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
  &lt;td&gt;tcsh&lt;/td&gt;
  &lt;td&gt;将C语言中的一些元素引入到shell中&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
  &lt;td&gt;zsh&lt;/td&gt;
  &lt;td&gt;将bash,tcsh和korn的特性引入同时提供高级编程特性,共享历史文件和主体化提示符的高级shell&lt;/td&gt;
 &lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;1.1.3 Linux 桌面环境&lt;/h3&gt;

&lt;h4&gt;1 X Window系统&lt;/h4&gt;

&lt;p&gt;X Window软件是图形显示的核心元素, 直接和PC上的显卡以及显示器一起工作的底层软件.&lt;/p&gt;

&lt;p&gt;XFree86&lt;/p&gt;

&lt;p&gt;X.org&lt;/p&gt;

&lt;p&gt;要在X Window系统软件之上建立桌面环境&lt;/p&gt;

&lt;h4&gt;2 KDE桌面&lt;/h4&gt;

&lt;p&gt;KDE(K Desktop Environment, K 桌面环境)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;KDE菜单&lt;/li&gt;
&lt;li&gt;程序快捷方式&lt;/li&gt;
&lt;li&gt;任务栏&lt;/li&gt;
&lt;li&gt;小应用程序&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3 GNOME桌面&lt;/h4&gt;

&lt;p&gt;GNOME(The GNU Network Object Model Environment, GNU网络对象模拟环境)&lt;/p&gt;

&lt;h4&gt;其他桌面&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;fluxbox&lt;/li&gt;
&lt;li&gt;xfce&lt;/li&gt;
&lt;li&gt;JWM&lt;/li&gt;
&lt;li&gt;fvwm&lt;/li&gt;
&lt;li&gt;fvwm95&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h3&gt;1.2 Linux 发行版本&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;完整的核心Linux发行版.&lt;/li&gt;
&lt;li&gt;专业发行版.&lt;/li&gt;
&lt;li&gt;LiveCD测试发行版.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;1.2.1 核心Linux发行版&lt;/h3&gt;

&lt;p&gt;包含&lt;em&gt;内核&lt;/em&gt;,一个或多个&lt;em&gt;图像化桌面环境&lt;/em&gt;以及&lt;em&gt;linux应用&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Slackware&lt;/li&gt;
&lt;li&gt;Red Hat&lt;/li&gt;
&lt;li&gt;Fedora&lt;/li&gt;
&lt;li&gt;Gentoo&lt;/li&gt;
&lt;li&gt;Mandriva&lt;/li&gt;
&lt;li&gt;openSuSE&lt;/li&gt;
&lt;li&gt;Debian&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;1.2.2 专业Linux发行版&lt;/h3&gt;

&lt;p&gt;基于某个主流发行版,但仅包含主流发行版中的一小部分用于某种特定用途的程序.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Xandros&lt;/li&gt;
&lt;li&gt;SimplyMEPIS&lt;/li&gt;
&lt;li&gt;Ubuntu&lt;/li&gt;
&lt;li&gt;PCLinusOS&lt;/li&gt;
&lt;li&gt;Mint&lt;/li&gt;
&lt;li&gt;dyne:bolic&lt;/li&gt;
&lt;li&gt;Puppy Linux&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;1.2.3 Linux LiveCD&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Knoppix&lt;/li&gt;
&lt;li&gt;SimplyMEPIS&lt;/li&gt;
&lt;li&gt;PCLinuxOS&lt;/li&gt;
&lt;li&gt;Ubuntu&lt;/li&gt;
&lt;li&gt;Slax&lt;/li&gt;
&lt;li&gt;Puppy Linux&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;h1&gt;第2章 走进shell&lt;/h1&gt;

&lt;h2&gt;2.1 终端模拟&lt;/h2&gt;

&lt;p&gt;命令行界面(CLI, Command Line Interface)&lt;/p&gt;

&lt;p&gt;哑终端(dumb terminal)&lt;/p&gt;

&lt;p&gt;Linux控制台&lt;/p&gt;

&lt;p&gt;终端模拟包&lt;/p&gt;

&lt;p&gt;哑终端-图形功能和键盘&lt;/p&gt;

&lt;h3&gt;2.1.1 图形功能&lt;/h3&gt;

&lt;h4&gt;1. 字符集&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;字符集&lt;/em&gt;是一组二进制命令,Linux可以将他们发给显示器来显示字符.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ASCII&lt;/li&gt;
&lt;li&gt;ISO-8859-1 (Latin-1)&lt;/li&gt;
&lt;li&gt;ISO-8859-2&lt;/li&gt;
&lt;li&gt;ISO-8859-6&lt;/li&gt;
&lt;li&gt;ISO-8859-7&lt;/li&gt;
&lt;li&gt;ISO-8859-8&lt;/li&gt;
&lt;li&gt;ISO-10646 (Unicode), 越来越流行,包含上面的&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;2. 控制码&lt;/h4&gt;

&lt;p&gt;终端控制显示器和键盘上的特殊功能,比如光标的位置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;回车(光标返回到行首)&lt;/code&gt;, &lt;code&gt;换行(光标放到下一水平行)&lt;/code&gt;, &lt;code&gt;水平制表符(光标移动指定数目的空格)&lt;/code&gt;,&lt;code&gt;方向键(上,下,左,右)&lt;/code&gt;, &lt;code&gt;翻页符(上翻,下翻)&lt;/code&gt;
还有清空整个屏幕,铃声等&lt;/p&gt;

&lt;p&gt;控制码可以用来控制哑终端的通信功能,&lt;code&gt;XON&lt;/code&gt;,&lt;code&gt;XOFF&lt;/code&gt; 开启, 停止到终端的数据传输&lt;/p&gt;

&lt;h4&gt;3. 块模式图形&lt;/h4&gt;

&lt;p&gt;ANSI字符集包含的代码不但允许显示器显示文本,也允许显示器显示基本的图形符号,比如框,线,块等&lt;/p&gt;

&lt;h4&gt;4. 矢量图形&lt;/h4&gt;

&lt;h4&gt;5. 显示缓冲&lt;/h4&gt;

&lt;p&gt;滚动区域(scroll region)&lt;/p&gt;

&lt;p&gt;替代屏幕(alternative screen)&lt;/p&gt;

&lt;h4&gt;6. 色彩&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;加粗字符&lt;/li&gt;
&lt;li&gt;下划线字符&lt;/li&gt;
&lt;li&gt;图像反转(黑底白字)&lt;/li&gt;
&lt;li&gt;闪烁&lt;/li&gt;
&lt;li&gt;组合&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;2.1.2 键盘&lt;/h3&gt;

&lt;p&gt;特殊键&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;中断(Break)&lt;/li&gt;
&lt;li&gt;滚动锁定(Scroll Lock)&lt;/li&gt;
&lt;li&gt;重复(Repeat)&lt;/li&gt;
&lt;li&gt;返回(Return)&lt;/li&gt;
&lt;li&gt;删除(Delete)&lt;/li&gt;
&lt;li&gt;方向键(Arrow key)&lt;/li&gt;
&lt;li&gt;功能键(Function Key)&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2.2 terminfo数据库&lt;/h2&gt;

&lt;p&gt;终端模拟包可以模拟不同类型的终端,通过一个环境变量和terminfo数据库文件来实现.&lt;/p&gt;

&lt;p&gt;terminfo 数据库是一组文件, 表示各种可用在Linux系统上的终端的特性,每种终端类型的terminfo数据作为一个单独的文件存储在terminfo数据库目录&lt;code&gt;/usr/share/terminfo&lt;/code&gt;,&lt;code&gt;/etc/terminfo&lt;/code&gt;,&lt;code&gt;/lib/terminfo&lt;/code&gt;等等&lt;/p&gt;

&lt;p&gt;terminfo是二进制文件,是编译文本文件的结果,这个文本文件含有定义了屏幕功能的代码字,以及在终端上实现这个功能的控制码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;infocmp&lt;/code&gt;命令将二进制条目转换成文本, 如&lt;code&gt;infocmp vt100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;terminfo 功能代码&lt;/p&gt;

&lt;p&gt;Linux shell使用&lt;code&gt;TERM&lt;/code&gt;环境变量来定义对特定会话使用terminfo数据库中的哪个终端模拟设置.如TERM设定为vt100时, shell知道使用vt100 terminfo数据库条目关联的控制码来向终端模拟器发送控制码.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo $TERM&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;2.3 Linux控制台&lt;/h2&gt;

&lt;p&gt;现代Linux,几个&lt;em&gt;虚拟控制台&lt;/em&gt;.运行在Linux系统内存总的一个终端会话,大部分会启动7个或者更多,&lt;code&gt;Ctrl+Alt+Fn&lt;/code&gt;来进入第n个控制台,其中一个或几个为X Window图形化桌面保留&lt;/p&gt;

&lt;h2&gt;2.4 xterm终端&lt;/h2&gt;

&lt;p&gt;xterm包提供了一个基本的VT102/VT220终端模拟CLI和一个图形化Tektronix 4014环境&lt;/p&gt;

&lt;h3&gt;2.4.1 命令行参数&lt;/h3&gt;

&lt;p&gt;加号将某个功能恢复为默认设置,减号将功能设为非默认值&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;xterm命令行参数&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;启动xterm时&lt;code&gt;-help&lt;/code&gt;参数来确定xterm实现了哪些参数&lt;/p&gt;

&lt;h3&gt;2.4.2 xterm主菜单&lt;/h3&gt;

&lt;p&gt;一般按&lt;code&gt;Ctrl 鼠标左键&lt;/code&gt;换出&lt;/p&gt;

&lt;h4&gt;1. X事件命令&lt;/h4&gt;

&lt;p&gt;xterm如何和X Window 显示交互的功能&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Toolbar(工具条) 同tb命令行参数&lt;/li&gt;
&lt;li&gt;Secure Keyboard(安全键盘) --将键盘限定在特定的xterm窗口中&lt;/li&gt;
&lt;li&gt;Allow SendEvents(允许发送事件) --允许这个xterm窗口接受其他X Window应用产生的X Window事件&lt;/li&gt;
&lt;li&gt;Redraw Window(重绘窗口)&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;2. 输出捕捉&lt;/h4&gt;

&lt;p&gt;xterm包允许捕捉显示在窗口总的数据&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Log to File(记录到文件)&lt;/li&gt;
&lt;li&gt;Print Window(打印窗口)&lt;/li&gt;
&lt;li&gt;Redirect to Printer(重定向到打印机)&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3. 键盘设置&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;8-bit Controls(8位控制)&lt;/li&gt;
&lt;li&gt;Back Arrow Key(后退方向键)&lt;/li&gt;
&lt;li&gt;Alt/Numlock Modifiers(Alt/Numlock修饰符)&lt;/li&gt;
&lt;li&gt;Alt Sends Escape(Alt 发送转义字符)&lt;/li&gt;
&lt;li&gt;Meta Sends Escape(Meta发送转义字符)&lt;/li&gt;
&lt;li&gt;Delete is DEL(删除键是DEL功能)&lt;/li&gt;
&lt;li&gt;Old Function Keys旧功能键&lt;/li&gt;
&lt;li&gt;Termcap Function Keys(Termcap功能键)&lt;/li&gt;
&lt;li&gt;Sun Function Keys&lt;/li&gt;
&lt;li&gt;VT220 Keyboard&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;设置键盘偏好通常取决于特定的应用和工作环境,还包括相当数量的个人偏好&lt;/p&gt;

&lt;h3&gt;2.4.3 VT选项&lt;/h3&gt;

&lt;p&gt;一般按&lt;code&gt;Ctrl 鼠标中键&lt;/code&gt;唤出&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;图2-5错误&lt;/p&gt;

&lt;hr /&gt;

&lt;h4&gt;1.VT功能&lt;/h4&gt;

&lt;h4&gt;2. VT命令&lt;/h4&gt;

&lt;h4&gt;3. 当前屏幕命令&lt;/h4&gt;

&lt;h3&gt;2.4.4 VT字体菜单&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Ctrl 鼠标右键&lt;/code&gt;唤出&lt;/p&gt;

&lt;h4&gt;1. 设置字体&lt;/h4&gt;

&lt;h4&gt;2. 显示字体&lt;/h4&gt;

&lt;h4&gt;3. 指定字体&lt;/h4&gt;

&lt;h2&gt;2.5 Konsole终端&lt;/h2&gt;

&lt;p&gt;KDE桌面项目创建的终端模拟包,不仅集成了xterm功能还有一些Windows应用中才有的高级功能&lt;/p&gt;

&lt;h3&gt;2.5.1 命令行参数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;konsole parameters&lt;/code&gt; 手动启动konsole&lt;/p&gt;

&lt;p&gt;Konsole命令行参数&lt;/p&gt;

&lt;h3&gt;2.5.2 标签式窗口会话&lt;/h3&gt;

&lt;p&gt;貌似这个比较高级啊.&lt;/p&gt;

&lt;h3&gt;2.5.3 配置文件&lt;/h3&gt;

&lt;p&gt;Konsole提供了配置文件(Profile)的强大方法来保存和重用标签会话的设置. 第一次启动Konsole时, 标签会话设置会从默认的配置文件Shell中提取, 这些设置包括使用什么Shell, 什么配色方案等等选项,修改了当前标签会话后, 可以将这些修改保存为一个新的配置文件.&lt;/p&gt;

&lt;p&gt;配置文件还能用来自动化普通任务,比如登陆到另外一个系统,可以定义许多配置文件并在每个打开的标签会话中使用不同的配置文件.可以用工具栏中的选项来新建配置,更改配置,切换配置.&lt;/p&gt;

&lt;h3&gt;2.5.4 菜单栏&lt;/h3&gt;

&lt;h2&gt;2.6 GNOME Terminal&lt;/h2&gt;

&lt;h3&gt;2.6.1 命令行参数&lt;/h3&gt;

&lt;h3&gt;2.6.2 标签&lt;/h3&gt;

&lt;h3&gt;2.6.3 菜单栏&lt;/h3&gt;
</description>
                <link>http://username.github.com/LCLSS/2012/12/05/chapter1_2-lclss</link>
                <guid>http://username.github.com/LCLSS/2012/12/05/chapter1_2-lclss</guid>
                <pubDate>2012-12-05T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
