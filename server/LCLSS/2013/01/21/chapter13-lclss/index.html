<link href="/assets/themes/twitter/css/pygments.css" rel="stylesheet">

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>处理用户输入 chapte13 LCLSS</title>
    <meta name="description" content="">
    <meta name="author" content="dogeyes">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">dogeyes</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="page-header">
  <h1>处理用户输入 chapte13 LCLSS </h1>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="date">
      <span>21 January 2013</strong>
    </div>
    <div class="content">
      <h1>第13章 处理用户输入</h1>

<h2>13.1 命令行参数</h2>

<pre><code>./addem 10 30
</code></pre>

<p>向脚本addem传递了两个参数10和30</p>

<h3>13.1.1 读取参数</h3>

<p><code>位置参数(positional parameter)</code> 分配给命令行输入的所有参数</p>

<p><code>$0</code>是程序名,<code>$1</code>是第一个参数,<code>$2</code>是第二个参数,...,<code>$9</code>是第九个参数 (最多只有9个参数吗?)</p>

<pre><code>factorial=1
for(( number = 1; number &lt;= $1; number++)
do
  factorial=$$[ $factorial *  $number ]
done
echo The factorial of $1 is $factorial
</code></pre>

<p>多个命令行参数</p>

<pre><code>total=$[ $1 * $2 ]
echo the first parameter is $1
echo the second parameter is $2
echo the total value is $total
</code></pre>

<p>参数当然也可以是<strong>字符串</strong></p>

<p>参数使用空格分隔的,当一个参数中包含空格时,参数要用引号包含</p>

<p>当参数多于9个的时候还是可以应用,但是方式要简单转换</p>

<pre><code>${11}
</code></pre>

<h3>13.1.2 读取程序名</h3>

<p><code>$0</code>参数来获取程序的名字</p>

<pre><code>echo The command entered is: $0
</code></pre>

<p>但是</p>

<pre><code>./test    调用的结果是./test
</code></pre>

<p>用</p>

<pre><code>/home/rich/test 调用的结果是/home/rich/test
</code></pre>

<p>使用<code>basename</code>命令,只返回程序名而不包括路径</p>

<pre><code>name=`basename $0`
echo the command entered is: $name
</code></pre>

<p>这样返回的就是test了</p>

<h3>13.1.3 测试参数</h3>

<p>使用数据之前有必要测试数据是否存在</p>

<pre><code>if [ -n $1 ]
then
    echo Hello $1, glad to meet you
else
    echo "Sorry, you did not identify yourself."
fi
</code></pre>

<h2>13.2 特殊参数变量</h2>

<h3>13.2.1 参数计数</h3>

<p><code>$#</code> 特殊变量含有脚本运行时就有的命令行参数个数</p>

<pre><code>if [ $# -ne 2 ]
then
   echo Usage: test9 a b
else
    total=$[ $1 + $2 ]
    echo the total is $total
fi
</code></pre>

<p>取命令行最后一个参数</p>

<pre><code>${!#}   注意$#不能使用,换成!#才能正常工作
</code></pre>

<h3>13.2.2 抓取所有的数据</h3>

<p><code>$*</code>和<code>$@</code>抓取命令行上所有参数</p>

<p><code>$*</code> 将所有参数存储为<em>一个</em>字符串</p>

<p><code>$@</code> 将所有参数存为一张表,参数之间相互分离</p>

<pre><code>count=1
for param in "$*"
do
   echo "\$* Parameter #$count = $param" 这里只执行一次
   count=$[ $count + 1 ]
done

count=1
for param in "$@"
do 
    echo "\$@ Parameter #$count = $param" 执行$#次
    count=$[ $count + 1 ]
done
</code></pre>

<h2>13.3 移动变量</h2>

<p><code>shift</code> 命令会根据它们的相对位置来移动命令行参数</p>

<p>默认情况下将每个参数变量减一,$3会变成$2,$2会变成$1,$1被删除,$0还是命令的名称</p>

<pre><code>count=1
while [ -n "$1" ]
do
    echo "Parameter #$count = $1"
    count=$[ $count + 1 ]
    shift
done
</code></pre>

<p><code>shift n</code> 来移动n位</p>

<h2>13.4 处理选项</h2>

<h3>13.4.1 查找选项</h3>

<h4>1. 处理简单的选项</h4>

<p>可以像处理参数一样用<code>shift</code>来处理选项</p>

<pre><code>while [ -n "$1" ]
do
    case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option" ;;
    -c) echo "Fount the -c option" ;;
    *) echo "$1 is not an option" ;;
    esac
    shift
done
</code></pre>

<h4>2. 分离参数和选项</h4>

<p><code>--</code>来表明选项结束,参数开始</p>

<pre><code>while [ -n "$1" ]
do
    case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option" ;;
    -c) echo "Found the -c option" ;;
    --) shift
        break ;;
    *) echo "$1 is not an option" ;;
    esac
    shift
done

count=1
for param in $@
do
    echo "Parameter #$count: $param"
    count=$[ $count + 1 ]
done
</code></pre>

<h4>3. 处理带值的选项</h4>

<pre><code>./test -a test1 -b -c -d test2
</code></pre>

<p>有些选项会带上一个额外的参数值</p>

<pre><code>while [ -n "$1" ]
do
    case "$1" in
    -a) echo "Found the -a option";;
    -b) param="$2"
        echo "Found the -b option, with parameter value $param"
        shift 2;;
    -c) echo "Found the -c option";;
    *) echo "$1 is not an option";;
    esac
    shift
done

count=1
for param in "$@"
do
    echo "Parameter #$count: $param"
    count=$[ $count + 1 ]
done
</code></pre>

<p>但是不能处理多个选项合并在一起的情况</p>

<pre><code>./test -ac
</code></pre>

<h3>13.4.2 使用getopt命令</h3>

<p>识别命令行参数</p>

<h4>1. 命令的格式</h4>

<p><code>getopt options optstring parameters</code></p>

<p>optstring 定义了命令行有效的选项字母, 还定义了哪些选项字母需要参数</p>

<p><code>getopt ab:cd -a -b test1 -cd test2 test3</code> 冒号表示有参数</p>

<p>上面的optstring定义了4个有效选项字母, a,b,c,d,b需要一个参数,会将-cd自动分成两个单独的选项,并插入双破折号来分开行中的额外参数.</p>

<p>如果指定了一个不再optstring中的选项,默认情况下会产生一条错误</p>

<pre><code>getopt ab:cd -a -b test1 -cde test2 test3
getopt: invalid option --e
-a -b test1 -c -d -- test2 test3
</code></pre>

<p>在命令后面加<code>-q</code>忽略这条信息</p>

<pre><code>getopt -q ab:cd -a -b test1 -cde test2 test3
</code></pre>

<h4>2. 在脚本中使用getopt</h4>

<p>使用getopt生成格式化输入给脚本的命令行选项,替换已有的命令行选项和参数</p>

<p><code>set</code>命令的选项之一'--', 会将命令行参数替换成set命令的命令行的值</p>

<pre><code>set -- `getopts -q ab:cd "$@"`
</code></pre>

<p>原始的命令行参数变量的值会被getopt命令的输出替换,而getopt已经格式化了命令行参数</p>

<pre><code>set -- `getopt -q ab:c "$@"`
while [ -n "$1" ]
do
    case "$1" in
    -a) echo "Found the -a option";;
    -b) param="$2"
        echo "Found the -b option, with parameter value $param";;
    -c) echo "Found the -c option";;
    --) shift
        break;;
    *) echo "$1 is not an option"
    esac
    shift
done

count=1
for param in "$@"
do
    echo "Parameter #$count: $param"
    count=$[ $count + 1 ]
done
</code></pre>

<p>getopt不擅长处理带空格的参数值,它会将空格当成参数的分隔符,而不是根据双引号将二者当成一个参数.</p>

<h3>13.4.2 使用更高级的getopts</h3>

<p><code>getopts optstring variable</code></p>

<p>optstring 和getopt中的optstring类似. 要去掉错误消息,在optstring之前加一个冒号., getopts会将当前参数保存在命令行中定义的<code>variable</code>中</p>

<p>getopts命令会用到两个环境变量,如果选项需要一个参数值,<code>OPTARG</code>环境变量会保存这个值, <code>OPTIND</code>环境变量保存了参数列表中getopts正在处理的参数位置</p>

<pre><code>while getopts :ab:c opt #最前面的:是忽略错误消息,当前选项在opt中
do
    case "$opt" in
    a) echo "Found the -a option";;
    b) echo "Found the -b option, with value $OPTARG";;
    c) echo "Found the -c option";;
    *) echo "Unknown option: $opt";;
    esac
done
</code></pre>

<p>getopts会返回状态码</p>

<p>getopts会移除选项开头的<code>-</code></p>

<p>getopts可以处理带空格的命令参数</p>

<p>getopts将命令行上未定义的选项同一输出成问号</p>

<p>在处理完选项后可以使用OPTIND和shift来移去已经处理过的选项</p>

<h2>13.5 将选项标准化</h2>

<p>当然可以自定义所有选项,但是有些字母选项已然约定俗成,遵守这样的规则可以更友好</p>

<h2>13.6 获得用户的输入</h2>

<p><code>read</code></p>

<h3>13.6.1 基本的读取</h3>

<p><code>read</code>命令接受从标准输入或另一个文件描述符的输入,在收到输入后,read命令会将数据放进一个标准变量</p>

<pre><code>echo -n "Enter your name"
read name #读入的值存在name中
echo "Hello $name, welcome to my program."
</code></pre>

<p><code>echo -n</code>移除了末尾的换行符,是的输出末尾不换行.</p>

<p><code>read -p "Please enter your age: " age # 直接指定了提示符</code></p>

<p>`read -p "Please enter your age: " first last #可以指定多个变量,如果输入的值多余变量值,那么多多的值会被分配到最后一个变量中.</p>

<p>如果不指定任何变量,那么得到的数据将被存储在<strong>REPLY</strong>环境变量中</p>

<h3>13.6.2 超时</h3>

<p><code>-t</code>选项指定read命令等待输入的秒数,当计时器过期后,read命令会返回一个非零状态退出码</p>

<pre><code>if read -t 5 -p "Please enter your name: " name
then
    echo "Hello $name, welcome to my script"
else
    echo
    echo "Sorry. too slow!"
fi
</code></pre>

<p>可以让read命令来对输入的字符进行计数,而非对输入过程进行计时,当输入的字符达到预设的字符数时,它会自动退出,将输入的数据赋给变量.</p>

<pre><code>read -n1 -p "Do you want to continue[Y/N]? " answer
case $answer in
Y | y) echo
       echo "fine. continue on...";;
N | n) echo
       echo OK.goodbye
       exit;;   
esac
echo "This is the end of the script"
</code></pre>

<p>n1表示输入一个字符read就结束</p>

<h3>13.6.3 隐藏方式读取</h3>

<p><code>-s</code>选项阻止将read命令的数据显示在显示器上(实际上,数据会被显示,read将文本颜色设成跟背景颜色一样)</p>

<pre><code>read -s -p "Enter your password: " pass
echo
echo "Is your password really $pass? "
</code></pre>

<h3>13.6.4 从文件中读取</h3>

<p>用<code>cat</code>命令将文件传给<code>read</code>命令,<code>read</code>每次读一行</p>

<pre><code>count=1
cat test | while read line
do
    echo "Line $count: $line"
    count=$[ $count + 1 ]
done
echo "Finished processing the file"
</code></pre>

    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
     
    	<li><a href="/categories.html#LCLSS-ref">
    		LCLSS <span>23</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#LCLSS-ref">LCLSS <span>23</span></a></li>
     
    	<li><a href="/tags.html#linux-ref">linux <span>23</span></a></li>
     
    	<li><a href="/tags.html#学习-ref">学习 <span>34</span></a></li>
     
    	<li><a href="/tags.html#command line-ref">command line <span>22</span></a></li>
    
  



    </ul>
    

    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/TPOP/2013/01/18/design-and-implementation" title="设计与实现">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next"><a href="/LCLSS/2013/01/26/chapter14-lclss" title="呈现数据 chapter14 LCLSS">Next &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </div>
</div>

      </div>
      <hr>
      <footer>
        <p>&copy; 2013 dogeyes
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div>

    
  </body>
</html>

