---
layout: post
title: "界面"
description: ""
category: TPOP 
tags: [学习, TPOP]
---
{% include JB/setup %}

#第4章 界面

在造墙之前,我必须设法弄清
该把什么放在墙里,什么放在墙外,
最需要防御的又是什么.
确实有些东西不喜欢墙,
总希望它倒下来.
---Robert Frost, <<修墙>>


设计的真谛,就是在一些相互冲突的需求和约束条件之间寻找平衡点.

在进行设计时,要考虑的问题

1. 界面: 应该提供哪些服务和访问? 界面在效能上实际成为服务的提供者和使用者之间的一个约定.同一方便的服务,功能足够丰富,但又不过多而无法控制.
2. 信息隐藏: 哪些信息可见,哪些不可见. 访问方便,同时隐藏实现细节.
3. 资源管理: 谁负责管理内存或者其他资源? 主要问题是存储的分配和释放,以及管理共享信息的拷贝等.
4. 错误处理: 谁检查错误,谁报告,如何恢复?

## 4.1 逗号分隔的值

逗号分隔的值(comma-separated value, CSV),用于表示表格数据的自然形式.

## 4.2 一个原型库

不大可能在第一次设计函数库或者界面时就做的很好."要计划扔掉一个,你总会这样做,无论以什么方式"

只有在已经构造和使用了程序的一个版本之后,才能对如何把系统设计正确有足够的认识

先搞出一个将要丢掉的,搞出一个原型.

strtok(p, s) 返回p中的一个标示符的指针,标示符完全由不再s中的字符构成. 第一次调用时p是原始字符串,而以后p是NULL,以从前一次调用结束的地方继续下去.(同时调用多个strtok会相互干扰)

    for(q = buf;(p = strtok(q, ",\n\r")) != NULL; q = NULL)
        field[nfield++] = unquote(p);

针对特定的数据可以进行处理,但是长的输入行,很多的数据域以及未预料到的或者欠缺的分隔符都可能造成大麻烦

一些需要仔细思考的问题

* 没有处理特别长的行,很多域,没有检查溢出,没有报错
* 假定输入是换行字符结尾的行组成
* 数据域由逗号分隔,数据域前后的引号被去除,没有考虑嵌套的引号和逗号
* 输入行没有保留, 在构造数据域的过程中将它覆盖掉了
* 在从一行输入转到另一行时没有保留任何数据,如果需要记录什么东西,那么就必须做一个拷贝
* 对数据域的访问通过全局变量,对数据域内容或指针的访问都没有任何控制,对超出最后一个域的访问也没有任何防御措施
* 使用全局变量,多线程环境无法使用,甚至不能两个交替进行的条用序列
* 调用库的程序必须显式打开或关闭文件
* 输入和划分操作纠缠在一起:每个调用读入一行并把它切分成一些域,不管实际应用中是否真的需要后一个服务
* 函数返回值表示输入行中的数据域个数,每行都被切分,无法把错误和文件结束区分开
* 除了改变代码外,没有任何办法来改变这些特性

但是如此多的改变都可以一起实现吗,如何实现?

## 4.3 为别人用的库

一个比较明确的需求是,csvgetline更健壮,使它能够处理很长的行和很多域,也必须能更仔细地剖析数据域

界面,信息隐藏,资源管理,错误处理

#### 界面

1. char* csvgetline(FILE*): 读取一个新CSV行
2. char* csvfield(int n): 返回当前行的第n个数据域
3. int csvfield(void): 返回当前行中数据域的个数


#### 信息隐藏

存储管理师对外隐藏的,到底是分配了一个大数组来存储行还是通过扩展来存储行

域的切分是在读取时进行的,还是在对数据域的访问时进行的也是对用户隐藏的

#### 资源管理

谁负责共享信息,返回原始数据还是返回一个拷贝

文件的管理,做文件打开的部分也应该负责关闭: 相互匹配的操作应该在同一个层次或位置完成.

在一个库与它的调用程序之间共享的,或者传递通过他们之间的界限的资源,管理起来总是很困难,这里经常出现一些合理而又相互矛盾的道理,要求我们做这种或者那种选择.在共享资源的责任方面常常出现错误或误解,这是程序错误最常见的根源之一.

#### 错误处理

错误通过返回来标记还是通过一个函数查询来标记

一个基本的原则是当错误发生时,库函数绝不能简单的死掉,而是应该把错误状态返回给调用程序,以便那里能采取适当的措施.另一方面,库函数也不应该输出错误信息,或者弹出一个会话框,因为这个程序将来可能运行在某些环境里,在那里这种信息可能干扰其他东西.

#### 规范

把上面的这些决定汇集在一起,就形成一个规范,它说明了csvgetline能够提供什么服务,应该如何使用.

在实践中规范和实现虽然可能来自不同的机构,但是两者一起发展.

规范最好及早提出,并随着实现中学到的新情况,对规范进行必要的修改.规范写的越精确越好,程序工作的很好的可能性就越大.

目前而言,规范包括函数原型,函数行为的细节描述,各种责任和假设:

* 域由都好分隔
* 一个域可能由一对双引号"..."括起
* 一个括起的域中可以包含逗号,但不能有换行
* 一个括起的域中可以包含双引号"本身, 表示为""
* 域可以为空; ""和一个空串都表示空的域
* 引导的和尾随的空格将预留
* char *csvgetline(FILE* f);</br>
从打开的文件f中读入一行;输入行以\r,\n,\r\n,或EOF结束;返回指向行的指针,行中结束符去掉;如果遇到EOF则返回NULL;行可以任意长,超出存储限度返回NULL;行必须当作只读存储看待;如果需要保存或修改,调用者必须自己建立拷贝.
* char *csvfield(int n);</br>
域从0开始;返回由csvgetline最近读入行的第n个域;如果n<0或者超出最后一个域,则返回NULL;域由逗号分隔;域可以用"..."括起来,这些引号将被去除;在"..."内部的""用"取代,内部逗号不作为分隔符.在没有引号括起来的域里,引号当作普通字符;允许有任意个数和任意长度的域;如果超出存储的限度,返回NULL;域必须当作只读存储看待;如果需要保存或修改,调用者必须自己建立拷贝;在调用csvgetline之前调用本函数,行为没有定义;
* int csvnfield(void);</br>
返回由csvgetline最近读入的行的域的个数;在调用csvgetline之前调用本函数,其行为没有定义.

还有许多问题没有被考虑,如EOF之后调用csvnfield和csvfield,将返回什么,具体错误形式的域将如何处理?


同文件包含函数声明，是界面的公共部分

通过static，使全局变量只在定义的文件中可见

## 4.4 c++实现

c可以通过struct进行封装

## 4.5 界面原则

界面定义了某个代码提为其用户提供的各种东西，定义了哪些功能或者数据元素可以为程序的其他部分使用

简单，通用，规范，其行为可以预料及坚固，还必须很好地适应用户或者实现方式的变化

#### 隐藏实现细节

信息隐蔽，封装，抽象，模块化

如果头文件里不包含实际结构的声明，而只有结构的名字，这种情况被称为模糊类型，其特性本身无法看到，所有操作都通过指针方式进行，实际的数据对象则潜藏在指针后面

避免使用全局变量，如果可能，数据通过函数参数传递

选择一小组正交的基本操作。 一个界面应该提供外界所需要的全部功能，但绝不要更多，函数在功能方面不应该有过度重叠。同一功能多种方式，这种冗余是要反对的。

窄的界面比宽的界面更受欢迎。做一件事并且把它做好。不要因为一个界面可能做某些事就给它增加这些东西。如果实现方面出了毛病那么就不要去修改界面。

不要在用户背后做小动作。一个库函数不应该写某个秘密文件、修改某个秘密变量，或者改变某些全局性数据，在改变调用者的数据时也要特别谨慎。


一个界面在使用时不应该强求另外的东西，如果这样做仅仅是为了设计者或实现者的某些方便。应该使界面成为自给自足。如果确实无法做到这一点，那么也应该把需要哪些外部服务的问题做成明显的。

在各处都用同样的方式做同样的事. 一致性和规范性非常重要,相关的事物应该有相关的意义.

外部一致性。 与其他东西的行为类似也是非常重要的。比如*是通配符等等


## 4.6 资源管理

在设计库的界面时，一个最困难的问题就是管理某些资源，这些资源是库所拥有的，而又在库和它的调用程序之间共享。最明显的资源是存储--谁负责分配和释放存储；打开的文件，共同关心的变量状态。

初始化，状态维护，共享和复制，清除

初始化方法

* 静态初始化
* 初始化函数
* 类的初始函数


终止和析构

资源的清理回收，文件的关闭


**释放资源与分配资源应该在同一层次进行**

资源的分配状态在跨过界面时不应该改变

废料收集机制， 收集动作发生的时间无法预期

代码可重入， 无论存在多少个同时的执行，它都应该能正常工作

可重入代码要求避免使用全局变量，静态局部变量，以及其他可能在别的线程里改变的变量

对于好的多线程设计，最关键的是做好各部件之间的隔离，使他们除了经过良好设计的界面外不再共享任何东西。随意把变量暴露出来共享的库就破坏了这个模型。 如果存在必须的共享变量，必须把他们放在某种锁定机制中，确保一次只有一个线程访问他们（Java的同步方法）

## 4.7 终止、重试或失败

eprintf 和 estrdup等函数

<stdarg.h>头文件,va_start初始化,va_end终止处理

错误发生时,有时终止不是一个好的选择,这将完全排除程序其他部分进行恢复的可能性.

在低层检查错误,在高层处理它们.一般情况下,应该由调用程序决定对错误的处理方式,而不该由被调用程序决定.尤其是库函数,应该以某种得体的失败方式在这方面起作用.

可以通过返回一个特定的值来标明特定的错误.

也可以返回单一异常值,再通过特定函数来读取错误信息

unix和c标准库的 errno变量和strerror函数

只把异常用在异常情况.对可预期的结果(如读到文件末尾等)不进行异常处理,而是返回特定值.异常最好留给那些无法预期的事件(如文件系统满或者浮点错误等等)

通过setjmp和longjmp可以实现一套异常处理机制

发生错误时应该如何恢复有关的资源,如果发生个错误,库函数应该做这种恢复吗?通常它们不做这些事,但也可以在这方面提供一些帮助:提供尽可能清楚的信息和以尽可能无害的方式退出

## 4.8 用户界面

显示的信息应该尽可能详细,不要简单的说发生错误,而应该标明哪个程序发生什么错误,在可能的情况下要指明正确的方式是什么.

防御性程序设计,保证程序在遇到坏的输入时本身不会受到损害.

图形用户界面. 很难做正确,通常实现交互的代码比实现所完成工作算法的代码更多

界面:简单性,清晰性,规范性,统一性,熟悉性,严谨性

对实现图形用户界面而言,面向对象的程序设计远胜于其他方法,因为它提供了一种途径,能够封装各种窗口的行为和状态细节,通过集成来取得基类的相似性,通过导出类区分相互的差异.

